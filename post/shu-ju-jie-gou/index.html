<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
<title>
    Mungeryang写字的地方
</title>
<!--[if lt IE 9]><script src="//cdn.bootcss.com/html5shiv/r29/html5.js"></script><![endif]-->
<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport" />
<meta http-equiv="x-dns-prefetch-control" content="on">
<link rel="dns-prefetch" href="https://fastly.jsdelivr.net">
<meta name="author" content="Mungeryang&#39;s Writting home">
<meta name="description" content="Share my technical route learning, reading notes, and life essays">
<meta name="keywords" content="book,code,life">
<script async src="//instant.page/3.0.0" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>
<link rel="stylesheet" href="https://Mungeryang.github.io/styles/main.css" />
<link href="https://fastly.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
<script type="text/javascript" src="https://apps.bdimg.com/libs/jquery/1.7.1/jquery.min.js"></script>

        <link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic/assets/media/css/style.min.css" />
        <script src="https://fastly.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic/assets/media/script/tocbot.min.js"></script>
        <script src="https://fastly.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic/assets/media/script/script.min.js"></script>
        <script src="https://fastly.jsdelivr.net/gh/itjoker233/Gridea-theme-Chic/assets/media/script/icon.min.js"></script>
        
            <script src="https://fastly.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@latest/CDN/js/Card/prism.min.js"></script>
            <link rel="stylesheet" href="https://fastly.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@latest/CDN/css/Card/prism.min.css" />
            <link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.css">
            <script defer src="https://fastly.jsdelivr.net/npm/katex@0.10.1/dist/katex.min.js"></script>
            
                <!--点击特效-->
                <script src="https://fastly.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@latest/CDN/js/love.min.js"></script>
                
                        <!--CDN样式-->
                        <script src="https://fastly.jsdelivr.net/gh/ITJoker233/ITJoker233.github.io@latest/CDN/js/hit-kounter-lc-0.3.0.js"></script>
                        <script src="https://cdn1.lncld.net/static/js/av-min-1.5.0.js"></script>
                        
                            <script>
                                (function() {
                                    var bp = document.createElement('script');
                                    var curProtocol = window.location.protocol.split(':')[0];
                                    if (curProtocol === 'https') {
                                        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
                                    } else {
                                        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
                                    }
                                    var s = document.getElementsByTagName("script")[0];
                                    s.parentNode.insertBefore(bp, s);
                                })();
                            </script>
                            
</head>

<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo">
                <a href="https://Mungeryang.github.io">
                    Mungeryang写字的地方
                </a>
            </div>
            <div id="tp-weather-widget"></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/">
                        扉页
                    </a>
                    
                    <a class="menu-item" href="https://Mungeryang.github.io/archives">
                        目录
                    </a>
                    
                    <a class="menu-item" href="https://Mungeryang.github.io/tags">
                        技术文集
                    </a>
                    
                    <a class="menu-item" href="https://Mungeryang.github.io/tags">
                        读书笔记
                    </a>
                    
                    <a class="menu-item" href="https://Mungeryang.github.io/tags">
                        生活随笔
                    </a>
                    
                    <a class="menu-item" href="/post/about">
                        About me
                    </a>
                    
                        <input id="switch_default" type="checkbox" class="switch_default">
                        <label for="switch_default" class="toggleBtn"></label>
            </div>
            <form id="gridea-search-form" data-update="1696728951294" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" autofocus="true" placeholder="Search...">
            </form>
        </div>
    </nav>

    
        <nav class="navbar-mobile" id="nav-mobile">
            <div class="container">
                <div class="navbar-header">
                    <div>
                        <a href="https://Mungeryang.github.io">
                            Mungeryang写字的地方
                        </a>
                        <!--en-->
                        <a id="mobile-toggle-theme-en" class="a en">&nbsp;Dark</a>
                        <!--zh-->
                        <a id="mobile-toggle-theme-zh" class="a zh">&nbsp;&#x6697;&#x9ED1;</a>
                    </div>
                    <form id="gridea-search-form" data-update="1696728951294" action="/search/index.html">
                        <input class="search-input" autocomplete="off" spellcheck="false" name="q" autofocus="true" placeholder="Search...">
                    </form>
                    <!--en-->
                    <div class="menu-toggle" id="menu-toggle-en" onclick="mobileBtn()">&#9776; Menu</div>
                    <!--zh-->
                    <div class="menu-toggle" id="menu-toggle-zh" onclick="mobileBtn()">&#9776; &#x83DC;&#x5355;</div>

                </div>
                <div class="menu" id="mobile-menu">
                    
                        <a class="menu-item" href="/">
                            扉页
                        </a>
                        
                        <a class="menu-item" href="https://Mungeryang.github.io/archives">
                            目录
                        </a>
                        
                        <a class="menu-item" href="https://Mungeryang.github.io/tags">
                            技术文集
                        </a>
                        
                        <a class="menu-item" href="https://Mungeryang.github.io/tags">
                            读书笔记
                        </a>
                        
                        <a class="menu-item" href="https://Mungeryang.github.io/tags">
                            生活随笔
                        </a>
                        
                        <a class="menu-item" href="/post/about">
                            About me
                        </a>
                        
                </div>
            </div>
        </nav>
</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementById("menu-toggle-en");
        var toggleMenu_zh = document.getElementById("menu-toggle-zh");

        var mobileMenu = document.getElementById("mobile-menu");
        if (toggleMenu.display != "none") {
            if (toggleMenu.classList.contains("active")) {
                toggleMenu.classList.remove("active")
                mobileMenu.classList.remove("active")
            } else {
                toggleMenu.classList.add("active")
                mobileMenu.classList.add("active")
            }
        } else if (toggleMenu_zh.display != "none") {
            if (toggleMenu_zh.classList.contains("active")) {
                toggleMenu_zh.classList.remove("active")
                mobileMenu.classList.remove("active")
            } else {
                toggleMenu_zh.classList.add("active")
                mobileMenu.classList.add("active")
            }
        }

    }
</script>



    <script>
        (function(a, h, g, f, e, d, c, b) {
            b = function() {
                d = h.createElement(g);
                c = h.getElementsByTagName(g)[0];
                d.src = e;
                d.charset = "utf-8";
                d.async = 1;
                c.parentNode.insertBefore(d, c)
            };
            a["SeniverseWeatherWidgetObject"] = f;
            a[f] || (a[f] = function() {
                (a[f].q = a[f].q || []).push(arguments)
            });
            a[f].l = +new Date();
            if (a.attachEvent) {
                a.attachEvent("onload", b)
            } else {
                a.addEventListener("load", b, false)
            }
        }(window, document, "script", "SeniverseWeatherWidget", "//cdn.sencdn.com/widget2/static/js/bundle.js?t=" + parseInt((new Date().getTime() / 100000000).toString(), 10)));
        window.SeniverseWeatherWidget('show', {
            flavor: "slim",
            location: "WWEFQFPJZ7T8",
            geolocation: true,
            language: "auto",
            unit: "c",
            theme: "auto",
            token: "61bcc333-3305-4728-9465-6785274bb0a3",
            hover: "enabled",
            container: "tp-weather-widget"
        })
    </script>
    
            <div class="main">
                <div class="container">
                    <article class="post-wrap">
                        <header class="post-header">
                            <h1 class="post-title">
                                数据结构与算法学习笔记
                            </h1>
                            
                                <!--en-->
                                <div class="post-meta en">
                                    Author:
                                    <a itemprop="author" rel="author" href="/">
                                        Mungeryang写字的地方
                                    </a>
                                    <span class="post-time">
                                Date: <a href="#">2023-09-05</a>
                            </span>
                                    <span class="post-readtime">Reading Time:<a
                                    href="#">126.8
                                    mins</a></span>
                                    <span class="post-words">words:<a href="#">28789</a></span>
                                    
                                        <span class="post-category">
                                Category:
                                
                                <a href="https://Mungeryang.github.io/tag/tech/">技术文集</a>
                                
                            </span>
                                        
                                            Views:
                                            <span data-hk-page="current"> - </span>
                                            
                                </div>
                                
                        </header>
                        
                        <div class="post-content">
                            <blockquote>
<p>你陪了我多少年，花开花落，一路上起起跌跌。——江南</p>
</blockquote>
<blockquote>
<p>天下大事，必作于细——侯捷</p>
</blockquote>
<figure data-type="image" tabindex="1"><img src="https://Mungeryang.github.io/post-images/1693901260116.jpg" alt="" loading="lazy"></figure>
<p><strong>写在前面：</strong></p>
<p>2022.06.20漫长的暑假开始了，总要做些什么。做啥？——当然是做好本手儿（2022年高考学的词哈哈~）</p>
<p>付东来大哥的这本书是2022.03.26购入，那是大二下学期的开学后不久。一个学期囫囵吞枣的看了一遍，没有get到精髓部分，代码看着很明白，自己写着错误百出。于是计划利用好这个稍微漫长的暑假，认认真真学好数据结构与算法。</p>
<p>这份总结是杨桂淼©（作者本人）基于力扣平台的题目，参考付东来大哥的解题思路编写；东来大哥每道题都给出了基于Java的解题思路，但是目前阶段本人Java语言掌握一般。于是乎，借鉴东来大哥的思路，将题目全部运用python语言实现。随着本人的不断学习积累，完善后代码会全部开源到杨桂淼的GitHub仓库中，届时，欢迎各位大佬评阅斧正；欢迎各位志同道合的同志交流学习！</p>
<p>本人秉持东来大哥的理念——致力于把算法讲清楚！</p>
<p>引用教员的话：下定决心，排除万难，争取学明白！</p>
<p><strong>写在过程中：</strong></p>
<p>行百里者半九十</p>
<p>2022.10月下旬以来，一边为了将来考研打算，一边在复习<code>C语言</code>基本知识点。决定下定决心把基本的数据结构复习温习。因为在前面的学习中我一直使用的是Python，也没有学号Python数据结构与算法，所以在刷题过程中遇到抽象数据结构与指针，我的理解是有问题的，而且有时候我本身就对某一句程序根本就是不理解。诚如程杰老师在大话数据结构中说是：<code>讲解数据结构还的使用最干净最纯粹的通用计算机经典语言，虽然Python很灵动，正是这种灵动，在解析数据结构的时候显得不够严肃和“正统”，而程序员的基础必修课，必须一拳一脚的养成规范的动作习惯。</code></p>
<p>所以，我觉着这也是我走过的弯路。当前主流的编程语言，对于学生来说，接受程度最大的我认为无疑是Python语言。我一开始最初摸索的时候，也是使用的Python语言。但是学到后期，我发现，Python的灵动使我对算法的关键执行步骤理解起来并不是非常清晰。C语言相比于Python，没用那么多灵动性，如果再引入指针，大部分本科生是很讨厌的。但是，正是由于C语言的朴实，我才发现了数据结构与算法真正的魅力所在。(只可意会不可言传哈哈哈!)。所以，打好C语言的基础任何时候都需要！！！——2023.09.05补充</p>
<p><strong>写在2022年终岁尾：</strong></p>
<p>因为疫情，突如其来的寒假又开始了，这个假期主要干三件事：<code>408,408，还TMD是408！</code></p>
<p>当然数据结构还是接续学，算法题还是要继续刷。利用寒假巩固一下竞赛中的C++基础语法知识和算法提高。寒假刷题的语言全部转换到了C++上，后期看到语言的转变就不要感到差异。算法学习强推ACwing-闫学灿！</p>
<p><strong>写在2023年初：</strong></p>
<p>2023开年——开始新一遍408数据结构与算法的总结复习，这一遍注重基础知识，特别是时间-空间复杂度的计算、程序设计大题代码的默写(细节)、各种算法的计算过程。</p>
<hr>
<p>后面学的多了，东来大哥的书已经不能满足我得学习激情了,博览群书借鉴多位专家大佬的思想精华。</p>
<p>参考学习更多书目如下：</p>
<blockquote>
<p>[1]计算之魂.吴军</p>
<p>[2]算法导论.MIT</p>
<p>[3]数据结构与算法.严蔚敏</p>
<p>[4]labuladong的算法小抄.付东来</p>
<p>[5]代码随想录.孙秀洋</p>
<p>[6]STL源码剖析.何捷</p>
<p>[7]大话数据结构.程杰(小白强推)</p>
<p>[8]数据结构与算法习题集.严蔚敏</p>
</blockquote>
<hr>
<h2 id="c基础语法-竞赛相关">C++基础语法-&gt;竞赛相关</h2>
<p>语法学习参考y神：ACwing-闫学灿！</p>
<h3 id="c中的数据类型">C++中的数据类型</h3>
<ul>
<li>bool:true/false  1 bytes</li>
<li>char:‘a’,‘c’,‘ ’,‘\n’  1 bytes</li>
<li>int：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><msup><mn>2</mn><mn>31</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-2^{31} - 2^{31}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>   4 bytes</li>
<li>float: 1.23,2.51,2.35e2 6-7位有效数字单精度浮点型数据   4 bytes</li>
<li>double(double flaot):15-16位双精度浮点型 8 bytes</li>
<li>long long(long int):<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>−</mo><msup><mn>2</mn><mn>63</mn></msup><mo>−</mo><msup><mn>2</mn><mn>63</mn></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-2^{63} - 2^{63}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>  8 bytes</li>
<li>long double:18-19位有效数字    16 bytes</li>
</ul>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cstdio&gt;

using namespace std;

int main(){
    
    int a,b,c,d;
    int x;
    cin &gt;&gt; a;
    cin &gt;&gt; b;
    cin &gt;&gt; c;
    cin &gt;&gt; d;
    x = a*b-c*d;
    cout &lt;&lt;  &quot;DIFERENCA = &quot; &lt;&lt; x &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>C++中的格式化的输入输出<br>
printf输出格式</p>
<p>注意：使用printf 时最好添加头文件 #include <cstdio>。</p>
<p>Int、float、double、char等类型的输出格式：</p>
<p>(1)  Int：%d</p>
<p>(2)  Float: %f, 默认保留6位小数</p>
<p>(3)  Double: %lf， 默认保留6位小数</p>
<p>(4)  Char: %c, 回车也是一个字符，用’\n’表示</p>
<p>在main函数内部，未初始化的数组中的元素是随机的。</p>
<h2 id="绪论与基础概念">绪论与基础概念</h2>
<p>数据结构：是互相之间存在的一种或者多种特定关系的数据元素的集合。</p>
<p>数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及他们之间的关系和操作相关问题的学科。</p>
<p>程序设计=数据结构+算法</p>
<h2 id="算法的五大特性">算法的五大特性</h2>
<blockquote>
<p>-&gt;大话数据结构-程杰</p>
</blockquote>
<p>算法具有五个基本特性：<strong>输入</strong>、<strong>输出</strong>、<strong>有穷性</strong>、<strong>确定性</strong>和<strong>可行性</strong>。</p>
<ol>
<li>
<p>输入输出：</p>
<p>输入和输出特性比较容易理解，算法具有零个或多个输入。算法至少有一个或多个输出，算法是一定需要输出的，不需要输出，你用这个算法干吗？输出的形式可以是打印输出，也可以是返回一个或多个值等。</p>
</li>
<li>
<p>有穷性</p>
<p>认识到一个问题的<strong>边界</strong>。有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。现实中经常会写出死循环的代码，这就是不满足有穷性。当然这里有穷的概念并不是纯数学意义的，而是在实际应用当中合理的、可以接受的“有边界”。</p>
</li>
<li>
<p>确定性</p>
<p>确定性：算法的每一步骤都具有确定的含义，不会出现<strong>二义性</strong>，相同的输入只能有唯一的输出结果。算法的每个步骤被精确定义而无歧义。</p>
</li>
<li>
<p>可行性</p>
<p>可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。可行性意味着算法可以转换为程序上机运行，并得到正确的结果。</p>
</li>
</ol>
<h2 id="算法与时空复杂度">算法与时空复杂度</h2>
<p>算法是解决特定问题的求解步骤描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或者多个操作。设计算法应该尽量满足时间效率高和存储量低的需求。</p>
<h3 id="函数的渐进增长">函数的渐进增长</h3>
<p>给定两个函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>,如果存在一个整数N,使得对于所有的n&gt;N,<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>总是比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>大,那么我们说<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的增长渐进快于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>g</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">g(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<h3 id="时间复杂度计算">时间复杂度计算</h3>
<h4 id="一层循环">一层循环</h4>
<p>思路：</p>
<ol>
<li>列出循环的趟数t及每轮循环i的变化值</li>
<li>找到t与i的关系</li>
<li>确定循环终止的条件</li>
<li>联立两个式子，解方程</li>
<li>写结果</li>
</ol>
<h4 id="两层循环">两层循环</h4>
<p>思路：</p>
<ol>
<li>列出外层循环中i的变化范围</li>
<li>列出内层语句的执行次数</li>
<li>求和写出结果</li>
</ol>
<h2 id="基础结构的复盘与强化">基础结构的复盘与强化</h2>
<p>备战考研呢，也算是复习一遍C语言基础，跟着王道龙哥过一遍C/C++基础。</p>
<h3 id="单链表">单链表</h3>
<p>单链表的增删改查</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;


//在此程序中，*LinkList是变量的指针；LinkList为指针变量。

//单链表的增删改查
//线性表的链式表示就是单链表

#define Maxsize 50
#define InitSize 100

//定义一个整型类型的变量
typedef int ElemType;

//单链表结构创建-8个字节
typedef struct LNode {//单链表的结构

	ElemType data;//数据域
	struct LNode* next;//指针域

}LNode,*LinkList;
//LinkList为结构体指针等价于struct LNode*
//别名LNode可以和上面保持一致


//头插法插入新的节点
//创建单链表-&gt;带有头结点
//头结点只需要头指针指向，啥也不存
LinkList CreatList1(LinkList &amp;L) {

	LNode* q;
	int x;
	L = (LinkList)malloc(sizeof(LNode));//带头结点的链表
	L-&gt;next = NULL;
	scanf_s(&quot;%d&quot;, &amp;x);
	while (x != 9999) {
		q = (LinkList)malloc(sizeof(LNode));
		q-&gt;data = x;
		q-&gt;next = L-&gt;next;
		L-&gt;next = q;
		scanf_s(&quot;%d&quot;, &amp;x);
	}
	return L;
}

//尾插法创建单链表
LinkList CreatList2(LinkList &amp;L) {

	int x;
	L = (LinkList)malloc(sizeof(LNode));//带头结点的链表
	//在这里需要注意的是，r本身就是表尾节点,指向链表尾部
	LNode* s, * r = L;//等价于LinkList s,r=L;
	scanf_s(&quot;%d&quot;, &amp;x);
	while (x != 9999) {
		s = (LinkList)malloc(sizeof(LNode));
		s-&gt;data = x;
		r-&gt;next = s;
		r = s;//r指向新的表尾节点
		scanf_s(&quot;%d&quot;, &amp;x);
	}
	r-&gt;next = NULL;//尾节点指针赋值为空
	return L;
}

//查找节点
LNode* GetElem(LinkList L, int i) {

	int j = 1;
	//初始指向虚拟头结点的下一个节点
	LNode* p = L-&gt;next;
	if (i == 0) {
		return L;
	}
	if (i &lt; 1) {
		return NULL;
	}
	//p-&gt;非空
	while (p &amp;&amp; j &lt; i) {

		p = p-&gt;next;
		j++;
	}
	return p;
}

//任意两个节点之间插入节点
//第i个位置插入值为e的节点
bool InsertFrontList(LinkList L,int i,ElemType e) {

	LinkList p = GetElem(L,i - 1);
	if (NULL == p) {
		return false;
	}
	LinkList s = (LNode*)malloc(sizeof(LNode));//为新插入的节点申请内存空间
	s-&gt;data = e;
	s-&gt;next = p-&gt;next;
	p-&gt;next = s;
	return true;
}

bool InsertBackList(LinkList L,ElemType e) {

	//L = (LinkList)malloc(sizeof(LNode));//带头结点的链表
	while (L-&gt;next != NULL) {
		L = L-&gt;next;
	}
	LNode* q;
	int x;
	scanf_s(&quot;%d&quot;, &amp;x);
	while (x != 9999) {
		q = (LinkList)malloc(sizeof(LNode));
		q-&gt;data = x;
		L-&gt;next = q;
		q-&gt;next = NULL;
		scanf_s(&quot;%d&quot;, &amp;x);
	}
	return L;

}

//无论是中间插入还是删除，找到需要操作节点的前驱节点是关键

//删除第i个位置的节点
bool DeleteList(LinkList L,int i) {

	//找到要删除元素的前驱结点
	LinkList p = GetElem(L, i - 1);
	LinkList q = p-&gt;next;
	if (p == NULL) {

		return false;//要删除的位置不存在
	}
	p-&gt;next = q-&gt;next;//断链
	free(q);
	q = NULL;
	return true;

}


void PrintList(LinkList L) {

	//头结点
	L = L-&gt;next;
	while (L != NULL) {
		printf(&quot;%d\t&quot;, L-&gt;data);
		L = L-&gt;next;
	}
}

//查找第几个元素
LinkList LocateElem(LinkList L, ElemType e) {

	int j = 1;
	LinkList p = L-&gt;next;
	while (p != NULL &amp;&amp; p-&gt;data != e) {
		p = p-&gt;next;
		j++;
	}
	return p;

}


int main() {

	//定义链表头,结构体指针类型
	LinkList L;
	LinkList search;//用来存储拿到的某一个节点
	LinkList search1;
	printf(&quot;请在下方输入单链表的值：（^_^大于5个元素且输入9999终止^_^）\n&quot;);
	CreatList1(L);
	printf(&quot;头插法的结果为：&quot;);
	PrintList(L);
	search = GetElem(L, 2);
	if (search != NULL) {

		printf(&quot;\n按序号查找成功！~\n&quot;);
		printf(&quot;该位置的值为：%3d\n&quot;, search-&gt;data);
	}
	search1 = LocateElem(L, 5);
	/*
	if (search1 != NULL) {

		printf(&quot;\n按序号查找成功！~\n&quot;);
		printf(&quot;该的值为：%3d&quot;, search-&gt;data);
	}
	*/
	InsertFrontList(L, 3, 30);
	PrintList(L);
	printf(&quot;\n-----------\n&quot;);
	printf(&quot;删除后的结果为：\n&quot;);
	DeleteList(L, 3);
	PrintList(L);
	printf(&quot;\n-----------\n&quot;);
	printf(&quot;请在下方输入单链表的值：（^_^大于5个元素且输入9999终止^_^）\n&quot;);
	CreatList2(L);
	printf(&quot;尾插法的结果为：&quot;);
	PrintList(L);
	return 0;

}
</code></pre>
<h3 id="栈和队列">栈和队列</h3>
<p>栈的入栈出栈</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

#define Maxsize 50

//堆栈的操作
//LIFO-&gt;后进先出的操作方式
//s.top就是用来指向数组下标的指针
typedef int ElemType;
typedef struct {
	ElemType data[Maxsize];//数组
	int top;
}SqStack;

//必须使用C++的引用，因为是从中函数传值进来，改变实参的值
void InitStack(SqStack &amp;S) {

	S.top = -1;//栈空

}

//判断栈是否为空：因为不需要改变实参的值，所以不用加引用
bool StackEmpty(SqStack S) {
	if (S.top == -1) {
		return true;
	}
	return false;
}

//压栈操作
//需要改变实参中的栈数值，所以需要加入引用
bool Push(SqStack&amp; S, ElemType x) {
	//无论是栈还是队列、链表；在进行插入操作时，一定记得要首先判断是满
	if (S.top == Maxsize - 1) {
		return false;
	}
	//压栈操作-&gt;先进性+操作
	//栈内元素存放在一个数组当中
	S.data[++S.top] = x;
	return true;
}

bool GetTop(SqStack S, ElemType&amp; x) {

	if (StackEmpty(S)) {

		return false;
	}
	x = S.data[S.top];
	return true;
}

//出栈操作
bool Pop(SqStack &amp;S,ElemType x) {

	if (StackEmpty(S)) {
		return false;
	}
	//以下两句等价于x = S.data[S.top--];
	x = S.data[S.top--];
	//S.top--;
	return true;
}

int main() {

	SqStack S;//初始化
	bool flag;
	ElemType m;
	InitStack(S);
	flag = StackEmpty(S);
	if (flag) {
		printf(&quot;栈是空的！\n&quot;);
	}
	//元素压栈
	Push(S, 3);
	Push(S, 4);
	Push(S, 5);
	Push(S, 6);
	flag = GetTop(S, m);
	if (flag) {
		printf(&quot;得到的栈顶元素为：%d\n&quot;, m);
	}
	flag = Pop(S, 6);
	if (flag) {
		printf(&quot;弹出的元素为：%d\n&quot;, m);
	}
	return 0;
}
</code></pre>
<p>队列与循环队列</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

typedef int ElemType;
typedef struct LinkNode {

	ElemType data;
	struct LinkNode* next;
}LinkNode;

typedef struct {

	struct LinkNode* front, * tail;

}LinkQueue;

bool InitQueue(LinkQueue &amp;Q) {

	Q.front = Q.tail = (LinkNode*)malloc(sizeof(LinkNode));
	Q.front-&gt;next = NULL;
	return true;
}

//尾插法入队
void EnQueue(LinkQueue&amp; Q, ElemType x) {

	LinkNode *s = (LinkNode*)malloc(sizeof(LinkNode));
	s-&gt;data = x;
	s-&gt;next = NULL;
	Q.tail-&gt;next = s;
	Q.tail = s;

}


//头插法删除
bool DeQueue(LinkQueue&amp; Q, ElemType&amp; x) {

	//判断队列是否为空
	if (Q.front == Q.tail)return false;
	//队头出队节点
	LinkNode* p = Q.front-&gt;next;
	x = p-&gt;data;
	Q.front-&gt;next = p-&gt;next;
	if (Q.tail == p) { 

		Q.front = Q.tail;
	}
	free(p);
	return true;
}

int main(void) {

	LinkQueue Q;
	ElemType data;
	bool ret;
	InitQueue(Q);
	EnQueue(Q, 3);
	EnQueue(Q, 4);
	EnQueue(Q, 5);
	EnQueue(Q, 6);
	EnQueue(Q, 7);
	ret = DeQueue(Q, data);
	if (ret) {
		printf(&quot;出队成功！！！\n&quot;);
		printf(&quot;出队元素为：%d\n&quot;,data);
	}
	else {
		printf(&quot;出队失败~~\n&quot;);
	}
	return 0;
}
-----------------------------------------------------------
 //循环队列
 #include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

//408常考的循环队列

#define Maxsize 5
typedef int ElemType;
//循环队列的结构 
typedef struct {
	ElemType data[Maxsize];
	int front, tail;
}SqQueue;

//初始化函数
void InitQueue(SqQueue&amp; q) {
	q.front = q.tail = 0;
}

//判断是否为空
bool isEmpty(SqQueue q) {

	//队头指针==队尾指针
	if (q.front == q.tail) {
		return true;
	}
	else {
		return false;
	}
	 
}

//元素入队函数
bool EnQueue(SqQueue&amp; q, ElemType x) {


	//先判断队列是否满队
	if ((q.tail + 1) % Maxsize == q.front) {
		return false;
	}
	q.data[q.tail + 1] = x;
	q.tail = (q.tail + 1) % Maxsize;
	return true;
}

int main() {
	SqQueue q;
	bool ret;
	ElemType m;
	InitQueue(q);
	EnQueue(q, 1);
	EnQueue(q, 2);
	EnQueue(q, 3);
	return 0;
}
</code></pre>
<h3 id="二叉树">二叉树</h3>
<p>层次建树与三种遍历方式</p>
<pre><code class="language-c">#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

//层次建树
//树的结构体建立
typedef char BiElemType;
typedef struct BiTNode {

	BiElemType root;
	struct BiTNode* left;
	struct BiTNode* right;
}BiTNode,*BiTree;

//层次队列
typedef struct tag {
	BiTree p;//树的某一个节点的地址
	struct tag* pnext;
}tag_t,*ptag_t;

//前序遍历
void PreOrder(BiTree p) {

	if (p != NULL) {
		putchar(p-&gt;root);
		PreOrder(p-&gt;left);
		PreOrder(p-&gt;right);
	}
	
}

//中序遍历
void InOrder(BiTree p) {

	if (p != NULL) {
		InOrder(p-&gt;left);
		putchar(p-&gt;root);
		InOrder(p-&gt;right);
	}

}

//后序遍历
void LastOrder(BiTree p) {

	if (p != NULL) {
		LastOrder(p-&gt;left);
		LastOrder(p-&gt;right);
		putchar(p-&gt;root);
	}

}

int main(void) {

	BiTree pnew;
	int i, j, pos;
	char c;
	BiTree tree = NULL;//树根  
	//层次建树辅助队列
	ptag_t phead = NULL, ptail = NULL, listnew = NULL, pcur = NULL;
	while (scanf_s(&quot;%c&quot;, &amp;c) != EOF) {

		if (c == '\n') {
			break;
		}

		pnew = (BiTree)calloc(1, sizeof(BiTNode));//calloc申请空间并对空间进行初始化
		pnew-&gt;root = c;
		listnew = (ptag_t)calloc(1, sizeof(tag_t));
		listnew-&gt;p = pnew;
		if (tree == NULL) {
			tree = pnew;
			phead = listnew;//队列头
			ptail = listnew;//队列尾
			pcur = listnew;
			continue;
		}
		else {
			ptail-&gt;pnext = listnew;//新节点入队，尾插法
			ptail = listnew;
		}
		if (pcur-&gt;p-&gt;left == NULL) {
			pcur-&gt;p-&gt;left = pnew;//把新节点放入到当前节点的左孩子
		}
		else if (pcur-&gt;p-&gt;right == NULL) {
			pcur-&gt;p-&gt;right = pnew;//把新节点放入到当前节点的左孩子
			pcur = pcur-&gt;pnext;//左右都放了节点后，pcur指向队列的下一个元素
		}
	}
	
	printf(&quot;\n-----------前序遍历---------\n&quot;);
	PreOrder(tree);
	printf(&quot;\n-----------中序遍历---------\n&quot;);
	InOrder(tree);
	printf(&quot;\n-----------后序遍历---------\n&quot;);
	LastOrder(tree);
	return 0;

}
</code></pre>
<h2 id="思考">思考</h2>
<h3 id="参考二叉树的后序遍历如何利用栈实现递归与非递归的转换">参考二叉树的后序遍历，如何利用栈实现递归与非递归的转换？</h3>
<p>首先二叉树的后序遍历过程是一个自底向上的回溯过程，也就是递归中归的过程。递归过程利用栈的数据结构，由递归的外层（递归栈的底层）到base case（递归栈的顶层）；每一个递归过程细节中都封装在了函数的内部，已实现递归重复调用。而对于非递归的转化，就是将封装过程打破，利用循环嵌套的流程去实现递归调用的过程。迭代循环是一个根据base case的自底向上过程。</p>
<blockquote>
<p>介绍并熟练掌握了基础的数据结构，下面就开始真正的算法之旅喽~</p>
</blockquote>
<h2 id="双指针技巧在链表与数组中的运用">双指针技巧在链表与数组中的运用</h2>
<p>双指针分类：1.<strong>快慢指针</strong> 2.<strong>左右指针</strong></p>
<p>力扣中的对应题目如下：</p>
<p>数组：</p>
<table>
<thead>
<tr>
<th>LeetCode</th>
<th>力扣</th>
<th>难度</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://leetcode.com/problems/longest-palindromic-substring/">5. Longest Palindromic Substring</a></td>
<td><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></td>
<td>🟠</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/">26. Remove Duplicates from Sorted Array</a></td>
<td><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">26. 删除有序数组中的重复项</a></td>
<td>🟢</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/remove-element/">27. Remove Element</a></td>
<td><a href="https://leetcode.cn/problems/remove-element/">27. 移除元素</a></td>
<td>🟢</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/">83. Remove Duplicates from Sorted List</a></td>
<td><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></td>
<td>🟢</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/">167. Two Sum II - Input Array Is Sorted</a></td>
<td><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/">167. 两数之和 II - 输入有序数组</a></td>
<td>🟢</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/move-zeroes/">283. Move Zeroes</a></td>
<td><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></td>
<td>🟢</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/reverse-string/">344. Reverse String</a></td>
<td><a href="https://leetcode.cn/problems/reverse-string/">344. 反转字符串</a></td>
<td>🟢</td>
</tr>
</tbody>
</table>
<p>在处理数组和链表相关问题时，双指针技巧是经常用到的，双指针技巧主要分为两类：<strong>左右指针</strong>和<strong>快慢指针</strong>。</p>
<p>所谓左右指针，就是两个指针相向而行或者<strong>相背而行</strong>；而所谓快慢指针，就是两个指针<strong>同向而行</strong>，一快一慢。</p>
<p>对于单链表来说，大部分技巧都属于快慢指针。</p>
<p>在数组中并没有真正意义上的指针，但我们可以把<strong>索引</strong>当做数组中的指针，这样也可以在数组中施展双指针技巧，<strong>本文先讲数组相关的双指针算法</strong>，<strong>再讲链表有关的双指针算法。</strong></p>
<h3 id="array~快慢指针技巧">Array~快慢指针技巧</h3>
<p><strong>数组问题中比较常见的快慢指针技巧，是让你原地修改数组</strong>。</p>
<p>简单解释一下什么是原地修改：</p>
<p>如果不是原地修改的话，我们直接 new 一个 <code>int[]</code> 数组，把去重之后的元素放进这个新数组中，然后返回这个新数组即可。</p>
<p>但是现在题目让你原地删除，不允许 new 新数组，只能在原数组上操作，然后返回一个长度，这样就可以通过返回的长度和原始数组得到我们去重后的元素有哪些了。</p>
<p>由于数组已经排序，所以重复的元素一定连在一起，找出它们并不难。但如果毎找到一个重复元素就立即原地删除它，由于数组中删除元素涉及数据搬移，整个时间复杂度是会达到 <code>O(N^2)</code>。</p>
<p>高效解决这道题就要用到快慢指针技巧：</p>
<p>我们让慢指针 <code>slow</code> 走在后面，快指针 <code>fast</code> 走在前面<strong>探路</strong>，找到一个不重复的元素就赋值给 <code>slow</code> 并让 <code>slow</code> 前进一步。</p>
<p>这样，就保证了 <code>nums[0..slow]</code> 都是无重复的元素，当 <code>fast</code> 指针遍历完整个数组 <code>nums</code> 后，<code>nums[0..slow]</code> 就是整个数组去重之后的结果。</p>
<pre><code class="language-Python">//Java实现
int removeDuplicates(int[] nums){
    if (nums.length == 0)
    {
        return 0;
    }
    int slow = 0,fast = 0;
    while (fast &lt; nums.length)
    {
        if (nums[fast] != nums[slow])
        {
            slow++;
            nums[slow] = nums[fast];
                
        }
        fast++; 
    }
    return slow + 1;
}
#python实现
class Solution(object):
    def removeDuplicates(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        if(len(nums) == 0):
            return 0
        #can't assign to literal的错误来源是slow=0，fast=0写在了一行中
        #要么用逗号隔开，用么分成两行写
        slow=0
        fast=0
        while(fast &lt; len(nums)):
            if(nums[fast] != nums[slow]):
                slow += 1
                nums[slow] = nums[fast]
            fast += 1

        return slow + 1
</code></pre>
<p>同理，将本题的思想用于链表去重的代码实现为：</p>
<pre><code class="language-Python">ListNode deleteDuplicates(ListNode head) {
    if (head == null) return null;
    ListNode slow = head, fast = head;
    while (fast != null) {
        if (fast.val != slow.val) {
            // nums[slow] = nums[fast];
            slow.next = fast;
            // slow++;
            slow = slow.next;
        }
        // fast++
        fast = fast.next;
    }
    // 断开与后面重复元素的连接
    slow.next = null;
    return head;
}
</code></pre>
<p>类似的，例如力扣中的<strong>移动零</strong>题目：</p>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>本质就是数组去重后将尾巴部分元素改为0</p>
<pre><code class="language-Python">class Solution(object):
    def moveZeroes(self, nums):
        &quot;&quot;&quot;
        :type nums: List[int]
        :rtype: None Do not return anything, modify nums in-place instead.
        &quot;&quot;&quot;
        #老套路，设置快慢指针
        slow=0
        fast=0
        #核心代码区，区分不同目标值的设置
        while(fast &lt;len(nums)):
            if(nums[fast] != 0):
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        #与前面题唯一的不同点，是将数组去重后尾部元素修改为0，此处我用的for循环，有其他新方法欢迎大佬们修改提出意见
        for i in range(slow,len(nums)):
            nums[i] = 0
</code></pre>
<h4 id="数组移除元素">数组移除元素</h4>
<pre><code class="language-python3">class Solution:
    def removeElement(self, nums: List[int], val: int) -&gt; int:
        slow,fast = 0,0
        while(fast &lt; len(nums)):
            if(nums[fast] != val):
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
        return slow
</code></pre>
<h4 id="移除数组中的重复元素">移除数组中的重复元素</h4>
<pre><code class="language-python">class Solution:
    def removeDuplicates(self, nums: List[int]) -&gt; int:
        slow,fast = 0,0
        while(fast &lt; len(nums)):
            if(nums[fast] != nums[slow]):
                slow += 1
                nums[slow] = nums[fast]
            fast += 1
        return slow + 1
</code></pre>
<h4 id="去重的核心代码块"><strong>去重的核心代码块</strong></h4>
<pre><code class="language-python">while(fast &lt;len(nums)):
            if(nums[fast] != 0):
                nums[slow] = nums[fast]
                slow += 1
            fast += 1
</code></pre>
<p>对于核心代码块而言，在熟练使用的情况下要记牢，方便后序写程序是效率提高。</p>
<h3 id="array~左右指针技巧">Array~左右指针技巧</h3>
<h4 id="二分查找算法">二分查找算法</h4>
<table>
<thead>
<tr>
<th style="text-align:center">LeetCode</th>
<th style="text-align:center">力扣</th>
<th style="text-align:center">难度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. Find First and Last Position of Element in Sorted Array</a></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></td>
<td style="text-align:center">🟠</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://leetcode.com/problems/binary-search/">704. Binary Search</a></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a></td>
<td style="text-align:center">🟢</td>
</tr>
</tbody>
</table>
<p>首先介绍以下二分查找的代码框架：</p>
<p>其中 <code>...</code> 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。</p>
<p><strong>另外提前说明一下，计算 <code>mid</code> 时需要防止溢出</strong>，代码中 <code>left + (right - left) / 2</code> 就和 <code>(left + right) / 2</code> 的结果相同，但是有效防止了 <code>left</code> 和 <code>right</code> 太大，直接相加导致溢出的情况。</p>
<pre><code class="language-java">def binarySearch(int[] nums, int target) {
    #设置左右指针
    int left = 0, right = ...;

    while(...) {
        #关键在mid值的设定与左右边界确定
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] &lt; target) {
            left = ...
        } else if (nums[mid] &gt; target) {
            right = ...
        }
    }
    return ...;
}
</code></pre>
<p>二分查找并不简单，Knuth 大佬（著有大部头《计算机程序设计》一书，无数程序员的圣经）都说二分查找：<strong>思路很简单，细节是魔鬼</strong>。二分查找真正的坑根本就不是那些有关于溢出的细节问题，而是在于到底要给 <code>mid</code> 加一还是减一，while 里到底用 <code>&lt;=</code> 还是 <code>&lt;</code>。</p>
<p>几个最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。</p>
<p>我们要<strong>深入细节</strong>，比如不等号是否应该带等号，<code>mid</code> 是否应该加一等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的二分查找算法。</p>
<p>大家写二分法经常写乱，主要是因为<strong>对区间的定义没有想清楚，区间的定义就是不变量</strong>。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是<strong>循环不变量</strong>规则。</p>
<p>写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。</p>
<p>从本书中学到了，在分析二分查找时，对于选择分支结构if-else很少使用，而是用<strong>else if</strong> 取代，这样可以展示二分查找的所有细节。</p>
<h5 id="寻找一个数">寻找一个数</h5>
<p>这段代码可以解决力扣第 704 题「 <a href="https://leetcode.cn/problems/binary-search/">二分查找</a>」。</p>
<p>下面提出解决本题需要关注的细节：</p>
<p><strong>搜索一个元素时，搜索区间两端闭</strong>；<strong>while条件带等号</strong>，否则需要打补丁。</p>
<p>if相等就返回，其他的是甭操心；<strong>mid必须加减一</strong>，因为区间两端闭。</p>
<p>while结束就凉凉，凄凄惨惨返-1.</p>
<pre><code class="language-python">class Solution(object):
    def search(self, nums, target):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type target: int
        :rtype: int
        &quot;&quot;&quot;
        left = 0
        right = len(nums)-1 #易错点
        while(left &lt;= right):
            mid = left + (right - left)/2
            if(nums[mid] == target):
                return mid
            elif(nums[mid] &lt; target):
                #对于mid的操作时二分查找的一个难点。
                left = mid + 1
            elif(nums[mid] &gt; target):
                right = mid - 1
        return -1
</code></pre>
<p><strong>while(left &lt;= right)的终止条件</strong>是：left == right + 1-&gt;[right + 1,right]。</p>
<p><strong>while(left &lt; right)的终止条件</strong>是：left == right -&gt;[left,right]。</p>
<h5 id="寻找左侧边界">寻找左侧边界</h5>
<p>左侧边界是左闭右开的搜索区间：<strong>[left,right)</strong>,因此需要注意while的条件是<strong>while(left&lt;right)</strong>。</p>
<p>right = len(nums)</p>
<h5 id="寻找右侧边界">寻找右侧边界</h5>
<h4 id="反转系列与回文">反转系列与回文</h4>
<p>回文模板：</p>
<pre><code class="language-c++">bool isPalindrome(const string&amp; s,int start,int end){
        for(int i = start,j = end;i &lt; j;i++,j--){
            if(s[i] != s[j]){
                return false;
            }
        }
        return true;
</code></pre>
<h5 id="迭代反转单链表">迭代反转单链表</h5>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def reverseList(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        if head == None or head.next == None:
            return head
        pre = None
        tmp = None
        #切记理解终止条件
        while(head != None):
            #迭代反转过程
            tmp = head.next
            head.next = pre
            pre = head
            head = tmp
        return pre
</code></pre>
<h5 id="递归反转单链表">递归反转单链表</h5>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def reverseList(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        #特殊情况
        if head == None or head.next == None:
            return head
        last = self.reverseList(head.next)
        head.next.next = head
        head.next = None
        return last
</code></pre>
<h5 id="回文链表">回文链表</h5>
<pre><code class="language-python">#数组模拟
class Solution:
    def isPalindrome(self, head: ListNode) -&gt; bool:
        length = 0
        tmp = head
        while tmp: #求链表长度
            length += 1
            tmp = tmp.next
        
        result = [0] * length
        tmp = head
        index = 0
        while tmp: #链表元素加入数组
            result[index] = tmp.val
            index += 1
            tmp = tmp.next
        
        i, j = 0, length - 1
        while i &lt; j: # 判断回文
            if result[i] != result[j]:
                return False
            i += 1
            j -= 1
        return True
        
#反转后半部分链表
class Solution:
    def isPalindrome(self, head: ListNode) -&gt; bool:
        if head == None or head.next == None:
            return True
        slow, fast = head, head
        while fast and fast.next:
            pre = slow
            slow = slow.next
            fast = fast.next.next
        
        pre.next = None # 分割链表
        cur1 = head # 前半部分
        cur2 = self.reverseList(slow) # 反转后半部分，总链表长度如果是奇数，cur2比cur1多一个节点
        while cur1:
            if cur1.val != cur2.val:
                return False
            cur1 = cur1.next
            cur2 = cur2.next
        return True

    def reverseList(self, head: ListNode) -&gt; ListNode:
        cur = head   
        pre = None
        while(cur!=None):
            temp = cur.next # 保存一下cur的下一个节点
            cur.next = pre # 反转
            pre = cur
            cur = temp
        return pre
</code></pre>
<h5 id="反转整数"><strong>反转整数</strong></h5>
<pre><code class="language-python">class Solution:
    def reverse(self, x: int) -&gt; int:
        if(x == 0):
            return 0
        if(x &gt; 0):
            y = int(str(x)[::-1])
            return y if -2147483648&lt;y&lt;2147483647 else 0 
        if(x &lt; 0):
            y = -int(str(abs(x))[::-1])
            return y if -2147483648&lt;y&lt;2147483647 else 0
</code></pre>
<h5 id="最长回文字符串"><strong>最长回文字符串</strong></h5>
<pre><code class="language-python">class Solution:
    def longestPalindrome(self, s: str) -&gt; str:
        res = ' '
        for i in range(len(s)):
            start = max(0,i-len(res)-1)
            tmp = s[start : i+1]
            #分情况：s中含有字母的个数
            if tmp == tmp[::-1]:
                res = tmp
            else:
                tmp = tmp[1:]
                if tmp == tmp[::-1]:
                    res = tmp
        return res
</code></pre>
<h5 id="反转字符串">反转字符串</h5>
<pre><code class="language-python">class Solution:
    def reverseString(self, s: List[str]) -&gt; None:
        &quot;&quot;&quot;
        Do not return anything, modify s in-place instead.
        &quot;&quot;&quot;
        left, right = 0, len(s) - 1
        
        # 该方法已经不需要判断奇偶数，经测试后时间空间复杂度比用 for i in range(right//2)更低
        # 推荐该写法，更加通俗易懂
        while left &lt; right:
            s[left], s[right] = s[right], s[left]
            left += 1
            right -= 1
</code></pre>
<h3 id="linked-list~双指针技巧">Linked List~双指针技巧</h3>
<p>链表：</p>
<table>
<thead>
<tr>
<th>LeetCode</th>
<th>力扣</th>
<th>难度</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/">19. Remove Nth Node From End of List</a></td>
<td><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></td>
<td>🟠</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/merge-two-sorted-lists/">21. Merge Two Sorted Lists</a></td>
<td><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></td>
<td>🟢</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/merge-k-sorted-lists/">23. Merge k Sorted Lists</a></td>
<td><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></td>
<td>🔴</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/partition-list/">86. Partition List</a></td>
<td><a href="https://leetcode.cn/problems/partition-list/">86. 分隔链表</a></td>
<td>🟠</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/linked-list-cycle/">141. Linked List Cycle</a></td>
<td><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></td>
<td>🟢</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/linked-list-cycle-ii/">142. Linked List Cycle II</a></td>
<td><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></td>
<td>🟠</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/intersection-of-two-linked-lists/">160. Intersection of Two Linked Lists</a></td>
<td><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></td>
<td>🟢</td>
</tr>
<tr>
<td><a href="https://leetcode.com/problems/middle-of-the-linked-list/">876. Middle of the Linked List</a></td>
<td><a href="https://leetcode.cn/problems/middle-of-the-linked-list/">876. 链表的中间结点</a></td>
<td>🟢</td>
</tr>
</tbody>
</table>
<p>解决问题：</p>
<p>本节的难点在于，目前无法突破在力扣中对于**「虚拟头结点」**的建立使用。所以代码先按东哥Java实现，努力突破难点后，全部更新为python代码。</p>
<h4 id="设计链表-充分掌握">设计链表-充分掌握</h4>
<p>在链表类中实现这些功能：</p>
<p>-get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。<br>
-addAtHead(val)：在链表的第一个元素之前<strong>添加</strong>一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。<br>
-addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。<br>
-addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。<br>
-deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</p>
<pre><code class="language-python"># 单链表
class Node:
    
    def __init__(self, val):
        self.val = val
        self.next = None


class MyLinkedList:

    def __init__(self):
        self._head = Node(0)  # 虚拟头部节点
        self._count = 0  # 添加的节点数

    def get(self, index: int) -&gt; int:
        &quot;&quot;&quot;
        Get the value of the index-th node in the linked list. If the index is invalid, return -1.
        &quot;&quot;&quot;
        if 0 &lt;= index &lt; self._count:
            node = self._head
            for _ in range(index + 1):
                node = node.next
            return node.val
        else:
            return -1

    def addAtHead(self, val: int) -&gt; None:
        &quot;&quot;&quot;
        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
        &quot;&quot;&quot;
        self.addAtIndex(0, val)

    def addAtTail(self, val: int) -&gt; None:
        &quot;&quot;&quot;
        Append a node of value val to the last element of the linked list.
        &quot;&quot;&quot;
        self.addAtIndex(self._count, val)

    def addAtIndex(self, index: int, val: int) -&gt; None:
        &quot;&quot;&quot;
        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.
        &quot;&quot;&quot;
        if index &lt; 0:
            index = 0
        elif index &gt; self._count:
            return

        # 计数累加
        self._count += 1

        add_node = Node(val)
        prev_node, current_node = None, self._head
        for _ in range(index + 1):
            prev_node, current_node = current_node, current_node.next
        else:
            prev_node.next, add_node.next = add_node, current_node

    def deleteAtIndex(self, index: int) -&gt; None:
        &quot;&quot;&quot;
        Delete the index-th node in the linked list, if the index is valid.
        &quot;&quot;&quot;
        if 0 &lt;= index &lt; self._count:
            # 计数-1
            self._count -= 1
            prev_node, current_node = None, self._head
            for _ in range(index + 1):
                prev_node, current_node = current_node, current_node.next
            else:
                prev_node.next, current_node.next = current_node.next, None


# 双链表
# 相对于单链表, Node新增了prev属性
class Node:
    
    def __init__(self, val):
        self.val = val
        self.prev = None
        self.next = None


class MyLinkedList:

    def __init__(self):
        self._head, self._tail = Node(0), Node(0)  # 虚拟节点
        self._head.next, self._tail.prev = self._tail, self._head
        self._count = 0  # 添加的节点数

    def _get_node(self, index: int) -&gt; Node:
        # 当index小于_count//2时, 使用_head查找更快, 反之_tail更快
        if index &gt;= self._count // 2:
            # 使用prev往前找
            node = self._tail
            for _ in range(self._count - index):
                node = node.prev
        else:
            # 使用next往后找
            node = self._head   
            for _ in range(index + 1):
                node = node.next
        return node

    def get(self, index: int) -&gt; int:
        &quot;&quot;&quot;
        Get the value of the index-th node in the linked list. If the index is invalid, return -1.
        &quot;&quot;&quot;
        if 0 &lt;= index &lt; self._count:
            node = self._get_node(index)
            return node.val
        else:
            return -1

    def addAtHead(self, val: int) -&gt; None:
        &quot;&quot;&quot;
        Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list.
        &quot;&quot;&quot;
        self._update(self._head, self._head.next, val)

    def addAtTail(self, val: int) -&gt; None:
        &quot;&quot;&quot;
        Append a node of value val to the last element of the linked list.
        &quot;&quot;&quot;
        self._update(self._tail.prev, self._tail, val)

    def addAtIndex(self, index: int, val: int) -&gt; None:
        &quot;&quot;&quot;
        Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted.
        &quot;&quot;&quot;
        if index &lt; 0:
            index = 0
        elif index &gt; self._count:
            return
        node = self._get_node(index)
        self._update(node.prev, node, val)

    def _update(self, prev: Node, next: Node, val: int) -&gt; None:
        &quot;&quot;&quot;
            更新节点
            :param prev: 相对于更新的前一个节点
            :param next: 相对于更新的后一个节点
            :param val:  要添加的节点值
        &quot;&quot;&quot;
        # 计数累加
        self._count += 1
        node = Node(val)
        prev.next, next.prev = node, node
        node.prev, node.next = prev, next

    def deleteAtIndex(self, index: int) -&gt; None:
        &quot;&quot;&quot;
        Delete the index-th node in the linked list, if the index is valid.
        &quot;&quot;&quot;
        if 0 &lt;= index &lt; self._count:
            node = self._get_node(index)
            # 计数-1
            self._count -= 1
            node.prev.next, node.next.prev = node.next, node.prev

代码随想录：carlsun-2
</code></pre>
<h4 id="合并两个有序链表">合并两个有序链表</h4>
<p>这个算法的逻辑类似于拉拉链，两个需要合并的单链表，类似于拉链两侧的锯齿，指针 <code>p</code> 就好像拉链的拉索，将两个有序链表合并；过程与蛋白质的形成过程高度相似。（高中生物知识的复习）</p>
<p>运用的技巧：<strong>代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是 <code>dummy</code> 节点</strong>。如果不使用 <code>dummy</code> 虚拟节点，代码会复杂很多，而有了 <code>dummy</code> 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。</p>
<pre><code class="language-python">//java实现
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        // 虚拟头结点
        ListNode dummy = new ListNode(-1), p = dummy;
        ListNode p1 = l1, p2 = l2;

        while (p1 != null &amp;&amp; p2 != null) {
            // 比较 p1 和 p2 两个指针
            // 将值较小的的节点接到 p 指针
            if (p1.val &gt; p2.val) {
                p.next = p2;
                p2 = p2.next;
            } else {
                p.next = p1;
                p1 = p1.next;
            }
            // p 指针不断前进
            p = p.next;
        }

        if (p1 != null) {
            p.next = p1;
        }

        if (p2 != null) {
            p.next = p2;
        }

        return dummy.next;
    }
}
</code></pre>
<p>运用递归方法实现合并：程序的可读性降低，但代码更简洁——递归思想后序总结，需要掌握好！</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def mergeTwoLists(self, list1, list2):
        &quot;&quot;&quot;
        :type list1: Optional[ListNode]
        :type list2: Optional[ListNode]
        :rtype: Optional[ListNode]
        &quot;&quot;&quot;
        if not list1: return list2
        if not list2: return list1
        if(list1.val &lt;= list2.val):
            #递归核心
            list1.next = self.mergeTwoLists(list1.next,list2)
            return list1
        else:
            #递归核心
            list2.next = self.mergeTwoLists(list1,list2.next)
            return list2
</code></pre>
<h4 id="链表的分解">链表的分解</h4>
<p>在合并两个有序链表时让你合二为一，而这里需要分解让你把原链表一分为二。具体来说，我们可以把原链表分成两个小链表，一个链表中的元素大小都小于 <code>x</code>，另一个链表中的元素都大于等于 <code>x</code>，最后再把这两条链表接到一起，就得到了题目想要的结果。</p>
<p>3、合并 <code>k</code> 个有序链表</p>
<p>合并 <code>k</code> 个有序链表的逻辑类似合并两个有序链表，难点在于，如何快速得到 <code>k</code> 个节点中的最小节点，接到结果链表上？</p>
<p>这里我们就要用到 <a href="https://labuladong.gitee.io/algo/2/21/62/">优先级队列（二叉堆）</a> 这种数据结构，把链表节点放入一个最小堆，就可以每次获得 <code>k</code> 个节点中的最小节点：</p>
<pre><code class="language-python">ListNode mergeKLists(ListNode[] lists) {
    if (lists.length == 0) return null;
    // 虚拟头结点
    ListNode dummy = new ListNode(-1);
    ListNode p = dummy;
    // 优先级队列，最小堆
    PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;(
        lists.length, (a, b)-&gt;(a.val - b.val));
    // 将 k 个链表的头结点加入最小堆
    for (ListNode head : lists) {
        if (head != null)
            pq.add(head);
    }

    while (!pq.isEmpty()) {
        // 获取最小节点，接到结果链表中
        ListNode node = pq.poll();
        p.next = node;
        if (node.next != null) {
            pq.add(node.next);
        }
        // p 指针不断前进
        p = p.next;
    }
    return dummy.next;
}
</code></pre>
<p>这个算法是面试常考题，它的时间复杂度:</p>
<p>优先队列 <code>pq</code> 中的元素个数最多是 <code>k</code>，所以一次 <code>poll</code> 或者 <code>add</code> 方法的时间复杂度是 <code>O(logk)</code>；所有的链表节点都会被加入和弹出 <code>pq</code>，<strong>所以算法整体的时间复杂度是 <code>O(Nlogk)</code>，其中 <code>k</code> 是链表的条数，<code>N</code> 是这些链表的节点总数</strong>。</p>
<h4 id="寻找单链表的中点">寻找单链表的中点</h4>
<p>力扣第 876 题「 <a href="https://leetcode.cn/problems/middle-of-the-linked-list/">链表的中间结点</a>」就是这个题目，问题的关键也在于我们无法直接得到单链表的长度 <code>n</code>，常规方法也是先遍历链表计算 <code>n</code>，再遍历一次得到第 <code>n / 2</code> 个节点，也就是中间节点。</p>
<p>如果想一次遍历就得到中间节点，也需要耍点小聪明，使用「快慢指针」的技巧：</p>
<p>我们让两个指针 <code>slow</code> 和 <code>fast</code> 分别指向链表头结点 <code>head</code>。</p>
<p><strong>每当慢指针 <code>slow</code> 前进一步，快指针 <code>fast</code> 就前进两步，这样，当 <code>fast</code> 走到链表末尾时，<code>slow</code> 就指向了链表中点</strong>。</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution(object):
    def middleNode(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        #快慢指针初始化指向 head
        slow = head
        fast = head
        while(fast != None and fast.next != None):
            slow = slow.next
            fast = fast.next.next
        return slow
</code></pre>
<h4 id="寻找单链表的倒数第-k-个节点">寻找单链表的倒数第 <code>k</code> 个节点</h4>
<p>以下是东哥文章中的详细解题思路：</p>
<p>从前往后寻找单链表的第 <code>k</code> 个节点很简单，一个 for 循环遍历过去就找到了，但是如何寻找从后往前数的第 <code>k</code> 个节点呢？</p>
<p>那你可能说，假设链表有 <code>n</code> 个节点，倒数第 <code>k</code> 个节点就是正数第 <code>n - k + 1</code> 个节点，不也是一个 for 循环的事儿吗？</p>
<p>是的，但是算法题一般只给你一个 <code>ListNode</code> 头结点代表一条单链表，你不能直接得出这条链表的长度 <code>n</code>，而需要先遍历一遍链表算出 <code>n</code> 的值，然后再遍历链表计算第 <code>n - k + 1</code> 个节点。</p>
<p>也就是说，这个解法需要遍历两次链表才能得到出倒数第 <code>k</code> 个节点</p>
<p>那么，我们能不能<strong>只遍历一次链表</strong>，就算出倒数第 <code>k</code> 个节点？可以做到的，如果是面试问到这道题，面试官肯定也是希望你给出只需遍历一次链表的解法。</p>
<p>这个解法就比较巧妙了，假设 <code>k = 2</code>，思路如下：</p>
<p>首先，我们先让一个指针 <code>p1</code> 指向链表的头节点 <code>head</code>，然后走 <code>k</code> 步：</p>
<p>现在的 <code>p1</code>，只要再走 <code>n - k</code> 步，就能走到链表末尾的空指针了对吧？</p>
<p>趁这个时候，再用一个指针 <code>p2</code> 指向链表头节点 <code>head</code>：</p>
<p>接下来就很显然了，让 <code>p1</code> 和 <code>p2</code> 同时向前走，<code>p1</code> 走到链表末尾的空指针时前进了 <code>n - k</code> 步，<code>p2</code> 也从 <code>head</code> 开始前进了 <code>n - k</code> 步，停留在第 <code>n - k + 1</code> 个节点上，即恰好停链表的倒数第 <code>k</code> 个节点上：</p>
<p>这样，只遍历了一次链表，就获得了倒数第 <code>k</code> 个节点 <code>p2</code>。</p>
<p>东哥很详细地说了一大堆，其实简单总结起来就是：<strong>先利用for循环让快指针先走k步，在利用上题寻找中点思路即可解决。</strong></p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def getKthFromEnd(self, head, k):
        &quot;&quot;&quot;
        :type head: ListNode
        :type k: int
        :rtype: ListNode
        &quot;&quot;&quot;
        slow = head
        fast = head
        #先让快指针fast向前走k步
        for i in range(k):
            fast = fast.next
        #while(fast != None and fast.next != None)多加一个fast的next的结果为[3,4,5]与原题结果不符合;注意条件控制
        while(fast != None):
            slow = slow.next
            fast = fast.next
        return slow
</code></pre>
<h4 id="判断单链表是否包含环并找出环起点">判断单链表是否包含环并找出环起点</h4>
<p>经典问题的解决方案仍然是：快慢指针。每当慢指针 <code>slow</code> 前进一步，快指针 <code>fast</code> 就前进两步。</p>
<p>如果 <code>fast</code> 最终遇到空指针，说明链表中没有环；如果 <code>fast</code> 最终和 <code>slow</code> 相遇，那肯定是 <code>fast</code> 超过了 <code>slow</code> 一圈，说明链表中含有环。只需要把寻找链表中点的代码稍加修改就行了：</p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def hasCycle(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: bool
        &quot;&quot;&quot;
        slow = head
        fast = head
        #寻找中点的套路
        while(fast != None and fast.next != None):
            #快指针前进两步
            fast = head.next.next
            #慢指针前进一步
            slow = head.next
            #当快指针比慢指针多走一圈时，相遇便成环
            if(fast == slow):
                return True
        return False
#不知道为啥这个代码总是运行超时，是时间复杂度太大吗？-2022.06.21
</code></pre>
<h4 id="判断两个单链表是否相交并找出交点">判断两个单链表是否相交并找出交点</h4>
<p>如果用两个指针 <code>p1</code> 和 <code>p2</code> 分别在两条链表上前进，并不能<strong>同时</strong>走到公共节点，也就无法得到相交节点 <code>c1</code>。</p>
<p><strong>解决这个问题的关键是，通过某些方式，让 <code>p1</code> 和 <code>p2</code> 能够同时到达相交节点 <code>c1</code></strong>。</p>
<p>所以，我们可以让 <code>p1</code> 遍历完链表 <code>A</code> 之后开始遍历链表 <code>B</code>，让 <code>p2</code> 遍历完链表 <code>B</code> 之后开始遍历链表 <code>A</code>，这样相当于「逻辑上」两条链表接在了一起。</p>
<p>如果这样进行拼接，就可以让 <code>p1</code> 和 <code>p2</code> 同时进入公共部分，也就是同时到达相交节点 <code>c1</code></p>
<pre><code class="language-Python"># Definition for singly-linked list.
# class ListNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution(object):
    def getIntersectionNode(self, headA, headB):
        &quot;&quot;&quot;
        :type head1, head1: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        p1 = headA
        p2 = headB
        while(p1 != p2):
            #p1 走一步，如果走到 A 链表末尾，转到 B 链表
            if(p1 == None):
                p1 = headB
            else:
                p1 = p1.next
            #p2 走一步，如果走到 B 链表末尾，转到 A 链表
            if(p2 == None):
                p2 = headA
            else:
                p2 = p2.next
        return p1
</code></pre>
<h2 id="滑动窗口">滑动窗口</h2>
<p>双指针运用最难得部分！</p>
<table>
<thead>
<tr>
<th style="text-align:center">LeetCode</th>
<th style="text-align:center">力扣</th>
<th style="text-align:center">难度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">3. Longest Substring Without Repeating Characters</a></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></td>
<td style="text-align:center">🟠</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/">438. Find All Anagrams in a String</a></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></td>
<td style="text-align:center">🟠</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://leetcode.com/problems/permutation-in-string/">567. Permutation in String</a></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/permutation-in-string/">567. 字符串的排列</a></td>
<td style="text-align:center">🟠</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://leetcode.com/problems/minimum-window-substring/">76. Minimum Window Substring</a></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></td>
<td style="text-align:center">🔴</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></td>
<td style="text-align:center">🟠</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/MPnaiL/">剑指 Offer II 014. 字符串中的变位词</a></td>
<td style="text-align:center">🟠</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/VabMRr/">剑指 Offer II 015. 字符串中的所有变位词</a></td>
<td style="text-align:center">🟠</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/wtcaE1/">剑指 Offer II 016. 不含重复字符的最长子字符串</a></td>
<td style="text-align:center">🟠</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/M1oyTv/">剑指 Offer II 017. 含有所有字符的最短字符串</a></td>
<td style="text-align:center">🔴</td>
</tr>
</tbody>
</table>
<p>题目特点：</p>
<p><strong>最长/最短-&gt;子数组、子序列、子串</strong></p>
<p>解决一类最难掌握的双指针技巧：<strong>滑动窗口技巧</strong>；这个算法技巧的思路非常简单，就是维护一个窗口，不断滑动，然后更新答案。</p>
<p>这个算法技巧的时间复杂度是 O(N)，比字符串暴力算法要高效得多。</p>
<p>其实困扰大家的，不是算法的思路，而是各种细节问题。比如说如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。即便你明白了这些细节，也容易出 bug，找 bug 还不知道怎么找，真的挺让人心烦的。</p>
<p>框架：</p>
<pre><code class="language-java">/* 滑动窗口算法框架 */
void slidingWindow(string s) {
    unordered_map&lt;char, int&gt; window;
    
    int left = 0, right = 0;
    while (right &lt; s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 增大窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf(&quot;window: [%d, %d)\n&quot;, left, right);
        /********************/
        
        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 缩小窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
</code></pre>
<p><strong>其中两处 <code>...</code> 表示的更新窗口数据的地方，到时候你直接往里面填就行了</strong>；而且，这两个 <code>...</code> 处的操作分别是扩大和缩小窗口的更新操作。</p>
<p>在处理字符串反面，c/c++要比Java有优势。</p>
<p><strong>滑动窗口算法的思路</strong>：</p>
<p>1、我们在字符串 <code>S</code> 中使用双指针中的左右指针技巧，初始化 <code>left = right = 0</code>，把索引<strong>左闭右开</strong>区间 <code>[left, right)</code> 称为一个「窗口」。</p>
<p>PS：理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是<strong>最方便处理</strong>的。因为这样初始化 <code>left = right = 0</code> 时区间 <code>[0, 0)</code> 中没有元素，但只要让 <code>right</code> 向右移动（扩大）一位，区间 <code>[0, 1)</code> 就包含一个元素 <code>0</code> 了。如果你设置为两端都开的区间，那么让 <code>right</code> 向右移动一位后开区间 <code>(0, 1)</code> 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 <code>[0, 0]</code> 就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。</p>
<p>2、我们先不断地增加 <code>right</code> 指针扩大窗口 <code>[left, right)</code>，直到窗口中的字符串符合要求（包含了 <code>T</code> 中的所有字符）。</p>
<p>3、此时，我们停止增加 <code>right</code>，转而不断增加 <code>left</code> 指针缩小窗口 <code>[left, right)</code>，直到窗口中的字符串不再符合要求（不包含 <code>T</code> 中的所有字符了）。同时，每次增加 <code>left</code>，我们都要更新一轮结果。</p>
<p>4、重复第 2 和第 3 步，直到 <code>right</code> 到达字符串 <code>S</code> 的尽头。</p>
<p>这个思路其实也不难，<strong>第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解</strong>，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。</p>
<h4 id="长度最小子数组">长度最小子数组</h4>
<p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0</p>
<pre><code class="language-python">class Solution(object):
    def minSubArrayLen(self, target, nums):
        &quot;&quot;&quot;
        :type target: int
        :type nums: List[int]
        :rtype: int
        &quot;&quot;&quot;
        #判断极端情况
        if len(nums) == 0:
            return 0
        #确定最值
        res = len(nums) + 1
        s = 0
        #定义双指针
        right = left = 0
        #扩大窗口
        while(right &lt; len(nums)):
            s = s + nums[right]
            right += 1
            #比较目标值，扩大窗口的终止条件
            while s &gt;= target:
                #righ-left为窗口内的元素
                res = min(res,right-left)
                #从左侧缩小窗口
                s = s - nums[left]
                left += 1
        #所有元素的和小于target
        if res == len(nums)+1:
            return 0
        #符合条件输出
        else:
            return res
</code></pre>
<h4 id="无重复字符的最长子串">无重复字符的最长子串</h4>
<pre><code class="language-python">class Solution(object):
    def lengthOfLongestSubstring(self, s):
        &quot;&quot;&quot;
        :type s: str
        :rtype: int
        &quot;&quot;&quot;
        #极端条件判断
        if len(s) == 0:
            return 0
        #定义所需变量
        left = count = res = 0
        #遍历列表的时间复杂度是O（n），遍历集合的时间复杂度是O（1）
        windows = set()
        #有指针依次向后遍历
        for i in range(len(s)):
            #计数
            count += 1
            #右指针指向元素已经在窗口中，即出现重复元素
            while s[i] in windows:
                #缩小窗口
                windows.remove(s[left])
                count -= 1
                left += 1
            #保留最值
            res = max(res,count)
            #窗口右侧加入元素
            windows.add(s[i])
        #返回结果
        return res
</code></pre>
<h4 id="乘积小于k的子数组">乘积小于K的子数组</h4>
<pre><code class="language-python">class Solution(object):
    def numSubarrayProductLessThanK(self, nums, k):
        &quot;&quot;&quot;
        :type nums: List[int]
        :type k: int
        :rtype: int
        &quot;&quot;&quot;
        #特殊情况
        if k &lt;= 1:
            return 0
        #双指针
        left = 0
        right = 0
        #记录器与计数器
        res = 1
        result = 0
        #扩大窗口
        while right &lt; len(nums):
            res *= nums[right]
            #缩小窗口
            while res &gt;= k:
                res /= nums[left]
                left += 1
            result += (right-left+1)
            right += 1
        return result
</code></pre>
<h4 id="最大连续1的个数">最大连续1的个数</h4>
<pre><code class="language-Python">class Solution:
    def longestOnes(self, nums: List[int], k: int) -&gt; int:
        #设置双指针
        left = 0
        right = 0
        #记录器和计数器
        res = 0
        count = 0
        while right &lt; len(nums):
            #扩大窗口
            if nums[right] == 0:
                count += 1
            right += 1
            #缩小窗口
            if count &gt; k:
                if nums[left] == 0:
                    count -= 1
                left += 1
            res = max(res,right - left)
        return res
</code></pre>
<h2 id="二叉树-2">二叉树</h2>
<p>视频导学：</p>
<p><a href="https://www.bilibili.com/video/BV1nG411x77H?spm_id_from=333.337.search-card.all.click&amp;vd_source=f093c3d64ba399e149cbffa6cd31a7b0">二叉树/递归的框架思维（纲领篇）</a></p>
<p><strong>二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 <a href="https://labuladong.gitee.io/algo/4/30/104/">回溯算法核心框架</a> 和 <a href="https://labuladong.gitee.io/algo/3/24/67/">动态规划核心框架</a></strong>。二叉树模型几乎是所有高级算法的基础，尤其是那么多人说对递归的理解不到位，更应该好好刷二叉树相关题目。</p>
<p>2022.08.28添加：对于递归函数书写的一些<strong>新的思考与启发</strong></p>
<p>学习本部分主要是学会使用递归函数的书写逻辑：</p>
<p>再次温习一下之前学过的<strong>递归三部曲</strong>：</p>
<p>1.递归函数的参数和返回值的设置</p>
<p>比如在在写回溯函数时，函数参数需要自己去定义。此时就要考虑，那些参数是我需要的，那些参数是题目中已知的；自定义的这个函数的类型是什么：viod泛型？bool型？int型？</p>
<pre><code class="language-c++">void traverse(参数1，参数2....){
    
}
</code></pre>
<p>2.终止条件</p>
<p>多数情况下就是遍历到树的根节点后开始返回；</p>
<pre><code class="language-c++">if(rooot == NULL){
	return;
}
</code></pre>
<p>3.递归的逻辑</p>
<p>在终止条件之后紧接着就是递归函数的调用；绝大多数递归的逻辑是前序逻辑，题目让干啥咱就干啥，而且递归的顺序一般就是先左子树后右子树，从上到下的DFS。</p>
<pre><code class="language-c++">//前序操作（看题目要求）
traverse(root-&gt;left,....);
traverse(root-&gt;right,....);
</code></pre>
<p>对于大多数的算法，暴力解决是可以的；但是无数个for循环嵌套既浪费时间又浪费空间，当情况较复杂是，for循环嵌套必定会出错。而递归回溯函数的书写，就是让计算机自己去深处遍历迭代，空间时间都可节省，可谓是计算机思维的精髓之处。</p>
<p>树既有递归遍历又有迭代遍历，在迭代遍历时一定要注意while循环的终止条件，一般是当节点不为空时，终止循环while；即：<strong>while(!=root)</strong></p>
<h3 id="二叉树-纲领篇">二叉树-纲领篇</h3>
<table>
<thead>
<tr>
<th style="text-align:center">LeetCode</th>
<th style="text-align:center">力扣</th>
<th style="text-align:center">难度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/">104. Maximum Depth of Binary Tree</a></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></td>
<td style="text-align:center">🟢</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://leetcode.com/problems/binary-tree-preorder-traversal/">144. Binary Tree Preorder Traversal</a></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历</a></td>
<td style="text-align:center">🟢</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://leetcode.com/problems/diameter-of-binary-tree/">543. Diameter of Binary Tree</a></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></td>
<td style="text-align:center">🟢</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/">剑指 Offer 55 - I. 二叉树的深度</a></td>
<td style="text-align:center">🟢</td>
</tr>
</tbody>
</table>
<p>总的老说，二叉树的两种解决思路：<br>
1.遍历-&gt;回溯问题-&gt;前序操作<br>
2.分解-&gt;动规问题-&gt;后序操作</p>
<p>遇到一道二叉树的题目时的通用思考过程是：</p>
<p><strong>1、是否可以通过遍历一遍二叉树得到答案</strong>？如果可以，用一个 <code>traverse</code> 函数配合外部变量来实现。</p>
<p><strong>2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案</strong>？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。</p>
<p><strong>3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做</strong>。</p>
<p>二叉树的框架思维：</p>
<pre><code class="language-Java">void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    // 前序位置
    traverse(root.left);
    // 中序位置
    traverse(root.right);
    // 后序位置
</code></pre>
<p>以数组和链表为例，看遍历和分解的区别与联系：</p>
<pre><code class="language-python">/* 迭代遍历数组 */
#void traverse(int[] arr) {
    #for (int i = 0; i &lt; arr.length; i++) {

    #}
#}
def traverse(int[] arr):
	for i in range(len(arr)):
	

/* 递归遍历数组 */
#void traverse(int[] arr, int i) {
    #if (i == arr.length) {
        #return;
    #}
    #// 前序位置
    #traverse(arr, i + 1);
    #// 后序位置
#}
def traverse(int[] arr, int i):
	if (i == len(arr)):
		return
		
	// 前序位置
    traverse(arr, i + 1);
    // 后序位置

/* 迭代遍历单链表 */
#void traverse(ListNode head) {
    #for (ListNode p = head; p != null; p = p.next) {

    #}
#}
def traverse(ListNode head):
	p = head
	while(p != None and p.next != None):
		p = p.next

/* 递归遍历单链表 */
#void traverse(ListNode head) {
    #if (head == null) {
        #return;
    #}
    #// 前序位置
    #traverse(head.next);
    #// 后序位置
#}
def traverse(ListNode head):
	if (head == None):
		return
		
	// 前序位置
    traverse(head.next);
    // 后序位置
</code></pre>
<p>递归三部曲：</p>
<p>递归函数的参数返回值</p>
<p>终止条件</p>
<p>递归的逻辑</p>
<h4 id="二叉树的最大深度">二叉树的最大深度</h4>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def maxDepth(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: int
        &quot;&quot;&quot;
        #分解问题：先找左右子树的最大深度然后加一-动态规划思路(后序位置操作)
        #递归到根节点
        if(root == None):
            return 0
        
        leftmax = self.maxDepth(root.left)
        rightmax = self.maxDepth(root.right)
        #推到原二叉树的最大深度
        return max(leftmax,rightmax) + 1
</code></pre>
<pre><code class="language-java">#回溯思路
    class Solution {

    int depth = 0;
    int res = 0;

    public int maxDepth(TreeNode root) {
        traverse(root);
        return res;
    }

    // 遍历二叉树
    void traverse(TreeNode root) {
        if (root == null) {
            return;
        }

        // 前序遍历位置
        depth++;
        // 遍历的过程中记录最大深度
        res = Math.max(res, depth);
        traverse(root.left);
        traverse(root.right);
        // 后序遍历位置
        depth--;
    }
}
</code></pre>
<h4 id="二叉树最小深度">二叉树最小深度</h4>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def minDepth(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: int
        &quot;&quot;&quot;
        if not root:
            return 0
        if not root.left and not root.right:
            return 1

        min_depth = 10**9
        if root.left:
            min_depth = min(self.minDepth(root.left), min_depth) # 获得左子树的最小高度
        if root.right:
            min_depth = min(self.minDepth(root.right), min_depth) # 获得右子树的最小高度
        return min_depth + 1
</code></pre>
<h4 id="二叉树的遍历">二叉树的遍历</h4>
<h5 id="前序遍历">前序遍历</h5>
<p>递归解法</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
#递归解法
class Solution:
    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:
        def preorder(root: TreeNode):
            if not root:
                return
            res.append(root.val)
            preorder(root.left)
            preorder(root.right)
        
        res = list()
        preorder(root)
        return res
  
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def preorderTraversal(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: List[int]
        &quot;&quot;&quot;
        #保存结果
        res = []

        #定义遍历函数
        def traversal(root):
            #根节点判断
            if root == None:
                return
            res.append(root.val)
            traversal(root.left)
            traversal(root.right)
        
        traversal(root)
        return res
</code></pre>
<p>迭代解法</p>
<pre><code class="language-python">class Solution:
    def preorderTraversal(self, root: TreeNode) -&gt; List[int]:
        res = list()
        if not root:
            return res
        
        stack = []
        node = root
        while stack or node:
            while node:
                res.append(node.val)
                stack.append(node)
                node = node.left
            node = stack.pop()
            node = node.right
        return res
</code></pre>
<h5 id="中序遍历">中序遍历</h5>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def inorderTraversal(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: List[int]
        &quot;&quot;&quot;
        #保存结果
        res = []

        def traervsal(root):
            #根节点判断
            if root == None:
                return
            #递归遍历
            traervsal(root.left)
            #中序操作
            res.append(root.val)
            traervsal(root.right)
        traervsal(root)
        return res
</code></pre>
<h5 id="后序遍历">后序遍历</h5>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def postorderTraversal(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: List[int]
        &quot;&quot;&quot;
        #保存结果
        res = []

        #定义遍历函数
        def traversal(root):
            if root == None:
                return
            traversal(root.left)
            traversal(root.right)
            #后序操作
            res.append(root.val)
        traversal(root)
        return res
</code></pre>
<h4 id="二叉树的最大直径">二叉树的最大直径</h4>
<p>后序遍历</p>
<pre><code class="language-python"># class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -&gt; int:
        self.ans = 1
        def depth(node):
            # 访问到空节点了，返回0
            if not node:
                return 0
            # 左孩子为根的子树的深度
            L = depth(node.left)
            # 右孩子为根的子树的深度
            R = depth(node.right)
            # 计算d_node即L+R+1 并更新ans
            self.ans = max(self.ans, L + R + 1)
            # 返回该节点为根的子树的深度
            return max(L, R) + 1

        depth(root)
        return self.ans - 1
</code></pre>
<h4 id="二叉树的层序遍历">二叉树的层序遍历</h4>
<p>层序遍历就是从左到右一层一层去遍历二叉树。需要借用一个辅助数据结构即队列来实现，<strong>队列先进先出，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上</strong><a href="https://programmercarl.com/0102.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.html">[1]</a></p>
<h5 id="层序遍历">层序遍历</h5>
<pre><code class="language-python">#层序遍历迭代法：
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def levelOrder(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        results = []
        if not root:
            return results
        
        from collections import deque
        que = deque([root])
        
        while que:
            size = len(que)
            result = []
            for _ in range(size):
                cur = que.popleft()
                result.append(cur.val)
                if cur.left:
                    que.append(cur.left)
                if cur.right:
                    que.append(cur.right)
            results.append(result)

        return results
    
  
#层序遍历递归法
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def levelOrder(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        res = []
        def cengxu(root,depth):
            if not root:
                return []
            if len(res) == depth:
                res.append([])
            res[depth].append(root.val)
            if root.left:
                cengxu(root.left,depth+1)
            if root.right:
                cengxu(root.right,depth+1)
        cengxu(root,0)
        return res
   
#[[3],[9,20],[15,7]]最后的结果是列表的嵌套

#自底向上层序遍历
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]:
        #记录结果
        res = []
        #定义层序遍历函数
        def cengxu(root,depth):
            #根节点判断
            if not root:
                return None
            #一开始很不理解这一步
            #观察结果:[[15,7],[9,20],[3]]；涉及到列表的嵌套
            #每当深度加一,就要增加一个子列表
            if len(res) == depth:
                res.append([])
            res[depth].append(root.val)
            if root.left:
                cengxu(root.left,depth + 1)
            if root.right:
                cengxu(root.right,depth + 1)
        cengxu(root,0)
        return res[::-1]
</code></pre>
<h5 id="二叉树的右视图">二叉树的右视图</h5>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def rightSideView(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: List[int]
        &quot;&quot;&quot;
        #结果记录
        res = []
        #定义层序遍历函数
        def cengxu(root,depth):
            if not root:
                return None
            if len(res) == depth:
                res.append(root.val)
            #res[depth].append(root.val)
            #只去遍历右子树-准确来说是去遍历每个节点的右子树
            if root.right:
                cengxu(root.right,depth + 1)
            if root.left:
                cengxu(root.left,depth + 1)
        cengxu(root,0)
        return res
</code></pre>
<h5 id="计算二叉树每层节点的平均数">计算二叉树每层节点的平均数</h5>
<pre><code class="language-Python"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def averageOfLevels(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: List[float]
        &quot;&quot;&quot;
        #保存结果
        res = []
        ans = []
        #定义层序遍历函数
        def cengxu(root,depth):
            if not root:
                return None
            if len(res) == depth:
                res.append([])
            res[depth].append(root.val)
            #遍历左右子树
            if root.left:
                cengxu(root.left,depth + 1)
            if root.right:
                cengxu(root.right,depth + 1)
        cengxu(root,0)
        for i in range(len(res)):
            sum1 = sum(res[i])
            num = len(res[i])
            ans.append(sum1 / num)
        return ans
</code></pre>
<h3 id="二叉树-思路篇">二叉树-思路篇</h3>
<p>层序遍历+栈就是后序遍历结果</p>
<p>刷完上面纲领篇幅的一些体会：</p>
<p>二叉树重要的部分：框架+细节；框架主要是对递归函数的书写，细节就是-前序遍历OR后序遍历-代码的摆放<strong>位置</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">LeetCode</th>
<th style="text-align:center">力扣</th>
<th style="text-align:center">难度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/">114. Flatten Binary Tree to Linked List</a></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></td>
<td style="text-align:center">🟠</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node/">116. Populating Next Right Pointers in Each Node</a></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/">116. 填充每个节点的下一个右侧节点指针</a></td>
<td style="text-align:center">🟠</td>
</tr>
<tr>
<td style="text-align:center"><a href="https://leetcode.com/problems/invert-binary-tree/">226. Invert Binary Tree</a></td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></td>
<td style="text-align:center">🟢</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center"><a href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/">剑指 Offer 27. 二叉树的镜像</a></td>
<td style="text-align:center">🟢</td>
</tr>
</tbody>
</table>
<h4 id="反转二叉树">反转二叉树</h4>
<p>反转的思想就是借助tmp指针进行左右节点的交换</p>
<p>分解问题思路：</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def invertTree(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: TreeNode
        &quot;&quot;&quot;
        #判断根节点
        if root == None:
            return
            
        #分解问题的思路
        self.invertTree(root.left)
        self.invertTree(root.right)

        tmp = root.left
        root.left = root.right
        root.right = tmp
        return root
</code></pre>
<p>回溯思路：</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    
    def invertTree(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: TreeNode
        &quot;&quot;&quot;
        self.traverse(root)
        return root
        
    def traverse(self, root):
        if root == None:
            return
        #前序位置
        tmp = root.left
        root.left = root.right
        root.right = tmp
        #遍历框架，去遍历左右子树的节点
        self.traverse(root.left)
        self.traverse(root.right)
</code></pre>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        /*
        //终止节点判断
        //从上到下递归遍历
        if(root == NULL) return root;
        swap(root-&gt;left,root-&gt;right);
        invertTree(root-&gt;left);
        invertTree(root-&gt;right);
        return root;
        */
        //迭代遍历
        if(root == NULL) return root;
        stack&lt;TreeNode*&gt; st;
        st.push(root);
        while(!st.empty()){
            TreeNode* node = st.top();
            st.pop();
            swap(node-&gt;left,node-&gt;right);
            if(node-&gt;right) st.push(node-&gt;right);
            if(node-&gt;left) st.push(node-&gt;left);

        }
        return root;

    }
};
</code></pre>
<h4 id="对称二叉树">对称二叉树</h4>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def isSymmetric(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: bool
        &quot;&quot;&quot;
        if not root:
            return True
        return self.compare(root.left, root.right)
        
    def compare(self, left, right):
        #对称二叉树的条件
        if left != None and right == None:
            return False
        elif left == None and right != None:
            return False
        elif left == None and right == None:
            return True
        elif left.val != right.val:
            return False
        #此时就是左右节点相同进入下一层遍历
        ots = self.compare(left.left,right.right)
        ins = self.compare(left.right,right.left)
        isSymmetric = ots and ins
        return isSymmetric
</code></pre>
<h4 id="填充每个节点的下一个右侧节点指针">填充每个节点的下一个右侧节点指针</h4>
<p>前序遍历：</p>
<p>前序遍历时要定义一个traverse函数用于递归前序节点。</p>
<pre><code class="language-python">&quot;&quot;&quot;
# Definition for a Node.
class Node(object):
    def __init__(self, val=0, left=None, right=None, next=None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
&quot;&quot;&quot;

class Solution(object):
    def connect(self, root):
        &quot;&quot;&quot;
        :type root: Node
        :rtype: Node
        &quot;&quot;&quot;
        #根节点情况
        if root == None:
            return
        self.traverse(root.left,root.right)
        return root
    def traverse(self,node1,node2):
        if node1 == None and node2 == None:
            return
        #连接传入的两个节点
        node1.next = node2
        #前序遍历
        self.traverse(node1.left,node1.right)
        self.traverse(node2.left,node2.right)
        self.traverse(node1.right,node2.left)
</code></pre>
<h4 id="将二叉树展开为链表">将二叉树展开为链表</h4>
<p>首先通过遍历寻求解题思路：发现遍历虽然得到了前序遍历结果但是无法把原来的二叉树拉平为一个链表</p>
<p>因此寻求分解问题的解决方法：先拉平左子树，在拉平右子树；最后将右子树嫁接到左子树上即可完成。</p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def flatten(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: None Do not return anything, modify root in-place instead.
        &quot;&quot;&quot;
        #根节点操作
        if root == None:
            return 
        #拉平左右子树
        self.flatten(root.left)
        self.flatten(root.right)
        #后序操作:分别将子树拉平为链表
        l = root.left
        r = root.right
        #将左子树作为右子树
        root.left = None
        root.right = l
        #将原先的右子树接到当前右子树的末端
        p = root
        while(p.right != None):
            p = p.right
        p.right = r
</code></pre>
<h4 id="左叶子之和">左叶子之和</h4>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def sumOfLeftLeaves(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: int
        &quot;&quot;&quot;
        #根节点判断
        if not root: 
            return 0
        
        left_left_leaves_sum = self.sumOfLeftLeaves(root.left)  # 左
        right_left_leaves_sum = self.sumOfLeftLeaves(root.right) # 右
        
        cur_val = 0
        if root.left and not root.left.left and not root.left.right: 
            cur_val = root.left.val  # 中
            
        return cur_val + left_left_leaves_sum + right_left_leaves_sum
</code></pre>
<h3 id="二叉树-构造篇">二叉树-构造篇</h3>
<p>每日一遍解题思路：</p>
<p>二叉树解题的思维模式分两类：</p>
<p><strong>1、是否可以通过遍历一遍二叉树得到答案</strong>？如果可以，用一个 <code>traverse</code> 函数配合外部变量来实现，这叫「遍历」的思维模式。</p>
<p><strong>2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案</strong>？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。</p>
<p>无论使用哪种思维模式，你都需要思考：</p>
<p><strong>如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做</strong>？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。</p>
<p><strong>二叉树的构造问题一般都是使用「分解问题」的思路：构造整棵树 = 根节点 + 构造左子树 + 构造右子树</strong>。</p>
<h4 id="最大二叉树">最大二叉树</h4>
<pre><code class="language-Python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def constructMaximumBinaryTree(self, nums: List[int]) -&gt; TreeNode:
        if not nums:
            return None
        #先找到最大值与其对应的索引 根节点 
        maxvalue = max(nums)
        index = nums.index(maxvalue)
        #将最大值确定为父节点 根节点 
        root = TreeNode(maxvalue)
        #前序操作划分左右子树  构造左子树 + 构造右子树
        left = nums[:index]
        right = nums[index + 1:]
        #递归遍历
        root.left = self.constructMaximumBinaryTree(left)
        root.right = self.constructMaximumBinaryTree(right)
        return root
</code></pre>
<h4 id="通过前序和中序遍历结果构造二叉树">通过前序和中序遍历结果构造二叉树</h4>
<p><strong>我们肯定要想办法确定根节点的值，把根节点做出来，然后递归构造左右子树即可</strong>。</p>
<p>前序遍历和中序遍历的结果有什么特点：</p>
<pre><code class="language-Java">void traverse(TreeNode root) {
    // 前序遍历
    preorder.add(root.val);
    traverse(root.left);
    traverse(root.right);
}

void traverse(TreeNode root) {
    traverse(root.left);
    // 中序遍历
    inorder.add(root.val);
    traverse(root.right);
</code></pre>
<p>找到根节点是很简单的，前序遍历的第一个值 <code>preorder[0]</code> 就是根节点的值。</p>
<p>关键在于如何通过根节点的值，将 <code>preorder</code> 和 <code>postorder</code> 数组划分成两半，构造根节点的左右子树？</p>
<p>换句话说，对于以下代码中的 <code>?</code> 部分应该填入什么：</p>
<pre><code class="language-java">/* 主函数 */
public TreeNode buildTree(int[] preorder, int[] inorder) {
    // 根据函数定义，用 preorder 和 inorder 构造二叉树
    return build(preorder, 0, preorder.length - 1,
                 inorder, 0, inorder.length - 1);
}

/* 
    build 函数的定义：
    若前序遍历数组为 preorder[preStart..preEnd]，
    中序遍历数组为 inorder[inStart..inEnd]，
    构造二叉树，返回该二叉树的根节点 
*/
TreeNode build(int[] preorder, int preStart, int preEnd, 
               int[] inorder, int inStart, int inEnd) {
    // root 节点对应的值就是前序遍历数组的第一个元素
    int rootVal = preorder[preStart];
    // rootVal 在中序遍历数组中的索引
    int index = 0;
    for (int i = inStart; i &lt;= inEnd; i++) {
        if (inorder[i] == rootVal) {
            index = i;
            break;
        }
    }

    TreeNode root = new TreeNode(rootVal);
    // 递归构造左右子树
    root.left = build(preorder, ?, ?,
                      inorder, ?, ?);

    root.right = build(preorder, ?, ?,
                       inorder, ?, ?);
    return root;
}
</code></pre>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def buildTree(self, preorder, inorder):
        &quot;&quot;&quot;
        :type preorder: List[int]
        :type inorder: List[int]
        :rtype: TreeNode
        &quot;&quot;&quot;
        #树为空，进行递归终止
        if not preorder:
            return None
        
        #找到并构造根节点
        rootval = preorder[0]
        root = TreeNode(rootval)
        #从中序遍历切割
        index = inorder.index(rootval)
        inleft = inorder[:index]
        inright = inorder[index + 1:]
        #重点：切割前序数组：注意子数组大小一定保持不变
        preleft = preorder[1:1+len(inleft)]
        preright = preorder[len(inleft)+1:]
        #递归
        root.left = self.buildTree(preleft,inleft)
        root.right = self.buildTree(preright,inright)
        return root
</code></pre>
<h4 id="从中序与后序遍历序列构造二叉树">从中序与后序遍历序列构造二叉树</h4>
<pre><code class="language-Python"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def buildTree(self, inorder, postorder):
        &quot;&quot;&quot;
        :type inorder: List[int]
        :type postorder: List[int]
        :rtype: TreeNode
        &quot;&quot;&quot;
        #特殊情况判断
        if not postorder:
            return None
        #找到并构建根节点
        rootval = postorder[-1]
        root = TreeNode(rootval)
        #中序数组在确定位置并切割数组
        index = inorder.index(rootval)
        inleft = inorder[:index]
        inright = inorder[index+1:]
        #重点是后序数组切割大小
        poleft = postorder[:len(inleft)]
        poright = postorder[len(inleft):len(postorder)-1]
        #递归
        root.left = self.buildTree(inleft,poleft)
        root.right = self.buildTree(inright,poright)
        return root
</code></pre>
<h4 id="完全二叉树节点个数">完全二叉树节点个数</h4>
<pre><code class="language-python">class Solution:
    def countNodes(self, root: TreeNode) -&gt; int:
        return self.getNodesNum(root)
        
    def getNodesNum(self, cur):
        if not cur:
            return 0
        leftNum = self.getNodesNum(cur.left) #左
        rightNum = self.getNodesNum(cur.right) #右
        treeNum = leftNum + rightNum + 1 #中
        return treeNum
   
#简化版
class Solution:
    def countNodes(self, root: TreeNode) -&gt; int:
        if not root:
            return 0
        return 1 + self.countNodes(root.left) + self.countNodes(root.right)
</code></pre>
<h4 id="平衡二叉树">平衡二叉树</h4>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isBalanced(self, root: TreeNode) -&gt; bool:
        if self.get_height(root) != -1:
            return True
        else:
            return False
    
    def get_height(self, root: TreeNode) -&gt; int:
        # Base Case
        if not root:
            return 0
        # 左
        if (left_height := self.get_height(root.left)) == -1:
            return -1
        # 右
        if (right_height := self.get_height(root.right)) == -1:
            return -1
        # 中
        if abs(left_height - right_height) &gt; 1:
            return -1
        else:
            return 1 + max(left_height, right_height)
</code></pre>
<h4 id="二叉树的路径">二叉树的路径</h4>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def binaryTreePaths(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: List[str]
        &quot;&quot;&quot;
        path = ''
        res = []
        if not root:
            return res
        self.road(root,path,res)
        return res

    #定义遍历函数 
    def road(self,cur,path,res):
        #路径表示
        path += str(cur.val)
        #叶子结点判断
        if not cur.left and not cur.right:
            res.append(path)
        #递归左右子树
        if cur.left:
            self.road(cur.left,path + '-&gt;',res)
        if cur.right:
            self.road(cur.right,path + '-&gt;',res)
</code></pre>
<h4 id="二叉树减枝">二叉树减枝</h4>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* pruneTree(TreeNode* root) {
        //判断空值
        if(!root){
            return nullptr;
        }
        //递归左右子树
        root-&gt;left = pruneTree(root-&gt;left);
        root-&gt;right = pruneTree(root-&gt;right);
        //判断根节点
        if(root-&gt;val == 0 &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right){
            return nullptr;
        }
        return root;
    }
};
</code></pre>
<h4 id="最大二叉树-2">最大二叉树</h4>
<p>给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:</p>
<p>创建一个根节点，其值为 nums 中的最大值。<br>
递归地在最大值 左边 的 子数组前缀上 构建左子树。<br>
递归地在最大值 右边 的 子数组后缀上 构建右子树。<br>
返回 nums 构建的 最大二叉树 。<br>
链接：https://leetcode.cn/problems/maximum-binary-tree</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) {
        TreeNode* node = new TreeNode(0);
        if (nums.size() == 1) {
            node-&gt;val = nums[0];
            return node;
        }
        // 找到数组中最大的值和对应的下表
        int maxValue = 0;
        int maxValueIndex = 0;
        for (int i = 0; i &lt; nums.size(); i++) {
            if (nums[i] &gt; maxValue) {
                maxValue = nums[i];
                maxValueIndex = i;
            }
        }
        node-&gt;val = maxValue;
        // 最大值所在的下表左区间 构造左子树
        if (maxValueIndex &gt; 0) {
            vector&lt;int&gt; newVec(nums.begin(), nums.begin() + maxValueIndex);
            node-&gt;left = constructMaximumBinaryTree(newVec);
        }
        // 最大值所在的下表右区间 构造右子树
        if (maxValueIndex &lt; (nums.size() - 1)) {
            vector&lt;int&gt; newVec(nums.begin() + maxValueIndex + 1, nums.end());
            node-&gt;right = constructMaximumBinaryTree(newVec);
        }
        return node;
    }
};

//优化遍历代码
class Solution {
private:
    // 在左闭右开区间[left, right)，构造二叉树
    TreeNode* traversal(vector&lt;int&gt;&amp; nums, int left, int right) {
        if (left &gt;= right) return nullptr;

        // 分割点下表：maxValueIndex
        int maxValueIndex = left;
        for (int i = left + 1; i &lt; right; ++i) {
            if (nums[i] &gt; nums[maxValueIndex]) maxValueIndex = i;
        }

        TreeNode* root = new TreeNode(nums[maxValueIndex]);

        // 左闭右开：[left, maxValueIndex)
        root-&gt;left = traversal(nums, left, maxValueIndex);

        // 左闭右开：[maxValueIndex + 1, right)
        root-&gt;right = traversal(nums, maxValueIndex + 1, right);

        return root;
    }
public:
    TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) {
        return traversal(nums, 0, nums.size());
    }
};
</code></pre>
<h4 id="合并二叉树">合并二叉树</h4>
<p>给你两棵二叉树： root1 和 root2 。</p>
<p>想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。</p>
<p>返回合并后的二叉树。</p>
<p>注意: 合并过程必须从两个树的根节点<br>
链接：https://leetcode.cn/problems/merge-two-binary-trees</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        //终止条件
        if(root1 == NULL) return root2;
        if(root2 == NULL) return root1;
        //单层递归的逻辑
        root1-&gt;val += root2-&gt;val;
        root1-&gt;left = mergeTrees(root1-&gt;left,root2-&gt;left);
        root1-&gt;right = mergeTrees(root1-&gt;right,root2-&gt;right);
        return root1;

    }
};
</code></pre>
<h3 id="二叉树-后序篇">二叉树-后序篇</h3>
<p>后序遍历二叉树是一种自底向上的遍历过程；后序遍历思想在回溯算法中应用最为广泛，本质就是一棵树先从上到下不操作，一撸到底，然后从叶子结点开始，向上根节点回溯的过程；说白了也就是递归的逆过程。</p>
<p>为什么都是后序遍历呢？这是一个值得思考的问题。</p>
<p>用剪枝的思想，去类比问题。无论是寻找最大直径、最长相同路径还是最大路径和，本质上都是一个从树的底部向树的顶部（root）去剪枝优化的过程。其实剪枝说的不准确，但是剪枝的目的也是寻找最优路径的选取过程。始终记住，后序是因为自底向上寻找的思路，那么这些问题就可以总结出一个很好模板思路。</p>
<h4 id="二叉树的最大直径-2">二叉树的最大直径</h4>
<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
 //后序遍历如何用？
 //遍历函数怎么写？
 //返回值是什么？
 //终止条件是什么？
 //单层遍历的逻辑是什么？
class Solution {
private:
    //int ans = 1;
    //dfs深度优先
    //函数定义的类型一定要和返回值密切相关。
    int travseral(TreeNode* node){
        //终止条件就是向下遍历到根节点
        if(node == NULL){
            return 0;
        }
        return max(travseral(node-&gt;left),travseral(node-&gt;right)) + 1;

    }
public:
    int diameterOfBinaryTree(TreeNode* root) {
        if(root == NULL) return 0;
        //定义左右子树之间的最大值
        int cur = travseral(root-&gt;left) + travseral(root-&gt;right);
        //diameterOfBinaryTree函数是返回左右子树自身的最大值
        //最后返回的是左右子树、左子树自身、右子树自身三者之间的最大值
        return max({cur,diameterOfBinaryTree(root-&gt;left),diameterOfBinaryTree(root-&gt;right)});

    }
};
</code></pre>
<h4 id="最长同值路径">最长同值路径</h4>
<p>给定一个二叉树的 root ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。</p>
<p>两个节点之间的路径长度 由它们之间的边数表示。<br>
链接：https://leetcode.cn/problems/longest-univalue-path</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    int res = 0;
    //遍历函数时什么、返回值是什么？
    int dfs(TreeNode* root,int parentVal){
        //终止条件
        if(root == NULL){
            return 0;
        }
        // 利用函数定义，计算左右子树值为 root.val 的最长树枝长度
        int left = dfs(root-&gt;left,root-&gt;val);
        int right = dfs(root-&gt;right,root-&gt;val);

        //后序操作:直接返回左右子树最大路径之和
        res = max(res, left + right);
        // 如果 root 本身和上级值不同，那么整棵子树都不可能有同值树枝
        if(root-&gt;val != parentVal){
            //注意返回值的设定
            return 0;
        }
        // 实现函数的定义：
        // 以 root 为根的二叉树从 root 开始值为 parentVal 的最长树枝长度
        // 等于左右子树的最长树枝长度的最大值加上 root 节点本身
        return 1 + max(left,right);


    }
public:
    int longestUnivaluePath(TreeNode* root) {
        if(root == NULL){
            return 0;
        }
        dfs(root,root-&gt;val);
        return res;

    }
};
</code></pre>
<h4 id="二叉树中最大路径和">二叉树中最大路径和</h4>
<p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p><strong>路径和</strong> 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。<br>
链接：https://leetcode.cn/problems/binary-tree-maximum-path-sum</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:

    int ret = INT_MIN;
    //函数定义和返回值是什么？
    // 定义：计算从根节点 root 为起点的最大单边路径和
    int dfs(TreeNode* root){
        //终止条件
        if(root == NULL){
            return 0;
        }
        int leftsum = max(0,dfs(root-&gt;left));
        int rightsum = max(0,dfs(root-&gt;right));
        // 后序遍历位置，顺便更新最大路径和
        int pathsum = root-&gt;val + leftsum + rightsum;
        ret = max(ret,pathsum);
        // 实现函数定义，左右子树的最大单边路径和加上根节点的值
        // 就是从根节点 root 为起点的最大单边路径和
        return max(leftsum,rightsum) + root-&gt;val;

    }
public:
    int maxPathSum(TreeNode* root) {
        if(root == NULL){
            return 0;
        }
        dfs(root);
        return ret;

    }
};
</code></pre>
<h3 id="二叉搜索树">二叉搜索树</h3>
<p>二叉搜索树的基本概念：</p>
<p>二叉搜索树是一颗有序树，满足如下规则：</p>
<ul>
<li>若它的左子树不空，则左子树上所有节点的值都小于它的根节点上的值。</li>
<li>若它的右子树不空，则右子树上所有节点的值都大于它的根节点上的值。</li>
<li>它的左右子树也分别书二叉排序树。</li>
</ul>
<p>二叉搜索树的<strong>中序遍历</strong>是一个严格的<strong>递增序列</strong>。所有在遇到二叉搜索树的相关问题时，巧用<strong>中序遍历</strong>是解题的关键也是解决问题的快速方法。</p>
<p>中序遍历代码：</p>
<pre><code class="language-c++">void searchBST(TreeNode* cur){
    if(cur == NULL) return;
    searchBST(root-&gt;left);//左
    (中序操作)
    searchBST(root-&gt;right);//右
}
</code></pre>
<p>在解决二叉搜索树的最值问题时，递归可以采用两种基本的方式：</p>
<p>1.以<strong>数组</strong>为基本数据结构的方式</p>
<p>思路：</p>
<p>以数组为基本的存储方式中序遍历写起来较为直观</p>
<pre><code class="language-c++">vector&lt;int&gt; res;
void travser(TreeNode* root){
        if(root == NULL) return;
        travser(root-&gt;left);
        res.push_back(root-&gt;val);
        travser(root-&gt;right);
</code></pre>
<p>操作是放在<strong>主函数</strong>中进行，在主函数利用for循环进行求解最值得问题；<strong>中序遍历</strong>的方法只是为了得到一个<strong>升序的数组</strong>，得以把一颗二叉排序树转化成一个单调递增的数组，以方便处理。</p>
<p>2.以<strong>单链表</strong>为基本数据结构的方式</p>
<p>思路：</p>
<p>单链表的方式需要设置两个节点指针：<strong>cur和pre</strong>，相当于一个头指针和一个尾指针；无论是在迭代还是在递归中，头尾指针的设定就是去摆脱在主函数中的二次for循环操作，而降低时间复杂度，在递归的过程中即实现操作的一步到位。</p>
<pre><code class="language-c++">TreeNode* pur = NULL;//记录前一个节点
//TreeNode* cur = root;
if(root == NULL) return true;
//中序遍历思路
bool left = isValidBST(root-&gt;left);
//相当于是中序遍历操作中在操作的判断
//运用头结点pur判断是否是一个递增的序列
if(pur != NULL &amp;&amp; pur-&gt;val &gt;= root-&gt;val) return false;
pur = root;
bool right = isValidBST(root-&gt;right);
//相当于中序遍历多加了一个if判断操作
</code></pre>
<h4 id="在二叉搜索树中寻找节点">在二叉搜索树中寻找节点</h4>
<p>给定二叉搜索树（BST）的根节点 root 和一个整数值 val。</p>
<p>你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。<br>
链接：https://leetcode.cn/problems/search-in-a-binary-search-tree</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    //确定递归函数和参数设置
    TreeNode* searchBST(TreeNode* root, int val) {
        //终止条件
        if(root == NULL || root-&gt;val == val) return root;
        //因为二叉搜索树的节点大小是有规律的所以可以简化搜索
        if(root-&gt;val &gt; val) return searchBST(root-&gt;left,val);
        if(root-&gt;val &lt; val) return searchBST(root-&gt;right,val);
        return NULL; 

    }
};
</code></pre>
<h4 id="验证二叉搜索树">验证二叉搜索树</h4>
<p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<p>有效 二叉搜索树定义如下：</p>
<p>节点的左子树只包含 小于 当前节点的数。<br>
节点的右子树只包含 大于 当前节点的数。<br>
所有左子树和右子树自身必须也是二叉搜索树。<br>
链接：https://leetcode.cn/problems/validate-binary-search-tree</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    //思路：中序遍历构建一个递增的数组
    vector&lt;int&gt; res;
    void travser(TreeNode* root){
        if(root == NULL) return;
        travser(root-&gt;left);
        res.push_back(root-&gt;val);
        travser(root-&gt;right);
    }
public:
    bool isValidBST(TreeNode* root) {
        res.clear();
        travser(root);
        for(int i = 1;i &lt; res.size();i++){
            if(res[i] &lt;= res[i - 1]){
                return false;
            }
        }
        return true;
    }
};

改进：
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* pur = NULL;//记录前一个节点
    //TreeNode* cur = root;
    bool isValidBST(TreeNode* root) {
        if(root == NULL) return true;
        //中序遍历思路
        bool left = isValidBST(root-&gt;left);
        //相当于是中序遍历操作中在操作的判断
        //运用头结点pur判断是否是一个递增的序列
        if(pur != NULL &amp;&amp; pur-&gt;val &gt;= root-&gt;val) return false;
        pur = root;
        bool right = isValidBST(root-&gt;right);
        return left &amp;&amp; right;
    }
};
</code></pre>
<h4 id="二叉搜索树的最小绝对差">二叉搜索树的最小绝对差</h4>
<p>给你一个二叉搜索树的根节点 <code>root</code> ，返回 <strong>树中任意两不同节点值之间的最小差值</strong> 。</p>
<p>差值是一个正数，其数值等于两值之差的绝对值。</p>
<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
vector&lt;int&gt; vec;
void traversal(TreeNode* root) {
    if (root == NULL) return;
    traversal(root-&gt;left);
    vec.push_back(root-&gt;val); // 将二叉搜索树转换为有序数组
    traversal(root-&gt;right);
}

public:
    int getMinimumDifference(TreeNode* root) {
        vec.clear();
        traversal(root);
        if (vec.size() &lt; 2) return 0;
        int result = INT_MAX;
        for (int i = 1; i &lt; vec.size(); i++) { // 统计有序数组的最小差值
            result = min(result, vec[i] - vec[i-1]);
        }
        return result;

    }
};

//设置双节点的另一种做法
class Solution {
private:
int result = INT_MAX;
TreeNode* pre;
void traversal(TreeNode* cur) {
    if (cur == NULL) return;
    traversal(cur-&gt;left);   // 左
    if (pre != NULL){       // 中
        result = min(result, cur-&gt;val - pre-&gt;val);
    }
    pre = cur; // 记录前一个
    traversal(cur-&gt;right);  // 右
}
public:
    int getMinimumDifference(TreeNode* root) {
        traversal(root);
        return result;
    }
};
</code></pre>
<h4 id="二叉搜索树中的众数">二叉搜索树中的众数</h4>
<p>给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。</p>
<p>如果树中有不止一个众数，可以按 任意顺序 返回。<br>
链接：https://leetcode.cn/problems/find-mode-in-binary-search-tree</p>
<pre><code class="language-c++">class Solution {
private:
    int maxCount; // 最大频率
    int count; // 统计频率
    TreeNode* pre;
    vector&lt;int&gt; result;
    void searchBST(TreeNode* cur) {
        if (cur == NULL) return ;

        searchBST(cur-&gt;left);       // 左
                                    // 中
        if (pre == NULL) { // 第一个节点
            count = 1;
        } else if (pre-&gt;val == cur-&gt;val) { // 与前一个节点数值相同
            count++;
        } else { // 与前一个节点数值不同
            count = 1;
        }
        pre = cur; // 更新上一个节点

        if (count == maxCount) { // 如果和最大值相同，放进result中
            result.push_back(cur-&gt;val);
        }

        if (count &gt; maxCount) { // 如果计数大于最大值频率
            maxCount = count;   // 更新最大频率
            result.clear();     // 很关键的一步，不要忘记清空result，之前result里的元素都失效了
            result.push_back(cur-&gt;val);
        }

        searchBST(cur-&gt;right);      // 右
        return ;
    }

public:
    vector&lt;int&gt; findMode(TreeNode* root) {
        count = 0;
        maxCount = 0;
        TreeNode* pre = NULL; // 记录前一个节点
        result.clear();

        searchBST(root);
        return result;
    }
};

//迭代法
class Solution {
public:
    vector&lt;int&gt; findMode(TreeNode* root) {
        stack&lt;TreeNode*&gt; st;
        TreeNode* cur = root;
        TreeNode* pre = NULL;
        int maxCount = 0; // 最大频率
        int count = 0; // 统计频率
        vector&lt;int&gt; result;
        while (cur != NULL || !st.empty()) {
            if (cur != NULL) { // 指针来访问节点，访问到最底层
                st.push(cur); // 将访问的节点放进栈
                cur = cur-&gt;left;                // 左
            } else {
                cur = st.top();
                st.pop();                       // 中
                if (pre == NULL) { // 第一个节点
                    count = 1;
                } else if (pre-&gt;val == cur-&gt;val) { // 与前一个节点数值相同
                    count++;
                } else { // 与前一个节点数值不同
                    count = 1;
                }
                if (count == maxCount) { // 如果和最大值相同，放进result中
                    result.push_back(cur-&gt;val);
                }

                if (count &gt; maxCount) { // 如果计数大于最大值频率
                    maxCount = count;   // 更新最大频率
                    result.clear();     // 很关键的一步，不要忘记清空result，之前result里的元素都失效了
                    result.push_back(cur-&gt;val);
                }
                pre = cur;
                cur = cur-&gt;right;               // 右
            }
        }
        return result;
    }
};
</code></pre>
<h4 id="二叉树搜索树的最近公共祖先">二叉树/搜索树的最近公共祖先</h4>
<p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”<br>
链接：https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree</p>
<pre><code class="language-c++">//普通二叉树的最近祖先
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if(root == p || root == q || root == NULL){
            return root; 
        }
        //寻找公共祖先的思路是要通过自底向上的后序遍历判断公共祖先
        TreeNode *left = lowestCommonAncestor(root-&gt;left,p,q);
        TreeNode *right = lowestCommonAncestor(root-&gt;right,p,q);
        //后序操作
        if(left != NULL &amp;&amp; right != NULL) return root;

        if(left == NULL &amp;&amp; right != NULL) return right;
        else if(left != NULL &amp;&amp; right == NULL) return left;
        else{
            return NULL;
        }

        
    }
};

//二叉搜索树的最近祖先
//注意结合搜索区间进行判断
class Solution {
private:
    TreeNode* traversal(TreeNode* cur, TreeNode* p, TreeNode* q) {
        if (cur == NULL) return cur;
                                                        // 中
        if (cur-&gt;val &gt; p-&gt;val &amp;&amp; cur-&gt;val &gt; q-&gt;val) {   // 左
            TreeNode* left = traversal(cur-&gt;left, p, q);
            if (left != NULL) {
                return left;
            }
        }

        if (cur-&gt;val &lt; p-&gt;val &amp;&amp; cur-&gt;val &lt; q-&gt;val) {   // 右
            TreeNode* right = traversal(cur-&gt;right, p, q);
            if (right != NULL) {
                return right;
            }
        }
        return cur;
    }
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        return traversal(root, p, q);
    }
};
</code></pre>
<h2 id="图论算法">图论算法</h2>
<p>图论章节主要是涉及到了图的两种遍历方式-&gt;<strong>深度优先搜索</strong>和<strong>广度有优先搜索</strong>。</p>
<h4 id="图的基本数据结构的实现">图的基本数据结构的实现</h4>
<p><strong>结构体</strong>是一个由程序员定义的数据类型，可以容纳许多不同的数据值。在过去，面向对象编程的应用尚未普及之前，程序员通常使用这些从逻辑上连接在一起的数据组合到一个单元中。一旦结构体类型被声明并且其数据成员被标识，即可创建该类型的多个变量，就像可以为同一个类创建多个对象一样。</p>
<p><strong>声明结构体</strong>的方式和<strong>声明类</strong>的方式大致相同，其区别如下：</p>
<ul>
<li>使用关键字 <strong>struct</strong> 而不是关键字 class。</li>
<li>尽管结构体可以包含成员函数，但它们很少这样做。所以，通常情况下结构体声明只会声明成员变量。</li>
<li>结构体声明通常不包括 <strong>public 或 private</strong> 的访问修饰符。</li>
<li>类成员默认情况是私有的，而结构体的成员则默认为 public。程序员通常希望它们保持公开，只需使用默认值即可。</li>
</ul>
<p>以下是一个结构体声明的示例，该结构体将 5 个变量绑定在一起，保存了员工的工资单数据。这个特殊结构体的名称是 PayRoll。请注意，它以大写字母开头，这和类名使用大写字母开头的约定一样。另外还要注意，与类声明一样，在结构体声明的大括号后面必须有一个分号。</p>
<pre><code class="language-c">struct PayRoll
{
    int empNumber;
    string name;
    double hours,payRate,grossPay;
};
</code></pre>
<h2 id="结构体">结构体</h2>
<p>当定义结构体变量时，可以通过两种方式初始化它：使用初始化列表或构造函数。</p>
<h4 id="初始化列表">初始化列表</h4>
<p>初始化结构体变量成员的最简单的方法是使用初始化列表。初始化列表是用于初始化一组内存位置的值列表。列表中的项目用逗号分隔并用大括号括起来。</p>
<p>例如，假设已经声明了以下 Date 结构体：</p>
<pre><code class="language-c">struct Date{    
    int day, month, year;
};
</code></pre>
<p>定义和初始化 Date 变量的方式是：先指定变量名，后接赋值运算符和初始化列表，如下所示：</p>
<p>Date birthday = {23, 8, 1983};</p>
<p>该声明定义 birthday 是一个 Date 结构体的变量，大括号内的值按顺序分配给其成员。</p>
<h3 id="bfs广度优先搜索">BFS广度优先搜索</h3>
<p>二叉树的广度优先搜索-&gt;二叉树的层序遍历；而讲到层序遍历，又可以把解题思路分成两种：递归法、迭代法。</p>
<p>这是主要写迭代法，因为相比于递归法的层序遍历，迭代法的BFS算法是最能体现出BFS思路的方法。</p>
<p>需要用到的数据结构：队列-&gt;准确的说是指针队列.</p>
<p>下面咱们就手撸一个BFS算法：</p>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;queue&gt;
#include&lt;stdlib.h&gt;
#include&lt;vector&gt;

using namespace std;

struct TreeNode{
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};

int BFS(TreeNode * root){
    if(root == NULL) return 0;  //终止条件判断
    queue&lt;TreeNode*&gt; que;   //创建队列
    que.push(root); //将根节点入队
    int sum = 0;//设置记录信号
    while(!que.empty()){
        sum = 0;//每次循环之前归零，记录单层的和
        int sz = que.size();//求出队列长度
        for(int i = 0;i &lt; sz;i++){
            //for循环依次对每层求和
            TreeNode* cur = que.front();//取对头元素为初始指针节点
            que.pop();
            sum += cur-&gt;val;
            if(cur-&gt;left != NULL){
                que.push(cur-&gt;left);
            }
            if(cur-&gt;right != NULL){
                que.push(cur-&gt;right);
            }

        }
    }
    return sum;
}
</code></pre>
<p>广度优先搜索——本质上是二叉树的层序遍历（力扣102题）</p>
<p>运用的数据结构是队列和数组；运用数组保存最后的结果，运用队列去模拟层序遍历的过程。</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
        queue&lt;TreeNode*&gt; que;
        if (root != NULL) que.push(root);
        vector&lt;vector&lt;int&gt;&gt; result;
        while (!que.empty()) {
            int size = que.size();
            vector&lt;int&gt; vec;
            // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的
            for (int i = 0; i &lt; size; i++) {
                TreeNode* node = que.front();
                que.pop();
                vec.push_back(node-&gt;val);
                if (node-&gt;left) que.push(node-&gt;left);
                if (node-&gt;right) que.push(node-&gt;right);
            }
            result.push_back(vec);
        }
        return result;
    }
};
</code></pre>
<h3 id="dfs深度优先搜索">DFS深度优先搜索</h3>
<p>深度优先搜索，顾名思义就是一条道路走到底；类比一棵树的话，就是从<strong>上到下先序遍历</strong>一棵树。深度优先，得到的一定先是树的深度（高度）。因为其通常和回溯算法相结合使用，所以其重要性不可估量。学会DFS就是学会使用其<strong>暴力搜索</strong>的功能，学会<strong>聪明的穷举</strong>。避免高强度的多循环嵌套for循环，既浪费时间又浪费空间；那为什么暴力搜索也需要花费大量时间但是还有它存在的道理呢？我认为，存在即合理，很多时候DFS算法存在确实是有他的优势的。最起码，DFS就是利用递归思维去书写程序的一个好模板。虽然本质上和for循环差别不大，但是，一旦问题规模变大，for循环承担不了大工程时，多层循环很容易把人绕懵而且时间复杂度是呈现n方量级增加。这时，DFS的递归遍历就节省了很大的空间复杂度（时间复杂度虽然不敢保证），避免了高强度的循环嵌套，使得程序得以运行出结果。同样，穷举与暴力是程序设计最本源的思路，计算机解决问题最开始的方法就是穷举，人们只是掌握了方法，让计算机学会去聪明的穷举。综上，这是我理解的DFS存在的现实意义与其重要性。</p>
<h4 id="dps算法的设计分析">DPS算法的设计分析</h4>
<p>在学习书写DFS前一定要学会书写树的遍历（递归遍历）</p>
<pre><code class="language-python">res.append(root.val)
preorder(root.left)
preorder(root.right)
</code></pre>
<p>理解了树的递归遍历之后，才能书写出DFS<strong>递归的逻辑</strong>。最本质的还是要理解递归的逻辑~</p>
<p>DFS书写套路：</p>
<p>1.定义存放结果变量</p>
<pre><code class="language-c++">vector&lt;vector&lt;int&gt;&gt; res;//存放最终结果
vector&lt;int&gt; path;//存放路径
</code></pre>
<p>2.回溯函数的框架书写与参数的确定</p>
<pre><code class="language-c++">void backtrack(参数......)
</code></pre>
<p>3.递归过程中搜索的逻辑</p>
<h4 id="dfs算法与回溯算法的关系">DFS算法与回溯算法的关系</h4>
<h4 id="dfs算法书写的模板套路">DFS算法书写的模板套路</h4>
<p>DFS的算法套路书写关键在于正确理解递归函数的参数调用与终止条件的确立。</p>
<h2 id="回溯算法">回溯算法</h2>
<p>回溯铺垫:二叉树的所有路径</p>
<pre><code class="language-c++">**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    void traversal(TreeNode* cur,vector&lt;int&gt; &amp;path,vector&lt;string&gt; &amp;res){

        path.push_back(cur-&gt;val);
        //到达叶子结点
        if(cur-&gt;left == NULL &amp;&amp; cur-&gt;right == NULL){
            string spath;
            for(int i = 0;i &lt; path.size() - 1;i++){
                spath += to_string(path[i]);
                spath += &quot;-&gt;&quot;;
            }
            spath += to_string(path[path.size() - 1]);
            res.push_back(spath);
            return;
        }
        if(cur-&gt;left){
            traversal(cur-&gt;left,path,res);
            path.pop_back();//回溯
        }
        if(cur-&gt;right){
            traversal(cur-&gt;right,path,res);
            path.pop_back();//回溯
        }
    }
public:
    vector&lt;string&gt; binaryTreePaths(TreeNode* root) {
        vector&lt;string&gt; res;
        vector&lt;int&gt; path;
        if(root == NULL) return res;
        traversal(root,path,res);
        return res;
    }
};
</code></pre>
<p>回溯算法和我们常说的 DFS 算法非常类似，本质上就是一种暴力穷举算法。回溯算法和 DFS 算法的细微差别是：<strong>回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」</strong>。</p>
<p>回溯算法解决从上到下一次遍历整颗树，在其模板中，运用for循环去横向遍历——做选择；利用递归（回溯函数）去纵向遍历——路径。</p>
<p>路径、选择、终止条件</p>
<pre><code class="language-python">#东哥模板
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
</code></pre>
<pre><code class="language-c++">//卡哥模板
void backtrack(参数){
    if(终止条件){
        存放结果;
        return;
    }
    
    for(选择:本层集合中的元素){
        处理节点;
        backtrack(路径，选择);
        回溯,撤销结果;
    }
}
</code></pre>
<p>回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作:</p>
<pre><code class="language-python">def backtrack(...):
    for 选择 in 选择列表:
        做选择
        backtrack(...)
        撤销选择
</code></pre>
<p><strong>写 <code>backtrack</code> 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集</strong>。</p>
<p>回溯法中的参数不是一次性就可以完全确定下来，一般先写逻辑，需要什么参数就可以填写什么参数。</p>
<hr>
<p>无论是排列、组合还是子集问题，简单说无非就是让你从序列 <code>nums</code> 中以给定规则取若干元素，主要有以下几种变体：</p>
<p><strong>形式一、元素无重不可复选，即 <code>nums</code> 中的元素都是唯一的，每个元素最多只能被使用一次，这也是最基本的形式</strong>。</p>
<p>以组合为例，如果输入 <code>nums = [2,3,6,7]</code>，和为 7 的组合应该只有 <code>[7]</code>。</p>
<pre><code class="language-c++">/* 组合/子集问题回溯算法框架 */
void backtrack(int[] nums, int start) {
    // 回溯算法标准框架
    for (int i = start; i &lt; nums.length; i++) {
        // 做选择
        track.addLast(nums[i]);
        // 注意参数
        backtrack(nums, i + 1);
        // 撤销选择
        track.removeLast();
    }
}

/* 排列问题回溯算法框架 */
void backtrack(int[] nums) {
    for (int i = 0; i &lt; nums.length; i++) {
        // 剪枝逻辑
        if (used[i]) {
            continue;
        }
        // 做选择
        used[i] = true;
        track.addLast(nums[i]);

        backtrack(nums);
        // 撤销选择
        track.removeLast();
        used[i] = false;
    }
}
</code></pre>
<p><strong>形式二、元素可重不可复选，即 <code>nums</code> 中的元素可以存在重复，每个元素最多只能被使用一次</strong>。</p>
<p>以组合为例，如果输入 <code>nums = [2,5,2,1,2]</code>，和为 7 的组合应该有两种 <code>[2,2,2,1]</code> 和 <code>[5,2]</code>。</p>
<pre><code class="language-c++">Arrays.sort(nums);
/* 组合/子集问题回溯算法框架 */
void backtrack(int[] nums, int start) {
    // 回溯算法标准框架
    for (int i = start; i &lt; nums.length; i++) {
        // 剪枝逻辑，跳过值相同的相邻树枝
        if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) {
            continue;
        }
        // 做选择
        track.addLast(nums[i]);
        // 注意参数
        backtrack(nums, i + 1);
        // 撤销选择
        track.removeLast();
    }
}


Arrays.sort(nums);
/* 排列问题回溯算法框架 */
void backtrack(int[] nums) {
    for (int i = 0; i &lt; nums.length; i++) {
        // 剪枝逻辑
        if (used[i]) {
            continue;
        }
        // 剪枝逻辑，固定相同的元素在排列中的相对位置
        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) {
            continue;
        }
        // 做选择
        used[i] = true;
        track.addLast(nums[i]);

        backtrack(nums);
        // 撤销选择
        track.removeLast();
        used[i] = false;
    }
}
</code></pre>
<p><strong>形式三、元素无重可复选，即 <code>nums</code> 中的元素都是唯一的，每个元素可以被使用若干次</strong>。</p>
<p>上面用组合问题举的例子，但排列、组合、子集问题都可以有这三种基本形式，所以共有 9 种变化。</p>
<p>除此之外，题目也可以再添加各种限制条件，比如让你求和为 <code>target</code> 且元素个数为 <code>k</code> 的组合，那这么一来又可以衍生出一堆变体，怪不得面试笔试中经常考到排列组合这种基本题型。</p>
<pre><code class="language-c++">/* 组合/子集问题回溯算法框架 */
void backtrack(int[] nums, int start) {
    // 回溯算法标准框架
    for (int i = start; i &lt; nums.length; i++) {
        // 做选择
        track.addLast(nums[i]);
        // 注意参数
        backtrack(nums, i);
        // 撤销选择
        track.removeLast();
    }
}


/* 排列问题回溯算法框架 */
void backtrack(int[] nums) {
    for (int i = 0; i &lt; nums.length; i++) {
        // 做选择
        track.addLast(nums[i]);
        backtrack(nums);
        // 撤销选择
        track.removeLast();
    }
}
</code></pre>
<p><strong>但无论形式怎么变化，其本质就是穷举所有解，而这些解呈现树形结构，所以合理使用回溯算法框架，稍改代码框架即可把这些问题一网打尽</strong>。</p>
<h3 id="排列问题">排列问题</h3>
<p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p>
<pre><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;int&gt; path;
    void backtrack(vector&lt;int&gt;&amp; nums,vector&lt;bool&gt;&amp; used){
        //此时找到说明找到了一组
        if(path.size() == nums.size()){
            res.push_back(path);
            return;
        }
        for(int i = 0;i &lt; nums.size();i++){
            if(used[i] == true) continue;//说明path中已经收集到了该元素
            used[i] = true;
            path.push_back(nums[i]);
            backtrack(nums,used);
            path.pop_back();
            used[i] = false;
        }
    }
    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) {
        res.clear();
        path.clear();
        vector&lt;bool&gt; used(nums.size(),false);
        backtrack(nums,used);
        return res;

    }
};

</code></pre>
<p>216.组合总数||</p>
<p>找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：</p>
<p>只使用数字1到9，每个数字 最多使用一次<br>
返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。</p>
<pre><code class="language-c++">class Solution {
private:
    //设置二维结果数组与路劲数组
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;int&gt; path;
    void backtrack(int tarSum,int k,int sum,int startIndex){
        //此时找到了一组
        if(path.size() == k){
            if(sum == tarSum) res.push_back(path);
            return;
        }
        //单层递归的逻辑
        for(int i = startIndex;i &lt;= 9;i++){
            sum += i;
            path.push_back(i);
            //注意参数的取值是i+1，调整下一层递归的startIndex
            backtrack(tarSum,k,sum,i + 1);
            sum -= i;//回溯
            path.pop_back();//回溯
        }
    }

public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) {
        res.clear();
        path.clear();
        backtrack(n,k,0,1);
        return res;

    }
};
</code></pre>
<h3 id="组合总和">组合总和</h3>
<p>39：</p>
<p>给你一个 <strong>无重复元素</strong> 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。</p>
<p>candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。</p>
<p>对于给定的输入，保证和为 target 的不同组合数少于 150个。</p>
<pre><code class="language-c++">class Solution {
private:
    //定义全局变量存放结果
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;int&gt; path;
    void backtrack(vector&lt;int&gt;&amp; candidates,int target,int sum,int startIndex){
        if(sum &gt; target){
            return;
        }
        if(sum == target){
            res.push_back(path);
            return;
        }
        for(int i = startIndex;i &lt;candidates.size();i++){
            sum += candidates[i];
            path.push_back(candidates[i]);
            //不需要i+1，表示可以从自身开始取
            backtrack(candidates,target,sum,i);
            sum -= candidates[i];
            path.pop_back();
            
        }
    }

public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {
        path.clear();
        res.clear();
        backtrack(candidates,target,0,0);
        return res;

    }
};
</code></pre>
<p>40：</p>
<p>给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用 一次 。</p>
<p>注意：解集不能包含重复的组合。</p>
<p>注意本题与前一题的主要区别在于，本题中的candidates中存在重复的元素，在回溯过程中，同一层的遍历要注意避免重复元素的使用。</p>
<p>增加了used数组来判断重复元素的使用次数，从而避免重复元素的使用情况。</p>
<pre><code class="language-c++">class Solution {
private:
    //定义全局变量
    //本题的区别在于，candidates中存在重复元素，要想办法进行去重
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;int&gt; path;
    void backtrack(vector&lt;int&gt;&amp; candidates, int target,int sum,int startIndex,vector&lt;bool&gt;&amp; used){
        if(sum &gt; target){
            return;
        }
        if(sum == target){
            res.push_back(path);
            return;
        }
        for(int i = startIndex;i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target;i++){
            if(i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; used[i - 1] == false){
                continue;
            }
            sum += candidates[i];
            path.push_back(candidates[i]);
            used[i] = true;
            backtrack(candidates,target,sum,i + 1,used);
            used[i] = false;
            sum -= candidates[i];
            path.pop_back();
        }
    }

public:
    vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) {
        vector&lt;bool&gt; used(candidates.size(),false);
        path.clear();
        res.clear();
        sort(candidates.begin(),candidates.end());
        backtrack(candidates,target,0,0,used);
        return res;

    }
};
</code></pre>
<h3 id="子集问题">子集问题</h3>
<p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p>
<p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p>
<pre><code class="language-c++">class Solution {
private:
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;int&gt; path;
    void backtrack(vector&lt;int&gt;&amp; nums,int startIndex){
        res.push_back(path);//收集子集要放在终止条件上面否则会漏掉
        if(startIndex &gt;= nums.size()){
            return;
        }
        for(int i = startIndex;i &lt; nums.size();i++){
            path.push_back(nums[i]);
            backtrack(nums,i + 1);
            path.pop_back();
        }
    }

public:
    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) {
        path.clear();
        res.clear();
        backtrack(nums,0);
        return res;

    }
};
</code></pre>
<p>num中存在可重复元素时的情况时同样采用used数组进行重复避免。</p>
<p><strong>换句话说，我们通过保证元素之间的相对顺序不变来防止出现重复的子集</strong>。</p>
<p>含有重复元素时一定要注意在最后主函数中<strong>先对题给集合先进行排序</strong>。</p>
<pre><code class="language-c++">class Solution {
private:
    vector&lt;vector&lt;int&gt;&gt; res;
    vector&lt;int&gt; path;
    void backtrack(vector&lt;int&gt;&amp; nums,int startIndex,vector&lt;bool&gt;&amp; used){
        res.push_back(path);
        if(startIndex &gt;= nums.size()){
            return;
        }
        for(int i = startIndex;i &lt; nums.size();i++){
            if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == false){
                continue;
            }
            path.push_back(nums[i]);
            used[i] = true;
            backtrack(nums,i + 1,used);
            used[i] = false;
            path.pop_back();
        }
    }
public:
    vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) {
        vector&lt;bool&gt; used(nums.size(),false);
        res.clear();
        path.clear();
        //去重要排序
        sort(nums.begin(),nums.end());
        backtrack(nums, 0, used);
        return res;
    }
};
</code></pre>
<h3 id="n皇后"><a href="https://leetcode.cn/problems/n-queens">N皇后</a></h3>
<p>按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。</p>
<p>n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p>
<p>给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。</p>
<p>每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。</p>
<h2 id="贪心算法">贪心算法</h2>
<h2 id="动态规划">动态规划</h2>
<p>动态规划的核心设计思想是数学归纳法，相信大家对数学归纳法都不陌生，高中就学过，而且思路很简单。比如我们想证明一个数学结论，那么<strong>我们先假设这个结论在 <code>k &lt; n</code> 时成立，然后根据这个假设，想办法推导证明出 <code>k = n</code> 的时候此结论也成立</strong>。如果能够证明出来，那么就说明这个结论对于 <code>k</code> 等于任何数都成立。</p>
<p>类似的，我们设计动态规划算法，不是需要一个 dp 数组吗？我们可以假设 <code>dp[0...i-1]</code> 都已经被算出来了，然后问自己：怎么通过这些结果算出 <code>dp[i]</code>？这也是标准的动态规划中的逆序解法。</p>
<p>首先要定义清楚 dp 数组的含义，即 <code>dp[i]</code> 的值到底代表着什么？</p>
<h3 id="动态规划基础">动态规划基础</h3>
<p>-&gt;利用子问题的最优解去求解全局最优解;善于利用二位表寻找思路。</p>
<p><strong>动态规划问题的一般形式就是求最值</strong>，动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多。既然是要求最值，核心问题是什么呢？<strong>求解动态规划的核心问题是穷举</strong>。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。但是，穷举所有可行解其实并不是一件容易的事，需要你熟练掌握递归思维，只有列出<strong>正确的「状态转移方程」</strong>，才能正确地穷举。因此，写出状态转移方程的一般思路是：</p>
<p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 <code>dp</code> 数组/函数的含义</strong>。</p>
<p>在**明确「选择」<strong>的思考是就体现出来</strong>“树”**的影子，可以画出树形结构来辅助思考最优解的路径</p>
<p>针对每道题应该有的思考：</p>
<ol>
<li>
<p><strong>确定dp数组以及下标的含义</strong><br>
dp[i]的定义为：第i个数的斐波那契数值是dp[i]</p>
</li>
<li>
<p><strong>确定递推公式</strong><br>
为什么这是⼀道⾮常简单的⼊⻔题⽬呢？<br>
因为题⽬已经把递推公式直接给我们了：状态转移⽅程 dp[i] = dp[i - 1] + dp[i - 2];</p>
</li>
<li>
<p><strong>dp数组如何初始化</strong></p>
<p>对于前提所需元素如何进行赋值；例如爬楼梯与斐波那契数列中dp[0]与dp[1]的赋值</p>
</li>
<li>
<p><strong>确定遍历顺序</strong><br>
从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序<br>
⼀定是从前到后遍历的</p>
</li>
<li>
<p><strong>举例推导dp数组</strong></p>
</li>
</ol>
<h4 id="动态规划书写框架">动态规划书写框架</h4>
<p>1.确定base case</p>
<p>2.穷举所有结果</p>
<p>3.状态转移</p>
<p>摆脱编程的黑盒状态：题目在于精；需要注意：每道题中<strong>dp[]数组及其下标的含义</strong>、<strong>递推公式</strong>、<strong>dp数组如何初始化</strong>、<strong>遍历顺序</strong>、<strong>打印dp数组</strong>。</p>
<p>动态规划的难点本来就在于寻找<strong>正确的状态转移方程</strong>，设计动态规划的通用技巧：<strong>数学归纳思想</strong>。</p>
<pre><code class="language-python"># 自顶向下递归的动态规划
def dp(状态1, 状态2, ...):
    for 选择 in 所有可能的选择:
        # 此时的状态已经因为做了选择而改变
        result = 求最值(result, dp(状态1, 状态2, ...))
    return result

# 自底向上迭代的动态规划
# 初始化 base case
dp[0][0][...] = base case
# 进行状态转移
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 求最值(选择1，选择2...)
</code></pre>
<h4 id="斐波那契数列">斐波那契数列</h4>
<p>斐波那契数列这道题⽬是⾮常基础的题⽬，通常⽤ F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后⾯的每⼀项<br>
数字都是前⾯两项数字的和。</p>
<pre><code class="language-c++">class Solution {
public:
	int fib(int N) {
		if (N &lt;= 1) return N;
		vector&lt;int&gt; dp(N + 1);
		dp[0] = 0;
		dp[1] = 1;
		for (int i = 2; i &lt;= N; i++) {
			dp[i] = dp[i - 1] + dp[i - 2];
		}
		return dp[N];
	}
};
</code></pre>
<p>-&gt;时间复杂度：O(n)<br>
-&gt;空间复杂度：O(n)</p>
<p>改进：</p>
<pre><code class="language-c++">class Solution {
public:
	int fib(int N) {
	if (N &lt;= 1) return N;
	int dp[2];
	dp[0] = 0;
	dp[1] = 1;
	for (int i = 2; i &lt;= N; i++) {
		int sum = dp[0] + dp[1];
		dp[0] = dp[1];
		dp[1] = sum;
	}
	return dp[1];
	}
};
</code></pre>
<p>-&gt;时间复杂度：O(n)<br>
-&gt;空间复杂度：O(1)</p>
<h4 id="爬楼梯">爬楼梯</h4>
<p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</p>
<p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
<ol>
<li>确定dp数组以及下标的含义</li>
</ol>
<p>dp[i]： <strong>爬到第i层楼梯，有dp[i]种方法</strong></p>
<pre><code>2.确定递推公式
</code></pre>
<p>如果可以推出dp[i]呢？</p>
<p>从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。</p>
<p>首先是<strong>dp[i - 1]</strong>，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。</p>
<p>还有就是<strong>dp[i - 2]</strong>，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。</p>
<p>那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！</p>
<p>所以dp[i] = dp[i - 1] + dp[i - 2] 。</p>
<p>在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。</p>
<p>这体现出确定dp数组以及下标的含义的重要性！</p>
<pre><code>3.dp数组如何初始化
</code></pre>
<p>在回顾一下dp[i]的定义：爬到第i层楼梯，有dp[i]中方法。</p>
<p>那么i为0，dp[i]应该是多少呢，这个可以有很多解释，但都基本是直接奔着答案去解释的。</p>
<p>例如强行安慰自己爬到第0层，也有一种方法，什么都不做也就是一种方法即：dp[0] = 1，相当于直接站在楼顶。</p>
<p>但总有点牵强的成分。</p>
<p>那还这么理解呢：我就认为跑到第0层，方法就是0啊，一步只能走一个台阶或者两个台阶，然而楼层是0，直接站楼顶上了，就是不用方法，dp[0]就应该是0.</p>
<p><strong>其实这么争论下去没有意义，大部分解释说dp[0]应该为1的理由其实是因为dp[0]=1的话在递推的过程中i从2开始遍历本题就能过，然后就往结果上靠去解释dp[0] = 1</strong>。</p>
<p>从dp数组定义的角度上来说，dp[0] = 0 也能说得通。</p>
<p>需要注意的是：题目中说了n是一个正整数，题目根本就没说n有为0的情况。</p>
<p>所以本题其实就不应该讨论dp[0]的初始化！</p>
<p>我相信dp[1] = 1，dp[2] = 2，这个初始化大家应该都没有争议的。</p>
<p>所以我的原则是：不考虑dp[0]如果初始化，只初始化dp[1] = 1，dp[2] = 2，然后从i = 3开始递推，这样才符合dp[i]的定义。</p>
<pre><code>4.确定遍历顺序
</code></pre>
<p>从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的</p>
<pre><code>5.举例推导dp数组
</code></pre>
<pre><code class="language-c++">class Solution {
public:
    int climbStairs(int n) {
        //1.dp[i]含义：达到第i阶台阶的方法数量为dp[i]
        //2.确定递推公式dp[i] = dp[i-1] + dp[i-2]
        //3.初始化:dp[0] = 1/0;dp[1] = 1,dp[2] = 2
        if(n &lt;= 1) return n;
        //vector&lt;int&gt; dp(n + 1);
        int dp[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for(int i = 3;i &lt;= n;i++){
            dp[i] = dp[i-1] + dp[i-2];
        }
        return dp[n];


    }
};
</code></pre>
<p>空间复杂度优化</p>
<pre><code class="language-c++">class Solution {
public:
    int climbStairs(int n) {
        if (n &lt;= 1) return n;
        int dp[3];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i &lt;= n; i++) {
            int sum = dp[1] + dp[2];
            dp[1] = dp[2];
            dp[2] = sum;
        }
        return dp[2];
    }
};
</code></pre>
<h4 id="使用最小花费爬楼梯">使用最小花费爬楼梯</h4>
<p>数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。</p>
<p>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。</p>
<p>请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。</p>
<p><strong>每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯</strong>.</p>
<p><strong>dp[i]的定义：到达第i个台阶所花费的最少体力为dp[i]</strong>。dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];<strong>注意这里为什么是加cost[i]，而不是cost[i-1],cost[i-2]之类的</strong>，因为题目中说了：每当你爬上一个阶梯你都要花费对应的体力值.</p>
<pre><code class="language-c++">class Solution {
public:
    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) {
        vector&lt;int&gt; dp(cost.size());
        dp[0] = cost[0];
        dp[1] = cost[1];
        for (int i = 2; i &lt; cost.size(); i++) {
            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
        }
        // 注意最后一步可以理解为不用花费，所以取倒数第一步，第二步的最少值
        return min(dp[cost.size() - 1], dp[cost.size() - 2]);
    }
};
</code></pre>
<p>优化空间复杂度</p>
<pre><code class="language-c++">class Solution {
public:
    int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) {
        int dp0 = cost[0];
        int dp1 = cost[1];
        for (int i = 2; i &lt; cost.size(); i++) {
            int dpi = min(dp0, dp1) + cost[i];
            dp0 = dp1; // 记录一下前两位
            dp1 = dpi;
        }
        return min(dp0, dp1);
    }
};
</code></pre>
<h4 id="两种思路">两种思路</h4>
<p><strong>第一种思路模板是一个一维的 <code>dp</code> 数组</strong></p>
<pre><code class="language-Python">int n = array.length;
int[] dp = new int[n];

for (int i = 1; i &lt; n; i++) {
    for (int j = 0; j &lt; i; j++) {
        dp[i] = 最值(dp[i], dp[j] + ...)
    }
}
</code></pre>
<p>比如我们写过的 <a href="https://labuladong.github.io/article/fname.html?fname=%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%EF%BC%9A%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97">最长递增子序列</a> 和 <a href="https://labuladong.github.io/article/fname.html?fname=%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84">最大子数组和</a> 都是这个思路。</p>
<p>在这个思路中 <code>dp</code> 数组的定义是：</p>
<p><strong>在子数组 <code>arr[0..i]</code> 中，我们要求的子序列（最长递增子序列）的长度是 <code>dp[i]</code></strong>。</p>
<pre><code class="language-c++">class Solution {
public:
    int lengthOfLIS(vector&lt;int&gt;&amp; nums) {
        //定义dp数组并初始化
        vector&lt;int&gt; dp(nums.size(),1);
        //以nums[i]结尾的子序列长度
        for(int i = 0;i &lt; nums.size();i++){
            for(int j = 0;j &lt; i;j++){
                if(nums[i] &gt; nums[j]){
                    dp[i] = max(dp[i],dp[j]+1);
                }
                
            }
        }
        //寻找dp数组中的最大值
        int res = 0;
        for(int j = 0;j &lt; dp.size();j++){
            res = max(res,dp[j]);
            
        }
        return res; 
    }
};
</code></pre>
<p><strong>第二种思路模板是一个二维的 <code>dp</code> 数组</strong></p>
<pre><code class="language-python">int n = arr.length;
int[][] dp = new dp[n][n];

for (int i = 0; i &lt; n; i++) {
    for (int j = 0; j &lt; n; j++) {
        if (arr[i] == arr[j]) 
            dp[i][j] = dp[i][j] + ...
        else
            dp[i][j] = 最值(...)
    }
}
</code></pre>
<p>-&gt;<strong>涉及两个字符串/数组的场景</strong>，<code>dp</code> 数组的定义如下：</p>
<p><strong>在子数组 <code>arr1[0..i]</code> 和子数组 <code>arr2[0..j]</code> 中，我们要求的子序列长度为 <code>dp[i][j]</code></strong>。</p>
<p>-&gt;<strong>只涉及一个字符串/数组的场景</strong>，<code>dp</code> 数组的定义如下：</p>
<p><strong>在子数组 <code>array[i..j]</code> 中，我们要求的子序列的长度为 <code>dp[i][j]</code></strong>。</p>
<blockquote>
<p>未完待续......</p>
</blockquote>

                        </div>
                        
                            <div class="post-toc">
                                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#c%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E7%AB%9E%E8%B5%9B%E7%9B%B8%E5%85%B3">C++基础语法-&gt;竞赛相关</a>
<ul>
<li><a href="#c%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">C++中的数据类型</a></li>
</ul>
</li>
<li><a href="#%E7%BB%AA%E8%AE%BA%E4%B8%8E%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5">绪论与基础概念</a></li>
<li><a href="#%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%94%E5%A4%A7%E7%89%B9%E6%80%A7">算法的五大特性</a></li>
<li><a href="#%E7%AE%97%E6%B3%95%E4%B8%8E%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6">算法与时空复杂度</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E6%B8%90%E8%BF%9B%E5%A2%9E%E9%95%BF">函数的渐进增长</a></li>
<li><a href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AE%A1%E7%AE%97">时间复杂度计算</a>
<ul>
<li><a href="#%E4%B8%80%E5%B1%82%E5%BE%AA%E7%8E%AF">一层循环</a></li>
<li><a href="#%E4%B8%A4%E5%B1%82%E5%BE%AA%E7%8E%AF">两层循环</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84%E7%9A%84%E5%A4%8D%E7%9B%98%E4%B8%8E%E5%BC%BA%E5%8C%96">基础结构的复盘与强化</a>
<ul>
<li><a href="#%E5%8D%95%E9%93%BE%E8%A1%A8">单链表</a></li>
<li><a href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97">栈和队列</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a></li>
</ul>
</li>
<li><a href="#%E6%80%9D%E8%80%83">思考</a>
<ul>
<li><a href="#%E5%8F%82%E8%80%83%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E7%9A%84%E8%BD%AC%E6%8D%A2">参考二叉树的后序遍历，如何利用栈实现递归与非递归的转换？</a></li>
</ul>
</li>
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7%E5%9C%A8%E9%93%BE%E8%A1%A8%E4%B8%8E%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E8%BF%90%E7%94%A8">双指针技巧在链表与数组中的运用</a>
<ul>
<li><a href="#array~%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7">Array~快慢指针技巧</a>
<ul>
<li><a href="#%E6%95%B0%E7%BB%84%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0">数组移除元素</a></li>
<li><a href="#%E7%A7%BB%E9%99%A4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0">移除数组中的重复元素</a></li>
<li><a href="#%E5%8E%BB%E9%87%8D%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BB%A3%E7%A0%81%E5%9D%97"><strong>去重的核心代码块</strong></a></li>
</ul>
</li>
<li><a href="#array~%E5%B7%A6%E5%8F%B3%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7">Array~左右指针技巧</a>
<ul>
<li><a href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95">二分查找算法</a>
<ul>
<li><a href="#%E5%AF%BB%E6%89%BE%E4%B8%80%E4%B8%AA%E6%95%B0">寻找一个数</a></li>
<li><a href="#%E5%AF%BB%E6%89%BE%E5%B7%A6%E4%BE%A7%E8%BE%B9%E7%95%8C">寻找左侧边界</a></li>
<li><a href="#%E5%AF%BB%E6%89%BE%E5%8F%B3%E4%BE%A7%E8%BE%B9%E7%95%8C">寻找右侧边界</a></li>
</ul>
</li>
<li><a href="#%E5%8F%8D%E8%BD%AC%E7%B3%BB%E5%88%97%E4%B8%8E%E5%9B%9E%E6%96%87">反转系列与回文</a>
<ul>
<li><a href="#%E8%BF%AD%E4%BB%A3%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8">迭代反转单链表</a></li>
<li><a href="#%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC%E5%8D%95%E9%93%BE%E8%A1%A8">递归反转单链表</a></li>
<li><a href="#%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8">回文链表</a></li>
<li><a href="#%E5%8F%8D%E8%BD%AC%E6%95%B4%E6%95%B0"><strong>反转整数</strong></a></li>
<li><a href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2"><strong>最长回文字符串</strong></a></li>
<li><a href="#%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2">反转字符串</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#linked-list~%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7">Linked List~双指针技巧</a>
<ul>
<li><a href="#%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8-%E5%85%85%E5%88%86%E6%8E%8C%E6%8F%A1">设计链表-充分掌握</a></li>
<li><a href="#%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8">合并两个有序链表</a></li>
<li><a href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E8%A7%A3">链表的分解</a></li>
<li><a href="#%E5%AF%BB%E6%89%BE%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E7%82%B9">寻找单链表的中点</a></li>
<li><a href="#%E5%AF%BB%E6%89%BE%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-k-%E4%B8%AA%E8%8A%82%E7%82%B9">寻找单链表的倒数第 <code>k</code> 个节点</a></li>
<li><a href="#%E5%88%A4%E6%96%AD%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E7%8E%AF%E5%B9%B6%E6%89%BE%E5%87%BA%E7%8E%AF%E8%B5%B7%E7%82%B9">判断单链表是否包含环并找出环起点</a></li>
<li><a href="#%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BA%A4%E5%B9%B6%E6%89%BE%E5%87%BA%E4%BA%A4%E7%82%B9">判断两个单链表是否相交并找出交点</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3">滑动窗口</a><br>
*
<ul>
<li><a href="#%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E5%AD%90%E6%95%B0%E7%BB%84">长度最小子数组</a></li>
<li><a href="#%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2">无重复字符的最长子串</a></li>
<li><a href="#%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8Ek%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84">乘积小于K的子数组</a></li>
<li><a href="#%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0">最大连续1的个数</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91-2">二叉树</a>
<ul>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91-%E7%BA%B2%E9%A2%86%E7%AF%87">二叉树-纲领篇</a>
<ul>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6">二叉树的最大深度</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6">二叉树最小深度</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86">二叉树的遍历</a>
<ul>
<li><a href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86">前序遍历</a></li>
<li><a href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86">中序遍历</a></li>
<li><a href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86">后序遍历</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9B%B4%E5%BE%84">二叉树的最大直径</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">二叉树的层序遍历</a>
<ul>
<li><a href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86">层序遍历</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE">二叉树的右视图</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E6%AF%8F%E5%B1%82%E8%8A%82%E7%82%B9%E7%9A%84%E5%B9%B3%E5%9D%87%E6%95%B0">计算二叉树每层节点的平均数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91-%E6%80%9D%E8%B7%AF%E7%AF%87">二叉树-思路篇</a>
<ul>
<li><a href="#%E5%8F%8D%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91">反转二叉树</a></li>
<li><a href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91">对称二叉树</a></li>
<li><a href="#%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88">填充每个节点的下一个右侧节点指针</a></li>
<li><a href="#%E5%B0%86%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8">将二叉树展开为链表</a></li>
<li><a href="#%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C">左叶子之和</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91-%E6%9E%84%E9%80%A0%E7%AF%87">二叉树-构造篇</a>
<ul>
<li><a href="#%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91">最大二叉树</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91">通过前序和中序遍历结果构造二叉树</a></li>
<li><a href="#%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91">从中序与后序遍历序列构造二叉树</a></li>
<li><a href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0">完全二叉树节点个数</a></li>
<li><a href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91">平衡二叉树</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%B7%AF%E5%BE%84">二叉树的路径</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%87%8F%E6%9E%9D">二叉树减枝</a></li>
<li><a href="#%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91-2">最大二叉树</a></li>
<li><a href="#%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91">合并二叉树</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%90%8E%E5%BA%8F%E7%AF%87">二叉树-后序篇</a>
<ul>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E7%9B%B4%E5%BE%84-2">二叉树的最大直径</a></li>
<li><a href="#%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84">最长同值路径</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C">二叉树中最大路径和</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">二叉搜索树</a>
<ul>
<li><a href="#%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E5%AF%BB%E6%89%BE%E8%8A%82%E7%82%B9">在二叉搜索树中寻找节点</a></li>
<li><a href="#%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91">验证二叉搜索树</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE">二叉搜索树的最小绝对差</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E4%BC%97%E6%95%B0">二叉搜索树中的众数</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88">二叉树/搜索树的最近公共祖先</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95">图论算法</a><br>
*
<ul>
<li><a href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9E%E7%8E%B0">图的基本数据结构的实现</a></li>
</ul>
</li>
<li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93">结构体</a><br>
*
<ul>
<li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8">初始化列表</a></li>
<li><a href="#bfs%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">BFS广度优先搜索</a></li>
<li><a href="#dfs%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2">DFS深度优先搜索</a>
<ul>
<li><a href="#dps%E7%AE%97%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%88%86%E6%9E%90">DPS算法的设计分析</a></li>
<li><a href="#dfs%E7%AE%97%E6%B3%95%E4%B8%8E%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B3%E7%B3%BB">DFS算法与回溯算法的关系</a></li>
<li><a href="#dfs%E7%AE%97%E6%B3%95%E4%B9%A6%E5%86%99%E7%9A%84%E6%A8%A1%E6%9D%BF%E5%A5%97%E8%B7%AF">DFS算法书写的模板套路</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95">回溯算法</a>
<ul>
<li><a href="#%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98">排列问题</a></li>
<li><a href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C">组合总和</a></li>
<li><a href="#%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98">子集问题</a></li>
<li><a href="#n%E7%9A%87%E5%90%8E">N皇后</a></li>
</ul>
</li>
<li><a href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95">贪心算法</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a>
<ul>
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80">动态规划基础</a>
<ul>
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B9%A6%E5%86%99%E6%A1%86%E6%9E%B6">动态规划书写框架</a></li>
<li><a href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">斐波那契数列</a></li>
<li><a href="#%E7%88%AC%E6%A5%BC%E6%A2%AF">爬楼梯</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF">使用最小花费爬楼梯</a></li>
<li><a href="#%E4%B8%A4%E7%A7%8D%E6%80%9D%E8%B7%AF">两种思路</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

                            </div>
                            
                                
                                    
                                        <!--en-->
                                        <section class="post-copyright en">
                                            <p class="copyright-item">
                                                <span>Author:</span>
                                                <span>Mungeryang写字的地方</span>
                                            </p>

                                            <p class="copyright-item">
                                                <span>Permalink:</span>
                                                <span><a href="https://Mungeryang.github.io/post/shu-ju-jie-gou/">https://Mungeryang.github.io/post/shu-ju-jie-gou/</a></span>
                                            </p>

                                            <p class="copyright-item">
                                                <span>License:</span>
                                                <span>MIT License</span>
                                            </p>
                                        </section>
                                        
                                                
                                                    
                                                        <!-- Share-->
                                                        <span style="margin-right:15px">
                                                    <i class="post-share"></i>
                                                    <span>Share:</span>
                                                        <a title="QR Code" target="_blank" href="https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=https://Mungeryang.github.io/post/shu-ju-jie-gou/"><i class="fa fa-qrcode"></i></a>
                                                        <a title="QQ" target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://Mungeryang.github.io/post/shu-ju-jie-gou/&sharesource=qzone&title=数据结构与算法学习笔记&pics=https://Mungeryang.github.io/images/avatar.png?v=1696728951294&summary="><i class="fa fa-qq"></i></a>
                                                        <a title="Weibo" target="_blank" href="https://service.weibo.com/share/share.php?url=https://Mungeryang.github.io/post/shu-ju-jie-gou/&sharesource=weibo&title=数据结构与算法学习笔记 + " - " + &pic="https://Mungeryang.github.io/images/avatar.png?v=1696728951294 "><i class="fa fa-weibo "></i></a>
                                                        
                                                                </span>
                                                                <!--en-->
                                                                <section class="post-tags en ">
                                                                    <div>
                                                                        <span>Tag(s):</span>
                                                                        <span class="tag ">
                        
                        
                        <a href="https://Mungeryang.github.io/tag/tech/">#
                                                技术文集
                                                    </a>
                                                    
                                                        
                                                            </span>
                                                                    </div>
                                                                    <div>
                                                                        <a href="javascript:window.history.back();">back</a>
                                                                        <span>&dot;</span>
                                                                        <a href="#">home</a>
                                                                    </div>
                                                                </section>
                                                                
                                                                                <!---->
                                                                                <section class="post-nav">
                                                                                    
                                                                                        <a class="prev" rel="prev" href="https://Mungeryang.github.io/post/2023-shu-jia/">
                                                                                            2023暑假留校闭关修炼|书单与知识结构图
                                                                                        </a>
                                                                                        
                                                                                            
                                                                                                <a class="next" rel="next" href="https://Mungeryang.github.io/post/ren-zheng-fei-wen-ji-one/">
                                                                                                    任正非文集|我的父亲母亲
                                                                                                </a>
                                                                                                
                                                                                </section>
                    </article>
                </div>
                
                                            
            </div>
    </div>
    </div>
    </div>
    
        <footer id="footer" class="footer">
            <div class="copyright">
                
                    <div class="Like">
                        <div class="tip" data-tooltip="Do you like it?">
                            <a href="https://github.com/ITJoker233/Gridea-theme-Chic" target="_blank" title=""><svg class="icon"
                        aria-hidden="true">
                        <use xlink:href="#like"></use>
                    </svg><b class="like_text" id="star"></b></a>
                        </div>
                    </div>
                    
                        Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
                            
                                <b id="hitokoto"></b><br>
                                
                                        <svg viewBox="0 0 1024 1024" style="margin-left: 5px;margin-right: 5px;" version="1.0" width="8" height="8" class="my-face">
            <path
                d="M863.597631 513.574282l-271.33965-140.213484L729.783667 81.926656c3.583731-7.87141 7.167462-15.742819 7.167462-25.214109C736.887134 25.226908 708.345275 0.012799 672.635953 0.012799a63.611229 63.611229 0 0 0-39.293053 12.607055c-1.791866 1.59988-3.519736 3.19976-5.311602 3.19976L147.87531 418.925381a55.547834 55.547834 0 0 0-19.646527 47.356448c1.791866 17.278704 14.27093 33.021523 32.125591 42.492813l271.33965 141.749369L292.504463 945.221908c-12.479064 25.214109-1.791866 53.563983 23.166262 69.306802 10.751194 6.335525 23.230258 9.47129 35.709322 9.47129 16.062795 0 32.125591-4.735645 44.604655-15.742819l480.091993-403.297753a55.547834 55.547834 0 0 0 19.646526-47.228458 61.243407 61.243407 0 0 0-32.12559-44.156688z"
                fill="#93b5cf"></path>
        </svg>
                                        Mungeryang写字的地方 &copy;Copyright
                                            <script>
                                                var date = new Date();
                                                document.write("" + date.getFullYear());
                                            </script>
                                            | Powered by
                                            <a href="https://github.com/Mungeryang" target="_blank">
                                                Munger
                                            </a>
            </div>
            <div id="update" style="display:none;">
                on
            </div>
            
                <div id="version" style="display:none;">
                    1.7.6
                </div>
                
                    <script>
                        var port = '';
                        
                        document.write('<div id="home_path" style="display:none;">' + document.location.protocol + '//' + window.document.location.hostname + port + '</div>')
                    </script>
        </footer>
        
            <script src='https://fastly.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js'></script>
            
                <script>
                    
                    
                    loadlive2d();
                    
                    
                    hitokoto();
                    
                    getStar();
                    hljs.initHighlighting();
                    console.clear();
                    
                    CheckVersion();
                    
                    var newDate = new Date();
                    newDate.setTime(1696728951294);
                    console.log(" Blog Update Time: " + newDate.toLocaleDateString());
                    console.log("\n %c \u26a1Theme:Chic Author's Blog:https://blog.itjoker.cn  Write By ITJoker  \n\n", "color: #ffffff; background: rgba(49, 49, 49, 0.85); padding:5px 0;border-radius:5px;");
                </script>
        </div>
</body>
<script>
    scroll();
</script>

</html>