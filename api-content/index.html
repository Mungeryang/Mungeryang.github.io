{"posts":[{"title":"å‰è·¯æ¼«æ¼«äº¦ç¿ç¿","content":" 2023å¹´9æœˆ29æ—¥ï¼Œä¸‹åˆ14:50ï¼Œæ•…äº‹å¼€å§‹äº†æ–°çš„ç¯‡ç« ã€‚ ä»2023å¹´2æœˆ15æ—¥ç¦»å®¶è¿”æ ¡ï¼Œä¸€ç›´åˆ°10æœˆ1å·ï¼Œæ•´æ•´228å¤©ï¼Œå®¶é—¨æœªè¸å…¥ä¸€æ­¥ã€‚ä¸€ç›´æƒ³å¸¦ä¸€ä¸ªå¥½çš„ç»“æœå›å®¶ï¼Œç»å†ç£•ç£•ç»Šç»Šï¼Œæœ€ç»ˆå¦‚æ„¿ä»¥å¿ã€‚ æƒ³è¯´çš„ä¸œè¥¿ï¼Œæƒ³è¡¨è¾¾çš„ä¸œè¥¿æœ‰å¥½å¤šï¼Œä½†å´éš¾ä»¥å¯é½¿ã€æ— ä»ä¸‹ç¬”ã€‚ å›é¦–è¿™æ®µå²æœˆï¼Œæ„Ÿè°¢è‡ªå·±æ²¡æœ‰æ”¾å¼ƒè‡ªå·±ï¼Œæ„Ÿè°¢æš‘å‡ç•™æ ¡è¸è¸å®å®è¯»ä¹¦å­¦ä¹ çš„æ²‰æ·€ã€‚æš‘å‡ç•™æ ¡ä¸¤ä¸ªæœˆï¼Œè‡ªå·±åœ¨å›¾ä¹¦é¦†äº”æ¥¼é çª—æˆ·å äº†ä¸€æ•´å¼ æ¡Œå­ï¼Œäº”æ¥¼äººçƒŸç¨€å°‘ï¼Œå…«æœˆä»½å®‰å®‰é™é™åœ¨é‚£é‡Œåº¦è¿‡äº†ä¸€ä¸ªæœˆå……å®çš„æ—¶å…‰ã€‚æ—©ä¸Šå…«ç‚¹åŠå¼€é¦†å‡†æ—¶åˆ°è¾¾ï¼Œæ™šä¸Šå†æ¼†é»‘çš„äº”æ¥¼å†™è¯»ä¹¦ç¬”è®°ï¼Œå¦‚ä»Šå†è¿›å…¥äº”æ¥¼ï¼Œå¾€äº‹å†å†å¦‚è¿‡çœ¼äº‘çƒŸèˆ¬æµ®ç°åœ¨çœ¼å‰ã€‚ä¸Šä¸€æ¬¡æœ‰è¿™ç§æ„Ÿè§‰ï¼Œè¿˜æ˜¯å› ä¸º19å¹´åº•å£ç½©äº‹æƒ…é«˜ä¸‰å¼€å­¦å»¶æœŸï¼Œ20å¹´åˆå±…å®¶å¤ä¹ çš„å²æœˆã€‚è¿™ä¸¤æ®µæ—¶å…‰äº¤ç»‡åœ¨ä¸€èµ·ï¼Œç»™æˆ‘çš„åæ€å°±æ˜¯ï¼Œè¦æƒ³åšæˆä¸€ä»¶äº‹æƒ…ï¼Œé¦–å…ˆè¦æŠŠè‡ªå·±è°ƒæ•´æˆé™éŸ³æ¨¡å¼ï¼Œè¸è¸å®å®å¿˜æˆ‘èˆ¬çš„æŠ•å…¥è¿›å»ã€‚æƒ³æˆäº‹ï¼Œä¸æ˜¯æ¯å¤©ç‚¸ç‚¸å‘¼å‘¼ï¼Œä¸€å¤©å…«æ¡æœ‹å‹åœˆï¼Œæ¨ä¸èƒ½åˆ«äººä¸çŸ¥é“æˆ‘å¹²å•¥ã€‚è€Œæ˜¯è¦æ²‰æ·€ã€è¦å®‰é™ã€è¦å¿è€ã€è¦åšæŒã€‚ äººæ€§çš„å¼±ç‚¹ä¹‹ä¸€å°±æ˜¯åªçœ‹ç»“æœï¼Œä¸æ³¨é‡è¿‡ç¨‹ã€‚ä½ è€ƒä¸Šç ”äº†ï¼Œè€ƒä¸Šå…¬äº†ï¼Œå‘¨å›´éƒ½æ˜¯æ¬¢å‘¼ã€èµç¾ä¹‹è¯ã€‚&quot;ç‰›é€¼ã€å¤§ä½¬ã€äº¤ç»™æœ‹å‹å§...&quot;è¯¸å¦‚æ­¤ç±»çš„è¯ï¼Œä¼šè®©ä½ æ²‰è¿·äº«å—ï¼Œä¼šè®©ä½ é£˜é£˜ç„¶å¿˜ä¹æ‰€ä»¥ã€‚ä½†æ˜¯ï¼Œå½“ä½ æ²¡è€ƒä¸Šï¼Œå‘¨å›´ä¾¿æ˜¯è®¥è®½ã€å˜²ç¬‘ä¸ç»äºè€³ã€‚&quot;ä»–ä¸è¡Œï¼Œä»–å…‰ç©ï¼Œä»–å°±ä¸æ˜¯é‚£å—æ–™...&quot;ã€‚æ‰€ä»¥ï¼Œè‡ªå¼ºä¸æ¯ã€åšå¾·è½½ç‰©ï¼Œæ°¸è¿œéƒ½æ˜¯æ³•å®ï¼Œè®©è‡ªå·±å¼ºå¤§èµ·æ¥ï¼Œè®©è‡ªå·±å†…å¿ƒå¼ºå¤§èµ·æ¥ï¼Œæ‰ä¼šåœ¨é¢å¯¹è¿™äº›æƒ…å†µçš„æ—¶å€™ï¼Œåšåˆ°å¤šä¸€ä»½çš„ä»å®¹ã€æ·¡å®šä¸å¦ç„¶ã€‚ å¸¦ç€å¥½ç»“æœå›å®¶è¿‡èŠ‚ï¼Œå®¶äººä»¬ç”±è¡·åœ°ä¸ºæˆ‘æ„Ÿåˆ°é«˜å…´ã€è‡ªè±ªã€‚æ„Ÿè°¢å®¶äººï¼Œæ²¡æœ‰å®¶äººçš„ç†è§£ä¸æ”¯æŒï¼Œæˆ‘æ²¡æœ‰å‹‡æ°”èµ°å¥½ä»Šå¤©çš„è·¯ã€‚ æˆ‘çš„çˆ¶äº²æ¨æµ·é¾™ï¼Œ1976å¹´å‡ºç”Ÿäºæ²³åŒ—çœæ²§å·å¸‚ä¸€ä¸ªè´«ç©·çš„æ™®é€šå®¶åº­ã€‚å°æ—¶å€™å­¦ä¹ æˆç»©ä¸é”™ï¼Œå‡­å€Ÿè‡ªå·±çš„åŠªåŠ›ä¸€ç›´è¯»åˆ°äº†é«˜ä¸­æ¯•ä¸šã€‚ä¸­è€ƒæˆç»©å¾ˆå¥½ï¼Œä½†æ˜¯å› ä¸ºå®¶é‡Œç©·è¦ç»§ç»­ä¾›ç»™æˆ‘äºŒå”ã€ä¸‰å”è¯»ä¹¦ã€‚äºæ˜¯ï¼Œçˆ¶äº²æ”¾å¼ƒäº†å»å¿é‡Œè¯»é«˜ä¸­çš„æœºä¼šï¼Œé€‰æ‹©äº†åœ¨é•‡ä¸Šå®Œæˆå­¦ä¸šï¼Œå¾ˆå¤šå¹´å‰ï¼Œä»–ä»ç„¶è‡ªå˜²:â€œä»¥æˆ‘å½“å¹´çš„æˆç»©ï¼Œè¦æ˜¯å»å¿é‡Œä¸Šï¼Œè€ƒè¿‡æ²³åŒ—å·¥ä¸šç»°ç»°æœ‰ä½™â€ã€‚é«˜ä¸­æ¯•ä¸šååœ¨æˆ‘äºŒçˆ·å®¶å·¥å‚é‡Œå·¥ä½œï¼Œç„¶åå’Œçˆ·çˆ·ã€å”å”ä»¬åˆ›ä¸šã€‚ æˆ‘çš„æ¯äº²åˆ˜ç§‹èŠï¼Œ1978å¹´å‡ºç”Ÿäºæ²³åŒ—çœæ²§å·å¸‚ä¸€ä¸ªè´«ç©·çš„æ™®é€šå®¶åº­ã€‚å°çš„æ—¶å€™å­¦ä¹ æˆç»©ä¸€èˆ¬ï¼Œè‚¯å®šæ²¡æœ‰æˆ‘çˆ¶äº²å­¦ä¹ å¥½ï¼Œæƒ³è€ƒä¸­ä¸“ï¼Œç»“æœä¹Ÿæ˜¯ä¸ºäº†å¼Ÿå¼Ÿå¦¹å¦¹çš„å­¦ä¸šè€Œæ”¾å¼ƒäº†è‡ªå·±çš„æ¢¦æƒ³ã€‚åˆä¸­æ¯•ä¸šåè¿›å…¥å†œæ‘ä¿¡ç”¨ç¤¾å½“ä¼šè®¡ï¼Œåæ¥åœ¨æˆ‘å§¥çˆ·çš„å‚å­é‡Œå½“ä¼šè®¡ï¼Œä¸€å¹²å°±æ˜¯åŠè¾ˆå­ã€‚æ¯äº²æ˜¯ä¸€ä¸ªèªæ˜çš„äººï¼Œç§¯æã€é˜³å…‰ã€çƒ­çˆ±å­¦ä¹ ï¼Œå¥¹ç®—è´¦ã€ç®—æ•°æ²¡å‡ºè¿‡é”™ï¼Œçˆ±å†™è¯»ä¹¦ç¬”è®°ï¼Œæœ‰é˜…è¯»ä¹ æƒ¯ï¼Œè¿™äº›éƒ½æ¶¦ç‰©ç»†æ— å£°èˆ¬å½±å“ç€æˆ‘ã€‚ ä¸¤ä¸ªæœ‰ç€ç›¸åŒå‘½è¿è·¯å¾„çš„äººèµ°åˆ°äº†ä¸€èµ·ï¼Œå…»è‚²äº†æˆ‘ã€åŸ¹å…»äº†æˆ‘ã€‚ç‰¹åˆ«æ˜¯ï¼Œä»Šå¹´å› ä¸ºé¢è¯•å¿™äºå„ä¸ªåŸå¸‚å¥”æ³¢ï¼ŒæŠ¥è¾…å¯¼æœºæ„ï¼Œå‘paperã€‚ä»¥ä¸Šç§ç§ï¼Œå½“æˆ‘éœ€è¦é’±çš„æ—¶å€™ï¼Œè€çˆ¶äº²æ€»æ˜¯é‚£ä¹ˆæ–©é’‰æˆªé“ç»™æˆ‘è½¬å¥½å¤šé’±ï¼Œè®©æˆ‘æ²¡æœ‰ä»»ä½•é¡¾è™‘ã€‚é’±æ˜¯å¥½ä¸œè¥¿ï¼Œé’±æ˜¯å¹²å‡€çš„ï¼Œè„çš„æ˜¯äººå¿ƒã€‚èµ°æ­£é“ï¼Œå¥½å¥½èµšé’±ã€å¤šèµšé’±æ°¸è¿œéƒ½æ˜¯å¹¸ç¦çš„ã€‚ è¿™äº›å¹´ï¼ŒäºŒå”çš„å»ä¸–ä¸€ç›´ä¹Ÿæ˜¯æˆ‘å‰è¿›çš„åŠ¨åŠ›ã€‚æˆ‘å¾ˆå°‘å’Œå¤–äººå»è°ˆæˆ‘äºŒå”å› ä¸ºè½¦ç¥¸å»ä¸–çš„äº‹æƒ…ï¼Œæˆ‘è®¤ä¸ºè¿™æ˜¯å®¶æ—ä¹‹æ®‡ã€‚æˆ‘ä½œä¸ºå®¶æ—ä¸­çš„é•¿å­é•¿å­™ï¼Œåœ¨æˆ‘17å²é‚£å¹´ï¼Œä»–çš„æ­»ï¼Œä½¿æˆ‘å¯¹æˆ‘çš„å®¶åº­ã€å¯¹æˆ‘è‡ªå·±æœ‰äº†æ–°çš„ç†è§£ã€‚æŒ«æŠ˜éƒ½æ˜¯å‘äººæ·±çœçš„ï¼Œæˆ‘åº†å¹¸è‡ªå·±æ²¡æœ‰è¢«ç”Ÿæ´»çš„é‡åˆ›æ‰“å®ï¼Œæˆ‘ä¹Ÿåº†å¹¸ï¼Œå®¶é‡Œçš„è€äººæ²¡æœ‰å› ä¸ºç”Ÿæ´»çš„è‹¦éš¾è€Œä½¿ä»–ä»¬ä¸§å¤±å¯¹ç”Ÿæ´»çš„å¸Œæœ›ã€‚åœ¨ç»å†è‹¦éš¾ä¹‹åï¼Œæˆ‘çœ‹åˆ°çš„ä¾ç„¶æ˜¯ä»–ä»¬ç§¯æçš„ç”Ÿæ´»æ€åº¦ï¼Œæ²¡æœ‰æ€¨å¤©å°¤äººã€æ²¡æœ‰ä¸€è¹¶ä¸æŒ¯ï¼Œæ°¸è¿œéƒ½ç»™å­å¥³æ ‘ç«‹äº†å¥½çš„æ¦œæ ·ã€‚å…¶å®ï¼Œè¿™å°±æ˜¯æˆ‘é‡åˆ°æ— æ•°å›°éš¾åï¼Œä¾ç„¶æœ‰å‹‡æ°”é¢å¯¹çš„åº•æ°”æ¥æºã€‚ ä»Šå¹´è¿˜è¦æ„Ÿè°¢å¼ å®‡(å®‡çˆ¹)ï¼Œä¸ç¡®å®šçš„æ—¥å­é‡Œä¸€ç›´åœ¨é€šè¿‡å¤‡è€ƒé«˜æ•°èˆ’ç¼“ã€‚æ¿€å‘äº†æˆ‘å¯¹æ•°å­¦çš„çƒ­æƒ…ï¼Œé‡å¡‘äº†å­¦ç§‘çš„ç†è§£ã€‚ ä¸‹ä¸€ä¸ªé˜¶æ®µè¦åšçš„ä»»åŠ¡ï¼š 1.å›å»ä»¥åä¸è¦æ‡ˆæ€ ï¼Œå¯ä»¥é€‚å½“ä¼‘æ¯ï¼Œä½†æ˜¯ä¸è¦æŒ¥éœã€ä¸è¦æµªè´¹ã€‚åšæŒé”»ç‚¼ï¼Œä¿æŠ¤èº«ä½“ï¼Œå°‘ç†¬å¤œï¼Œè‡ªå¾‹èµ·æ¥ã€‚ 2.åˆ—ä¸€ä¸ªä¹¦å•ï¼Œå¤šè¯»ç‚¹ä¹¦ã€‚ 3.ä¸“ä¸šæŠ€æœ¯çŸ¥è¯†å¤ä¹ ï¼Œä»£ç å¤šæ•²ã€‚ 4.åœ¨ç ”ç©¶é¢†åŸŸæ·±è€•çªç ´ï¼Œçºµå‘çªç ´æå‡ï¼Œè€ƒå‡ ä¸ªè¯ä¹¦ã€‚ 5.å¦‚æœæœ‰æœºä¼šå»å®ä¹ ï¼ 6.é‡è§†è‹±è¯­ã€æ•°å­¦çš„å­¦ä¹ ã€‚ æ²¡æœ‰è½»èˆŸå·²è¿‡ä¸‡é‡å±±ï¼Œå”¯æœ‰å‰è·¯æ¼«æ¼«äº¦ç¿ç¿ã€‚ ","link":"https://Mungeryang.github.io/post/qian-lu-man-man-yi-can-can/"},{"title":"å¼ å®‡|é«˜ç­‰æ•°å­¦é—­å…³ä¿®ç‚¼Â·18è®²æ±‡æ€»","content":" å¤šå¤šé‡å¤ï¼Œç™¾ç‚¼æˆé’¢ é”™è¯¯æ˜¯é‡‘å­ï¼Œä¸çº æ˜¯å‚»å­ã€‚å­¦æ•°å­¦çº¯ç²¹ç‚¹ï¼Œåˆ«é‚£ä¹ˆå¥½é¢å­ æ¨æ¡‚æ·¼1^{1}1,åˆ˜è´º2^{2}2 [1]æ¨æ¡‚æ·¼ï¼šHebei University,Information Management and Information Systems [2]åˆ˜è´ºï¼šQingdao Institute of Technology,Computer Science and Technology *ä»¥ä¸‹å…¬å¼çš†ä¸ºå®‡å“¥ä¸Šè¯¾æ—¶å¼ºè°ƒçš„â€œè€ƒå‰è®°ä¸€è®°-å–å‰æ‘‡ä¸€æ‘‡â€å…¬å¼ï¼Œè¿™äº›å…¬å¼æˆ–å‡½æ•°æˆ–ç®—æ³•å¹³æ—¶ä¸ä¾¿äºè€ƒç”Ÿè®°å¿†è€Œä¸”è€ƒé¢‘ç›¸å¯¹è¾ƒä½(ä½†æ˜¯ä¸ä»£è¡¨ä¸è€ƒ)ï¼Œæ‰€ä»¥é€¢è€ƒå‰ï¼Œå¿…é¡»è®¤çœŸç†Ÿæ‚‰ä¸€éã€‚é™¤ä»¥ä¸‹ç‰¹æ®Šå…¬å¼å¤–ï¼Œå…¶ä½™å„ç§å…¬å¼ã€å„ä¸ªåŸºæœ¬å‡½æ•°åŠå…¶å›¾åƒæ€§è´¨éƒ½å¿…é¡»ç†Ÿx(ç¨”)äºå¿ƒï¼Œå€’èƒŒå¦‚æµ,æ–¹å¯ç™»å³°é€ æï¼Œè¡Œäº‘æµæ°´ã€ä»¤äººæ‹æ¡ˆï¼â¤ï¸ æåæ ‡ä¸‹ä½ æ€»æ˜¯è®°ä¸ç†Ÿçš„å‡½æ•°åŠå›¾åƒ ç¬›å¡å°”å¿ƒå½¢çº¿ï¼š r=a(1âˆ’cosâ¡Î¸)r = a(1 - \\cos\\theta) r=a(1âˆ’cosÎ¸) x{r=Î±(1+cosâ¡Î¸),å‘å³r=Î±(1âˆ’cosâ¡Î¸),å‘å·¦r=Î±(1+sinâ¡Î¸),å‘ä¸Šr=Î±(1âˆ’sinâ¡Î¸),å‘ä¸‹ x\\begin{cases}r= \\alpha(1+\\cos \\theta),&amp;\\text{å‘å³}\\\\r= \\alpha(1-\\cos \\theta),&amp;\\text{å‘å·¦}\\\\r= \\alpha(1+\\sin \\theta),&amp;\\text{å‘ä¸Š}\\\\r= \\alpha(1-\\sin \\theta),&amp;\\text{å‘ä¸‹}\\end{cases} xâ©âªâªâªâ¨âªâªâªâ§â€‹r=Î±(1+cosÎ¸),r=Î±(1âˆ’cosÎ¸),r=Î±(1+sinÎ¸),r=Î±(1âˆ’sinÎ¸),â€‹å‘å³å‘å·¦å‘ä¸Šå‘ä¸‹â€‹ ã€é»˜å†™åŒºã€‘ ç«ç‘°çº¿ï¼š r=asinâ¡(nÎ¸)r = a\\sin(n \\theta) r=asin(nÎ¸) ã€é»˜å†™åŒºã€‘ é˜¿åŸºç±³å¾·èºçº¿ï¼š r=aÎ¸r = a\\theta r=aÎ¸ ã€é»˜å†™åŒºã€‘ ä¼¯åŠªåˆ©åŒçº½çº¿ï¼š r=a2sinâ¡(2Î¸)r=a^2 \\sin(2\\theta) r=a2sin(2Î¸) ã€é»˜å†™åŒºã€‘ æ‘†çº¿çš„å‚æ•°æ–¹ç¨‹ï¼š x=râ‹…(Î¸âˆ’sinâ¡Î¸) y=râ‹…(1âˆ’cosâ¡Î¸) x = r \\cdot (\\theta - \\sin \\theta) \\\\ y = r \\cdot (1 - \\cos \\theta) x=râ‹…(Î¸âˆ’sinÎ¸) y=râ‹…(1âˆ’cosÎ¸) ã€é»˜å†™åŒºã€‘ æ˜Ÿè¡Œçº¿çš„å‚æ•°æ–¹ç¨‹ï¼š x=aâ‹…cosâ¡3(t)y=aâ‹…sinâ¡3(t)x = a \\cdot \\cos^3(t) \\\\ y = a \\cdot \\sin^3(t) x=aâ‹…cos3(t)y=aâ‹…sin3(t) ã€é»˜å†™åŒºã€‘ ååŒæ›²æ­£å¼¦ï¼šy=ln(x+x2+1)y = ln(x + \\sqrt{x^2 + 1})y=ln(x+x2+1â€‹) ã€é»˜å†™åŒºã€‘ åŒæ›²æ­£å¼¦ï¼šy=exâˆ’eâˆ’x2y = \\frac{e^x - e^{-x}}{2}y=2exâˆ’eâˆ’xâ€‹ ã€é»˜å†™åŒºã€‘ åŒæ›²ä½™å¼¦(æ‚¬é“¾çº¿)ï¼šy=ex+eâˆ’x2y = \\frac{e^x + e^{-x}}{2}y=2ex+eâˆ’xâ€‹ ã€é»˜å†™åŒºã€‘ å¦å¤– y=xxy=x^xy=xx ä¸ y=x1xy=x^{\\frac{1}{x}}y=xx1â€‹ è€ƒç”Ÿä¹Ÿéœ€ç‰¢è®°å‡½æ•°å›¾åƒåŠæ€§è´¨ å¼ºåŒ–é˜¶æ®µè¦æ±‚æ–°æŒæ¡çš„å‡½æ•°ã€æ•°åˆ—æé™ f(x)=(1+x)1xf\\left( x \\right) =\\left( 1+x \\right) ^{\\frac{1}{x}} f(x)=(1+x)x1â€‹ f(x)å•è°ƒå‡å°‘ limâ¡xâ†’0+f(x)=e\\underset{x\\rightarrow 0^+}{\\lim}f\\left( x \\right) =exâ†’0+limâ€‹f(x)=e (1+x)1xâˆ’eâˆ¼âˆ’e2x(xâ†’0+)\\left( 1+x \\right) ^{\\frac{1}{x}}-e\\sim -\\frac{e}{2}x\\left( x\\rightarrow 0^+ \\right)(1+x)x1â€‹âˆ’eâˆ¼âˆ’2eâ€‹x(xâ†’0+) xn=(1+1n)nx_n=\\left( 1+\\frac{1}{n} \\right) ^n xnâ€‹=(1+n1â€‹)n xnx_nxnâ€‹å•è°ƒå¢åŠ  limâ¡nâ†’âˆxn=e\\underset{n\\rightarrow \\infty}{\\lim}x_n=enâ†’âˆlimâ€‹xnâ€‹=e (1+1n)nâˆ’eâˆ¼âˆ’e21n\\left( 1+\\frac{1}{n} \\right) ^n-e\\sim -\\frac{e}{2}\\frac{1}{n}(1+n1â€‹)nâˆ’eâˆ¼âˆ’2eâ€‹n1â€‹ æœ€è£…é€¼çš„è„±å¸½ã€å¸¦å¸½æ³•â€”â€”æ”¾å¿ƒæ²¡æœ‰å¾ˆå¤šäººä¼šçµæ´»è¿ç”¨ï¼Œä½†ä½ å¯ä»¥ï¼ è„±å¸½æ³•ï¼š limâ¡xâ†’â‹…f(x)&gt;(&lt;)0âŸ¹f(x)&gt;(&lt;)0\\underset{x\\rightarrow Â·}{\\lim}f\\left( x \\right) \\underset{\\left( &lt; \\right)}{&gt;}0\\Longrightarrow f\\left( x \\right) \\underset{\\left( &lt; \\right)}{&gt;}0 xâ†’â‹…limâ€‹f(x)(&lt;)&gt;â€‹0âŸ¹f(x)(&lt;)&gt;â€‹0 ã€é»˜å†™åŒºã€‘ å¸¦å¸½æ³•ï¼š f(x)â©¾(â©½)0âŸ¹limâ¡xâ†’â‹…f(x)â©¾(â©½)0f\\left( x \\right) \\underset{\\left( \\leqslant \\right)}{\\geqslant}0\\Longrightarrow \\underset{x\\rightarrow Â·}{\\lim}f\\left( x \\right) \\underset{\\left( \\leqslant \\right)}{\\geqslant}0 f(x)(â©½)â©¾â€‹0âŸ¹xâ†’â‹…limâ€‹f(x)(â©½)â©¾â€‹0 ã€é»˜å†™åŒºã€‘ ç«çœ¼é‡‘ç›ï¼Œdo you know? âˆ«âˆ’âˆ0eâˆ’tdt=1\\int_{- \\infty}^{0} e^{-t}dt = 1âˆ«âˆ’âˆ0â€‹eâˆ’tdt=1 é«˜æ–¯æ›²çº¿ï¼šâˆ«0+âˆeâˆ’x2dx\\int_{0}^{+ \\infty} e^{-x^2}dxâˆ«0+âˆâ€‹eâˆ’x2dx=Ï€2\\frac{\\sqrt Ï€}{2}2Ï€â€‹â€‹ âˆ«0xx2âˆ’t2dx=14Ï€x2(å‡ ä½•æ„ä¹‰)\\int_{0}^{x} \\sqrt{x^2 - t^2}dx = \\frac{1}{4}Ï€x^2(å‡ ä½•æ„ä¹‰)âˆ«0xâ€‹x2âˆ’t2â€‹dx=41â€‹Ï€x2(å‡ ä½•æ„ä¹‰) è€ƒç ”æ•°å­¦ä¸­å¯¹ç»å¯¹å€¼å¤„ç†ä½ ç†Ÿç»ƒå—ï¼Ÿâ€”â€”ç­”ï¼šä¸ç†Ÿç»ƒã€‚ç«‹å³æ¨ï¼šå¤ä¹ åˆ°4ç‚¹ï¼ å»ç»å¯¹å€¼å°±æ„å‘³ç€è¦åˆ†æƒ…å†µè®¨è®ºã€‚ æ”¾ç¼©æ³• å‹ç¼©æ˜ å°„ ç»å¯¹å€¼æ±‚æé™ ç»å¯¹å€¼æ±‚å¯¼æ•°(åˆ†æ®µ) ç»å¯¹å€¼æ±‚ç§¯åˆ† ç»å¯¹å€¼è¯æ˜é¢˜ç»¼åˆ æ°¸è¿œç”¨ä¸ç†Ÿç»ƒçš„ä¸ç­‰å¼ âˆ£aÂ±bâˆ£â©½âˆ£aâˆ£+âˆ£bâˆ£âˆ£âˆ£aâˆ£âˆ’âˆ£bâˆ£âˆ£â©½âˆ£aâˆ’bâˆ£âˆ£âˆ«abf(x)dxâˆ£â©½âˆ«abâˆ£f(x)âˆ£dxâˆ£abâˆ£â©½a2+b22âˆ£a1Â±a2Â±â‹…â‹…â‹…Â±anâˆ£â©½âˆ£a1âˆ£+âˆ£a2âˆ£+â‹…â‹…â‹…+âˆ£anâˆ£|a\\pm b|\\leqslant |a|+|b| \\\\ ||a|-|b||\\leqslant |a-b| \\\\ |\\int{_{a}^{b}f\\left( x \\right) dx}|\\leqslant \\int{_{a}^{b}|f\\left( x \\right) |dx} \\\\ |ab|\\leqslant \\frac{a^2+b^2}{2} \\\\ |a_1\\pm a_2\\pm Â·Â·Â·\\pm a_n|\\leqslant |a_1|+|a_2|+Â·Â·Â·+|a_n| âˆ£aÂ±bâˆ£â©½âˆ£aâˆ£+âˆ£bâˆ£âˆ£âˆ£aâˆ£âˆ’âˆ£bâˆ£âˆ£â©½âˆ£aâˆ’bâˆ£âˆ£âˆ«abâ€‹f(x)dxâˆ£â©½âˆ«abâ€‹âˆ£f(x)âˆ£dxâˆ£abâˆ£â©½2a2+b2â€‹âˆ£a1â€‹Â±a2â€‹Â±â‹…â‹…â‹…Â±anâ€‹âˆ£â©½âˆ£a1â€‹âˆ£+âˆ£a2â€‹âˆ£+â‹…â‹…â‹…+âˆ£anâ€‹âˆ£ ã€é»˜å†™åŒºã€‘ å¸¦ç»å¯¹å€¼çš„æé™ limâ¡xâ†’â‹…âˆ£f(x)âˆ£=0âŸºlimâ¡xâ†’â‹…f(x)=0\\underset{x\\rightarrow Â·}{\\lim}|f\\left( x \\right) |=0\\Longleftrightarrow \\underset{x\\rightarrow Â·}{\\lim}f\\left( x \\right) =0 xâ†’â‹…limâ€‹âˆ£f(x)âˆ£=0âŸºxâ†’â‹…limâ€‹f(x)=0 ã€é»˜å†™åŒºã€‘ ä¸€ä¸ªç‰¹æ®Šçš„æ±‚å¯¼å…¬å¼(è§†ç»å¯¹å€¼è€Œä¸è§) (lnâ¡âˆ£xâˆ£)â€²=1x\\left( \\ln |x| \\right)&#x27; =\\frac{1}{x} (lnâˆ£xâˆ£)â€²=x1â€‹ ã€é»˜å†™åŒºã€‘ æ¶å¿ƒçš„è¿ç»­ä¸é—´æ–­ è¯·è®¨è®ºä¸€ä¸‹å‡½æ•°ç¬¬ä¸€ç±»é—´æ–­ç‚¹çš„ä¸ªæ•° f(x)=(x2âˆ’x)âˆ£x+1âˆ£e1xâˆ«1ttâˆ£sinâ¡tâˆ£dtf\\left( x \\right) =\\frac{\\left( x^2-x \\right) |x+1|}{e^{\\frac{1}{x}}\\int{_{1}^{t}t|\\sin t|dt}} f(x)=ex1â€‹âˆ«1tâ€‹tâˆ£sintâˆ£dt(x2âˆ’x)âˆ£x+1âˆ£â€‹ ä½œç­”åŒºï¼š è‹¥f(x0)f(x_0)f(x0â€‹)åœ¨ x0x_0x0â€‹ å¤„å¯å¯¼ï¼Œå½“f(x0)=0f(x_0)=0f(x0â€‹)=0ä¸”fâ€™(x0)=0fâ€™(x_0)=0fâ€™(x0â€‹)=0æ—¶ï¼Œâˆ£f(x)âˆ£|f(x)|âˆ£f(x)âˆ£åœ¨x0x_0x0â€‹å¤„å¯å¯¼å—ï¼Ÿ Please prove: æ‹†åˆ†æ±‚å¯¼ä½“ç°åŸºæœ¬åŠŸ å°è¯•ç‰›åˆ€ï¼šf(x)=âˆ«01âˆ£t2âˆ’x2âˆ£dt(x&gt;0)f\\left( x \\right) =\\int{_{0}^{1}|t^2-x^2|dt\\left( x&gt;0 \\right)}f(x)=âˆ«01â€‹âˆ£t2âˆ’x2âˆ£dt(x&gt;0),æ±‚f(x)f(x)f(x)çš„æœ€å°å€¼ ä½œç­”åŒºï¼š[è‡ªå¤‡è‰ç¨¿çº¸] æˆ‘è§‰ç€è¿™ä¸ªå‡½æ•°æ˜¯ä¸€ä¸ªä¸‡é‡‘æ²¹çš„ä¾‹å­(P49) f(x)={x24+x4sinâ¡1x,xâ‰ 00,x=0f\\left( x \\right) =\\begin{cases} \\frac{x^2}{4}+x^4\\sin \\frac{1}{x},x\\ne 0\\\\ 0,x=0\\\\ \\end{cases} f(x)={4x2â€‹+x4sinx1â€‹,xî€ â€‹=00,x=0â€‹ è¯·è‡ªè¡Œæ±‚å‡ºå®ƒçš„ä¸€é˜¶å¯¼å‡½æ•°ã€äºŒé˜¶å¯¼å‡½æ•°ã€‚ æ±‚å¯¼åŒºï¼š ç‰¹åˆ«æ˜¯ï¼Œæ¶‰åŠåˆ°ä¸€äº›æ¦‚å¿µæ€§é—®é¢˜ï¼Œæ¯”å¦‚ä»€ä¹ˆå‡½æ•°è¿ç»­ä¸€é˜¶å¯¼å‡½æ•°æ˜¯å¦è¿ç»­ï¼Œç±»ä¼¼è¿™ç§è®¨è®ºå‡½æ•°ä¸å…¶å¯¼å‡½æ•°çš„è¿ç»­æ€§ä¸å¯å¯¼æ€§é—®é¢˜ï¼Œè¿™ä¸ªä¾‹å­å±¡è¯•ä¸çˆ½ã€‚ ä¸èƒ½è›®å¹²ï¼Œè¦ç”¨å·§åŠ²çš„é«˜é˜¶å¯¼æ•°(p39) å¤§å±•æ‹³è„šï¼šå·²çŸ¥å‡½æ•°f(x)=x21âˆ’x2f(x) = \\frac{x^2}{1 - x^2}f(x)=1âˆ’x2x2â€‹,åˆ™f(x) = ___(n=1,2,3â‹¯ )(n=1,2,3\\cdots)(n=1,2,3â‹¯) æé†’ï¼š(1ax+b)(n)=(âˆ’1)nann!(ax+b)n+1(\\frac{1}{ax+b})^{(n)}=(-1)^n a^n \\frac{n!}{(ax+b)^{n+1}}(ax+b1â€‹)(n)=(âˆ’1)nan(ax+b)n+1n!â€‹ ä½œç­”åŒºï¼š[è‡ªå¤‡è‰ç¨¿çº¸] ä½ æ€»æ˜¯è‡ªä¿¡åœ°è®¤ä¸ºèƒŒçš„å¾ˆç†Ÿä½†æ˜¯ä¸€ä¸‹ç¬”å°±å†™é”™çš„ä½©äºšè¯ºä½™é¡¹ åœ¨è€ƒç ”æ•°å­¦ä¸­ï¼Œå¸¸å¸¸ä½¿ç”¨å¸¦ä½©äºšè¯ºä½™é¡¹çš„æ³°å‹’å±•å¼€å¼æ¥è¿‘ä¼¼å‡½æ•°çš„å€¼ã€‚ å¸¦ä½©äºšè¯ºä½™é¡¹çš„æ³°å‹’å±•å¼€å¼ï¼ˆä¸€é˜¶ï¼‰ï¼š f(x)â‰ˆf(a)+fâ€²(a)(xâˆ’a)+R1(x)f(x) \\approx f(a) + f&#x27;(a)(x - a) + R_1(x) f(x)â‰ˆf(a)+fâ€²(a)(xâˆ’a)+R1â€‹(x) ã€é»˜å†™åŒºã€‘ å…¶ä¸­ï¼Œf(x) æ˜¯è¦è¿‘ä¼¼çš„å‡½æ•°ï¼Œaæ˜¯å±•å¼€ç‚¹ï¼ŒR1(x) æ˜¯å¸¦ä½©äºšè¯ºä½™é¡¹çš„ä¸€é˜¶ä½™é¡¹ï¼Œé€šå¸¸è¡¨ç¤ºä¸ºï¼š f(x)â‰ˆf(a)+fâ€²(a)(xâˆ’a)+fâ€²â€²(a)2!(xâˆ’a)2+R2(x)f(x) \\approx f(a) + f&#x27;(a)(x - a) + \\frac{f&#x27;&#x27;(a)}{2!}(x - a)^2 + R_2(x) f(x)â‰ˆf(a)+fâ€²(a)(xâˆ’a)+2!fâ€²â€²(a)â€‹(xâˆ’a)2+R2â€‹(x) ã€é»˜å†™åŒºã€‘ å…¶ä¸­ï¼Œf(x) æ˜¯è¦è¿‘ä¼¼çš„å‡½æ•°ï¼Œaæ˜¯å±•å¼€ç‚¹ï¼ŒR2(x) æ˜¯å¸¦ä½©äºšè¯ºä½™é¡¹çš„äºŒé˜¶ä½™é¡¹ï¼Œé€šå¸¸è¡¨ç¤ºä¸ºï¼š R2(x)=fâ€²â€²â€²(Î¾)3!(xâˆ’a)3R_2(x) = \\frac{f&#x27;&#x27;&#x27;(\\xi)}{3!}(x - a)^3 R2â€‹(x)=3!fâ€²â€²â€²(Î¾)â€‹(xâˆ’a)3 ã€é»˜å†™åŒºã€‘ æœ€å®¹æ˜“è¢«å†·è½çš„ä¸­å€¼å®šç† äºŒé‡ç§¯åˆ†ä¸­å€¼å®šç†å…¬å¼ âˆ¬f(x,y)dÏƒ=f(Î¾,Î·)Ïƒ\\underset{}{\\iint{f\\left( x,y \\right) d\\sigma =}f\\left( \\xi ,\\eta \\right) \\sigma} âˆ¬f(x,y)dÏƒ=f(Î¾,Î·)Ïƒâ€‹ ã€é»˜å†™åŒºã€‘ æ¨å¹¿çš„ç§¯åˆ†ä¸­å€¼å®šç† âˆ«abf(x)g(x)dx=f(Î¾)âˆ«abg(x)dx\\int{_{a}^{b}f\\left( x \\right) g\\left( x \\right) dx=}f\\left( \\xi \\right) \\int{_{a}^{b}g\\left( x \\right) dx} âˆ«abâ€‹f(x)g(x)dx=f(Î¾)âˆ«abâ€‹g(x)dx ã€é»˜å†™åŒºã€‘ äºŒå…ƒå‡½æ•°ä¸­çš„æ‹‰æ ¼æœ—æ—¥ä¸­å€¼å®šç†(ç±»æ¯”ä¸€å…ƒ) f(x,y)âˆ’f(0,0)=[f(x,y)âˆ’f(0,y)]+[f(0,y)âˆ’f(0,0)]=fâ€²x(Î¾x,y)x+fâ€²y(0,Î·y)y\\quad f(x,y)-f(0,0)=[f(x,y)-f(0,y)]+[f(0,y)-f(0,0)]=f\\prime_x(\\xi_x,y)x+f\\prime_y(0,\\eta_y)yf(x,y)âˆ’f(0,0)=[f(x,y)âˆ’f(0,y)]+[f(0,y)âˆ’f(0,0)]=fâ€²xâ€‹(Î¾xâ€‹,y)x+fâ€²yâ€‹(0,Î·yâ€‹)y å…¶ä¸­,f(0,0)=0,è¯¦è§1000é¢˜P49ç¬¬3é¢˜f(0,0)=0,è¯¦è§1000é¢˜P_{49}ç¬¬3é¢˜f(0,0)=0,è¯¦è§1000é¢˜P49â€‹ç¬¬3é¢˜ ã€é»˜å†™åŒºã€‘ éšä¾¿è½¬çš„æ—‹è½¬ä½“ä½“ç§¯ V=Ï€(A2+B2)32âˆ«ab[Ax+Bf(x)+C]2âˆ£Afâ€²(x)âˆ’Bâˆ£dxV=\\frac{\\pi}{\\left( A^2+B^2 \\right) ^{\\frac{3}{2}}}\\int{_{a}^{b}\\left[ Ax+Bf\\left( x \\right) +C \\right] ^2|Af&#x27;\\left( x \\right) -B|dx} V=(A2+B2)23â€‹Ï€â€‹âˆ«abâ€‹[Ax+Bf(x)+C]2âˆ£Afâ€²(x)âˆ’Bâˆ£dx ç©ºé—´æ›²çº¿L:f(x),aâ©½xâ©½bL:f(x),a\\leqslant x\\leqslant bL:f(x),aâ©½xâ©½bä¸”f(x)å¯å¯¼ å®šç›´çº¿ï¼šL0:Ax+By+C=0L_0:Ax+By+C=0L0â€‹:Ax+By+C=0 ã€é»˜å†™åŒºã€‘ ä¸¤ä¸ªå¾ˆä¸èµ·çœ¼çš„åŒºé—´å†ç°å…¬å¼(P118ã€96) âˆ«0nTxf(x)dx=n2T2âˆ«0Tf(x)dx(n=1,2,3â‹…â‹…â‹…)âˆ«aa+nTf(x)dx=nâˆ«0Tf(x)dx\\int{_{0}^{nT}xf\\left( x \\right) dx=}\\frac{n^2T}{2}\\int{_{0}^{T}f\\left( x \\right) dx}\\left( n=1,2,3Â·Â·Â· \\right) \\\\ \\int{_{a}^{a+nT}f\\left( x \\right) dx=}n\\int{_{0}^{T}f\\left( x \\right) dx} âˆ«0nTâ€‹xf(x)dx=2n2Tâ€‹âˆ«0Tâ€‹f(x)dx(n=1,2,3â‹…â‹…â‹…)âˆ«aa+nTâ€‹f(x)dx=nâˆ«0Tâ€‹f(x)dx ã€é»˜å†™åŒºã€‘ è¿·äººçš„æ•›æ•£æ€§å°ºåº¦ âˆ«011xpdx{0&lt;p&lt;1,convergencep&gt;1,diverge\\int{_{0}^{1}}\\frac{1}{x^p}dx\\begin{cases} 0&lt;p&lt;1,convergence\\\\ p&gt;1,diverge\\\\ \\end{cases} âˆ«01â€‹xp1â€‹dx{0&lt;p&lt;1,convergencep&gt;1,divergeâ€‹ âˆ«01lnâ¡xxpdx\\int{_{0}^{1}}\\frac{\\ln x}{x^p}dxâˆ«01â€‹xplnxâ€‹dxåŒç† ã€é»˜å†™åŒºã€‘ âˆ«1+âˆ1xpdx{pâ©½1,divergep&gt;1,convergence\\int{_{1}^{+\\infty}}\\frac{1}{x^p}dx\\begin{cases} p\\leqslant 1,diverge\\\\ p&gt;1,convergence\\\\ \\end{cases} âˆ«1+âˆâ€‹xp1â€‹dx{pâ©½1,divergep&gt;1,convergenceâ€‹ âˆ«1+âˆlnâ¡xxpdx\\int{_{1}^{+\\infty}}\\frac{\\ln x}{x^p}dxâˆ«1+âˆâ€‹xplnxâ€‹dxåŒç† ã€é»˜å†™åŒºã€‘ æ›²ç‡ä¸æ›²ç‡åŠå¾„(ä»…æ•°ä¸€ã€æ•°äºŒ) æ›²ç‡k=yâ€²â€²[1+(yâ€²)2]32,æ›²ç‡åŠå¾„R=1kk=\\frac{y^{&#x27;&#x27;}}{[1+(y^\\prime)^2]^{\\frac{3}{2}}},æ›²ç‡åŠå¾„R=\\frac{1}{k}k=[1+(yâ€²)2]23â€‹yâ€²â€²â€‹,æ›²ç‡åŠå¾„R=k1â€‹ ã€é»˜å†™åŒºã€‘ ç‚’é¸¡å”¬äººçš„é‡ç§¯åˆ†å…¬å¼(æ•°ä¸€) è½¬åŠ¨æƒ¯é‡ Ix=âˆ­(y2+z2)Ï(x,y,z) dx dy dzIy=âˆ­(x2+z2)Ï(x,y,z) dx dy dzIz=âˆ­(x2+y2)Ï(x,y,z) dx dy dzI_x = \\iiint (y^2 + z^2) \\rho(x, y, z) \\, dx \\, dy \\, dz \\\\ I_y = \\iiint (x^2 + z^2) \\rho(x, y, z) \\, dx \\, dy \\, dz \\\\ I_z = \\iiint (x^2 + y^2) \\rho(x, y, z) \\, dx \\, dy \\, dz Ixâ€‹=âˆ­(y2+z2)Ï(x,y,z)dxdydzIyâ€‹=âˆ­(x2+z2)Ï(x,y,z)dxdydzIzâ€‹=âˆ­(x2+y2)Ï(x,y,z)dxdydz ã€é»˜å†™åŒºã€‘ é‡å¿ƒ(è´¨å¿ƒ)ä¸å½¢å¿ƒ xcm=1Vâˆ­xÏ(x,y,z) dVycm=1Vâˆ­yÏ(x,y,z) dVzcm=1Vâˆ­zÏ(x,y,z) dVx_{\\text{cm}} = \\frac{1}{V} \\iiint x \\rho(x, y, z) \\, dV \\\\ y_{\\text{cm}} = \\frac{1}{V} \\iiint y \\rho(x, y, z) \\, dV \\\\ z_{\\text{cm}} = \\frac{1}{V} \\iiint z \\rho(x, y, z) \\, dV xcmâ€‹=V1â€‹âˆ­xÏ(x,y,z)dVycmâ€‹=V1â€‹âˆ­yÏ(x,y,z)dVzcmâ€‹=V1â€‹âˆ­zÏ(x,y,z)dV ã€é»˜å†™åŒºã€‘ å¼•åŠ› Fx=Gm(xâˆ’x0)2âˆ­(xâˆ’x0)r3Ï(x,y,z) dVFy=Gm(yâˆ’y0)2âˆ­(yâˆ’y0)r3Ï(x,y,z) dVFz=Gm(zâˆ’z0)2âˆ­(zâˆ’z0)r3Ï(x,y,z) dVr=(xâˆ’x0)2+(yâˆ’y0)2+(zâˆ’z0)2F_x = \\frac{G m}{(x - x_0)^2} \\iiint \\frac{(x - x_0)}{r^3} \\rho(x, y, z) \\, dV \\\\ F_y = \\frac{G m}{(y - y_0)^2} \\iiint \\frac{(y - y_0)}{r^3} \\rho(x, y, z) \\, dV \\\\ F_z = \\frac{G m}{(z - z_0)^2} \\iiint \\frac{(z - z_0)}{r^3} \\rho(x, y, z) \\, dV \\\\ r=\\sqrt{\\left( x-x_0 \\right) ^2+\\left( y-y_0 \\right) ^2+\\left( z-z_0 \\right) ^2} Fxâ€‹=(xâˆ’x0â€‹)2Gmâ€‹âˆ­r3(xâˆ’x0â€‹)â€‹Ï(x,y,z)dVFyâ€‹=(yâˆ’y0â€‹)2Gmâ€‹âˆ­r3(yâˆ’y0â€‹)â€‹Ï(x,y,z)dVFzâ€‹=(zâˆ’z0â€‹)2Gmâ€‹âˆ­r3(zâˆ’z0â€‹)â€‹Ï(x,y,z)dVr=(xâˆ’x0â€‹)2+(yâˆ’y0â€‹)2+(zâˆ’z0â€‹)2â€‹ ã€é»˜å†™åŒºã€‘ â€‹ æ²¡æœ‰æ¡ä»¶ï¼Œåˆ›é€ æ¡ä»¶ â€‹ ååå¤å¤æ‰æ‰å®å®ï¼Œå¿µå¿µä¸å¿˜å¿…æœ‰å›å“ â€‹ ã€æ³¨ã€‘ä»¥ä¸Šæ€»ç»“çš†ä¸ºæœ¬äººå¼ºåŒ–é˜¶æ®µå®‡å“¥(çˆ¹)è¯¾ä¸Šå˜±æ‰˜â€è€ƒå‰è®°ä¸€è®°ï¼Œå–å‰æ‘‡ä¸€æ‘‡â€œå†…å®¹ï¼ŒåŠ ä¸Šæˆ‘è‡ªå·±çš„å½’çº³æ€»ç»“ã€‚æ‰€ä»¥ä¾‹å­å…¨æ— ç­”æ¡ˆï¼Œå…¨éƒ¨å‚è€ƒé—­å…³ä¿®ç‚¼é«˜ç­‰æ•°å­¦18è®²å†…å®¹ï¼Œå¦‚æœ‰å›°éš¾ï¼Œè¯·åå¤çœ‹ä¹¦ï¼Œåƒé€æ¯ä¸€é“ç»å…¸ä¾‹é¢˜ï¼ğŸ‘Š æœªå®Œå¾…ç»­â€¦â€¦â€¦ ç†Ÿç¨”äºå¿ƒçš„å…¬å¼æ±‡æ€» â€¦â€¦â€¦ğŸš© ","link":"https://Mungeryang.github.io/post/zhang-yu-orgao-deng-shu-xue-bi-guan-xiu-lian-18-jiang-hui-zong/"},{"title":"2023æš‘å‡ç•™æ ¡é—­å…³ä¿®ç‚¼|ä¹¦å•ä¸çŸ¥è¯†ç»“æ„å›¾","content":"ä¹¦å• ã€Šç¨‹åºæ˜¯æ€ä¹ˆè·‘èµ·æ¥çš„ã€‹â€”â€”çŸ¢æ³½ä¹…é›„ ã€Šç½‘ç»œæ˜¯æ€æ ·è¿æ¥çš„ã€‹â€”â€”æˆ·æ ¹å‹¤ ã€Šè®¡ç®—æœºæ˜¯æ€æ ·è·‘èµ·æ¥çš„ã€‹â€”â€”çŸ¢æ³½ä¹…é›„ ã€Šå›¾è§£äººå·¥æ™ºèƒ½ã€‹â€”â€”å¤šç”°æ™ºå²ã€çŸ³äº•ä¸€å¤« ã€Šå¾æœCæŒ‡é’ˆã€‹â€”â€”å‰æ¡¥å’Œå¼¥ ã€Šå¹²æ³•ã€‹â€”â€”ç¨»ç››å’Œå¤« ã€Šæ•°å­¦ä¹‹ç¾ã€‹â€”â€”å´å†› ã€Šè®¡ç®—æœºç½‘ç»œã€‹â€”â€”è°¢å¸Œä» ã€Šç¬¬äºŒå¤§è„‘ã€‹â€”â€”æ¶‚å­æ²› ã€Šæ¯›æ³½ä¸œé€‰é›†5Â·é™ç«ç‰ˆã€‹â€”â€”æ¯›ä¸»å¸­ã€é™ç« ã€Šæ˜æœé‚£äº›äº‹å„¿1ã€‹â€”â€”å½“å¹´æ˜æœˆ ã€Šé«˜ç­‰æ•°å­¦é—­å…³ä¿®ç‚¼18è®²ã€‹â€”â€”å¼ å®‡ ã€Šé¸¢å°¾èŠ±ä¹‹ä¹¦Â·çº¿æ€§ä»£æ•°ã€‹â€”â€”ç”Ÿå§œ ã€Šä½ è¿˜åœ¨èƒŒå•è¯å—ã€‹â€”â€”åˆ˜æ™“ç‡•(èƒŒäº†1.5é) ã€Šæ–°å©šå¿…è¯»å…¨ä¹¦ã€‹â€”â€”éƒæ™¯å’Œ(åŒ—äº¬åå’Œ) ã€Šåšé»‘å­¦ã€‹â€”â€”æå®—å¾ ã€Šæ”¿æ²»çš„äººç”Ÿã€‹â€”â€”ç‹æ²ªå® ã€Šå¥½å¥½å­¦ä¹ ã€‹â€”â€”æˆç”² ã€Šå¤©æ¶¯ç¥è´´ã€‹â€”â€”æ— åæ° ã€Šè¿ç­¹å­¦ã€‹â€”â€”èƒ¡è¿æƒ çŸ¥è¯†ç»“æ„å›¾ å¥½å¥½å­¦ä¹ -æˆç”² è¿ç­¹å­¦ ç¨‹åºæ˜¯æ€æ ·è·‘èµ·æ¥çš„ æ•°æ®ç»“æ„ è®¡ç®—æœºç½‘ç»œ ","link":"https://Mungeryang.github.io/post/2023-shu-jia/"},{"title":"æ•°æ®ç»“æ„ä¸ç®—æ³•å­¦ä¹ ç¬”è®°","content":" ä½ é™ªäº†æˆ‘å¤šå°‘å¹´ï¼ŒèŠ±å¼€èŠ±è½ï¼Œä¸€è·¯ä¸Šèµ·èµ·è·Œè·Œã€‚â€”â€”æ±Ÿå— å¤©ä¸‹å¤§äº‹ï¼Œå¿…ä½œäºç»†â€”â€”ä¾¯æ· å†™åœ¨å‰é¢ï¼š 2022.06.20æ¼«é•¿çš„æš‘å‡å¼€å§‹äº†ï¼Œæ€»è¦åšäº›ä»€ä¹ˆã€‚åšå•¥ï¼Ÿâ€”â€”å½“ç„¶æ˜¯åšå¥½æœ¬æ‰‹å„¿ï¼ˆ2022å¹´é«˜è€ƒå­¦çš„è¯å“ˆå“ˆ~ï¼‰ ä»˜ä¸œæ¥å¤§å“¥çš„è¿™æœ¬ä¹¦æ˜¯2022.03.26è´­å…¥ï¼Œé‚£æ˜¯å¤§äºŒä¸‹å­¦æœŸçš„å¼€å­¦åä¸ä¹…ã€‚ä¸€ä¸ªå­¦æœŸå›«å›µåæ£çš„çœ‹äº†ä¸€éï¼Œæ²¡æœ‰getåˆ°ç²¾é«“éƒ¨åˆ†ï¼Œä»£ç çœ‹ç€å¾ˆæ˜ç™½ï¼Œè‡ªå·±å†™ç€é”™è¯¯ç™¾å‡ºã€‚äºæ˜¯è®¡åˆ’åˆ©ç”¨å¥½è¿™ä¸ªç¨å¾®æ¼«é•¿çš„æš‘å‡ï¼Œè®¤è®¤çœŸçœŸå­¦å¥½æ•°æ®ç»“æ„ä¸ç®—æ³•ã€‚ è¿™ä»½æ€»ç»“æ˜¯æ¨æ¡‚æ·¼Â©ï¼ˆä½œè€…æœ¬äººï¼‰åŸºäºåŠ›æ‰£å¹³å°çš„é¢˜ç›®ï¼Œå‚è€ƒä»˜ä¸œæ¥å¤§å“¥çš„è§£é¢˜æ€è·¯ç¼–å†™ï¼›ä¸œæ¥å¤§å“¥æ¯é“é¢˜éƒ½ç»™å‡ºäº†åŸºäºJavaçš„è§£é¢˜æ€è·¯ï¼Œä½†æ˜¯ç›®å‰é˜¶æ®µæœ¬äººJavaè¯­è¨€æŒæ¡ä¸€èˆ¬ã€‚äºæ˜¯ä¹ï¼Œå€Ÿé‰´ä¸œæ¥å¤§å“¥çš„æ€è·¯ï¼Œå°†é¢˜ç›®å…¨éƒ¨è¿ç”¨pythonè¯­è¨€å®ç°ã€‚éšç€æœ¬äººçš„ä¸æ–­å­¦ä¹ ç§¯ç´¯ï¼Œå®Œå–„åä»£ç ä¼šå…¨éƒ¨å¼€æºåˆ°æ¨æ¡‚æ·¼çš„GitHubä»“åº“ä¸­ï¼Œå±Šæ—¶ï¼Œæ¬¢è¿å„ä½å¤§ä½¬è¯„é˜…æ–§æ­£ï¼›æ¬¢è¿å„ä½å¿—åŒé“åˆçš„åŒå¿—äº¤æµå­¦ä¹ ï¼ æœ¬äººç§‰æŒä¸œæ¥å¤§å“¥çš„ç†å¿µâ€”â€”è‡´åŠ›äºæŠŠç®—æ³•è®²æ¸…æ¥šï¼ å¼•ç”¨æ•™å‘˜çš„è¯ï¼šä¸‹å®šå†³å¿ƒï¼Œæ’é™¤ä¸‡éš¾ï¼Œäº‰å–å­¦æ˜ç™½ï¼ å†™åœ¨è¿‡ç¨‹ä¸­ï¼š è¡Œç™¾é‡Œè€…åŠä¹å 2022.10æœˆä¸‹æ—¬ä»¥æ¥ï¼Œä¸€è¾¹ä¸ºäº†å°†æ¥è€ƒç ”æ‰“ç®—ï¼Œä¸€è¾¹åœ¨å¤ä¹ Cè¯­è¨€åŸºæœ¬çŸ¥è¯†ç‚¹ã€‚å†³å®šä¸‹å®šå†³å¿ƒæŠŠåŸºæœ¬çš„æ•°æ®ç»“æ„å¤ä¹ æ¸©ä¹ ã€‚å› ä¸ºåœ¨å‰é¢çš„å­¦ä¹ ä¸­æˆ‘ä¸€ç›´ä½¿ç”¨çš„æ˜¯Pythonï¼Œä¹Ÿæ²¡æœ‰å­¦å·Pythonæ•°æ®ç»“æ„ä¸ç®—æ³•ï¼Œæ‰€ä»¥åœ¨åˆ·é¢˜è¿‡ç¨‹ä¸­é‡åˆ°æŠ½è±¡æ•°æ®ç»“æ„ä¸æŒ‡é’ˆï¼Œæˆ‘çš„ç†è§£æ˜¯æœ‰é—®é¢˜çš„ï¼Œè€Œä¸”æœ‰æ—¶å€™æˆ‘æœ¬èº«å°±å¯¹æŸä¸€å¥ç¨‹åºæ ¹æœ¬å°±æ˜¯ä¸ç†è§£ã€‚è¯šå¦‚ç¨‹æ°è€å¸ˆåœ¨å¤§è¯æ•°æ®ç»“æ„ä¸­è¯´æ˜¯ï¼šè®²è§£æ•°æ®ç»“æ„è¿˜çš„ä½¿ç”¨æœ€å¹²å‡€æœ€çº¯ç²¹çš„é€šç”¨è®¡ç®—æœºç»å…¸è¯­è¨€ï¼Œè™½ç„¶Pythonå¾ˆçµåŠ¨ï¼Œæ­£æ˜¯è¿™ç§çµåŠ¨ï¼Œåœ¨è§£ææ•°æ®ç»“æ„çš„æ—¶å€™æ˜¾å¾—ä¸å¤Ÿä¸¥è‚ƒå’Œâ€œæ­£ç»Ÿâ€ï¼Œè€Œç¨‹åºå‘˜çš„åŸºç¡€å¿…ä¿®è¯¾ï¼Œå¿…é¡»ä¸€æ‹³ä¸€è„šçš„å…»æˆè§„èŒƒçš„åŠ¨ä½œä¹ æƒ¯ã€‚ æ‰€ä»¥ï¼Œæˆ‘è§‰ç€è¿™ä¹Ÿæ˜¯æˆ‘èµ°è¿‡çš„å¼¯è·¯ã€‚å½“å‰ä¸»æµçš„ç¼–ç¨‹è¯­è¨€ï¼Œå¯¹äºå­¦ç”Ÿæ¥è¯´ï¼Œæ¥å—ç¨‹åº¦æœ€å¤§çš„æˆ‘è®¤ä¸ºæ— ç–‘æ˜¯Pythonè¯­è¨€ã€‚æˆ‘ä¸€å¼€å§‹æœ€åˆæ‘¸ç´¢çš„æ—¶å€™ï¼Œä¹Ÿæ˜¯ä½¿ç”¨çš„Pythonè¯­è¨€ã€‚ä½†æ˜¯å­¦åˆ°åæœŸï¼Œæˆ‘å‘ç°ï¼ŒPythonçš„çµåŠ¨ä½¿æˆ‘å¯¹ç®—æ³•çš„å…³é”®æ‰§è¡Œæ­¥éª¤ç†è§£èµ·æ¥å¹¶ä¸æ˜¯éå¸¸æ¸…æ™°ã€‚Cè¯­è¨€ç›¸æ¯”äºPythonï¼Œæ²¡ç”¨é‚£ä¹ˆå¤šçµåŠ¨æ€§ï¼Œå¦‚æœå†å¼•å…¥æŒ‡é’ˆï¼Œå¤§éƒ¨åˆ†æœ¬ç§‘ç”Ÿæ˜¯å¾ˆè®¨åŒçš„ã€‚ä½†æ˜¯ï¼Œæ­£æ˜¯ç”±äºCè¯­è¨€çš„æœ´å®ï¼Œæˆ‘æ‰å‘ç°äº†æ•°æ®ç»“æ„ä¸ç®—æ³•çœŸæ­£çš„é­…åŠ›æ‰€åœ¨ã€‚(åªå¯æ„ä¼šä¸å¯è¨€ä¼ å“ˆå“ˆå“ˆ!)ã€‚æ‰€ä»¥ï¼Œæ‰“å¥½Cè¯­è¨€çš„åŸºç¡€ä»»ä½•æ—¶å€™éƒ½éœ€è¦ï¼ï¼ï¼â€”â€”2023.09.05è¡¥å…… å†™åœ¨2022å¹´ç»ˆå²å°¾ï¼š å› ä¸ºç–«æƒ…ï¼Œçªå¦‚å…¶æ¥çš„å¯’å‡åˆå¼€å§‹äº†ï¼Œè¿™ä¸ªå‡æœŸä¸»è¦å¹²ä¸‰ä»¶äº‹ï¼š408,408ï¼Œè¿˜TMDæ˜¯408ï¼ å½“ç„¶æ•°æ®ç»“æ„è¿˜æ˜¯æ¥ç»­å­¦ï¼Œç®—æ³•é¢˜è¿˜æ˜¯è¦ç»§ç»­åˆ·ã€‚åˆ©ç”¨å¯’å‡å·©å›ºä¸€ä¸‹ç«èµ›ä¸­çš„C++åŸºç¡€è¯­æ³•çŸ¥è¯†å’Œç®—æ³•æé«˜ã€‚å¯’å‡åˆ·é¢˜çš„è¯­è¨€å…¨éƒ¨è½¬æ¢åˆ°äº†C++ä¸Šï¼ŒåæœŸçœ‹åˆ°è¯­è¨€çš„è½¬å˜å°±ä¸è¦æ„Ÿåˆ°å·®å¼‚ã€‚ç®—æ³•å­¦ä¹ å¼ºæ¨ACwing-é—«å­¦ç¿ï¼ å†™åœ¨2023å¹´åˆï¼š 2023å¼€å¹´â€”â€”å¼€å§‹æ–°ä¸€é408æ•°æ®ç»“æ„ä¸ç®—æ³•çš„æ€»ç»“å¤ä¹ ï¼Œè¿™ä¸€éæ³¨é‡åŸºç¡€çŸ¥è¯†ï¼Œç‰¹åˆ«æ˜¯æ—¶é—´-ç©ºé—´å¤æ‚åº¦çš„è®¡ç®—ã€ç¨‹åºè®¾è®¡å¤§é¢˜ä»£ç çš„é»˜å†™(ç»†èŠ‚)ã€å„ç§ç®—æ³•çš„è®¡ç®—è¿‡ç¨‹ã€‚ åé¢å­¦çš„å¤šäº†ï¼Œä¸œæ¥å¤§å“¥çš„ä¹¦å·²ç»ä¸èƒ½æ»¡è¶³æˆ‘å¾—å­¦ä¹ æ¿€æƒ…äº†,åšè§ˆç¾¤ä¹¦å€Ÿé‰´å¤šä½ä¸“å®¶å¤§ä½¬çš„æ€æƒ³ç²¾åã€‚ å‚è€ƒå­¦ä¹ æ›´å¤šä¹¦ç›®å¦‚ä¸‹ï¼š [1]è®¡ç®—ä¹‹é­‚.å´å†› [2]ç®—æ³•å¯¼è®º.MIT [3]æ•°æ®ç»“æ„ä¸ç®—æ³•.ä¸¥è”šæ• [4]labuladongçš„ç®—æ³•å°æŠ„.ä»˜ä¸œæ¥ [5]ä»£ç éšæƒ³å½•.å­™ç§€æ´‹ [6]STLæºç å‰–æ.ä½•æ· [7]å¤§è¯æ•°æ®ç»“æ„.ç¨‹æ°(å°ç™½å¼ºæ¨) [8]æ•°æ®ç»“æ„ä¸ç®—æ³•ä¹ é¢˜é›†.ä¸¥è”šæ• C++åŸºç¡€è¯­æ³•-&gt;ç«èµ›ç›¸å…³ è¯­æ³•å­¦ä¹ å‚è€ƒyç¥ï¼šACwing-é—«å­¦ç¿ï¼ C++ä¸­çš„æ•°æ®ç±»å‹ bool:true/false 1 bytes char:â€˜aâ€™,â€˜câ€™,â€˜ â€™,â€˜\\nâ€™ 1 bytes intï¼šâˆ’231âˆ’231âˆ’1-2^{31} - 2^{31}-1âˆ’231âˆ’231âˆ’1 4 bytes float: 1.23,2.51,2.35e2 6-7ä½æœ‰æ•ˆæ•°å­—å•ç²¾åº¦æµ®ç‚¹å‹æ•°æ® 4 bytes double(double flaot):15-16ä½åŒç²¾åº¦æµ®ç‚¹å‹ 8 bytes long long(long int):âˆ’263âˆ’263âˆ’1-2^{63} - 2^{63}-1âˆ’263âˆ’263âˆ’1 8 bytes long double:18-19ä½æœ‰æ•ˆæ•°å­— 16 bytes #include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; int main(){ int a,b,c,d; int x; cin &gt;&gt; a; cin &gt;&gt; b; cin &gt;&gt; c; cin &gt;&gt; d; x = a*b-c*d; cout &lt;&lt; &quot;DIFERENCA = &quot; &lt;&lt; x &lt;&lt; endl; return 0; } C++ä¸­çš„æ ¼å¼åŒ–çš„è¾“å…¥è¾“å‡º printfè¾“å‡ºæ ¼å¼ æ³¨æ„ï¼šä½¿ç”¨printf æ—¶æœ€å¥½æ·»åŠ å¤´æ–‡ä»¶ #include ã€‚ Intã€floatã€doubleã€charç­‰ç±»å‹çš„è¾“å‡ºæ ¼å¼ï¼š (1) Intï¼š%d (2) Float: %f, é»˜è®¤ä¿ç•™6ä½å°æ•° (3) Double: %lfï¼Œ é»˜è®¤ä¿ç•™6ä½å°æ•° (4) Char: %c, å›è½¦ä¹Ÿæ˜¯ä¸€ä¸ªå­—ç¬¦ï¼Œç”¨â€™\\nâ€™è¡¨ç¤º åœ¨mainå‡½æ•°å†…éƒ¨ï¼Œæœªåˆå§‹åŒ–çš„æ•°ç»„ä¸­çš„å…ƒç´ æ˜¯éšæœºçš„ã€‚ ç»ªè®ºä¸åŸºç¡€æ¦‚å¿µ æ•°æ®ç»“æ„ï¼šæ˜¯äº’ç›¸ä¹‹é—´å­˜åœ¨çš„ä¸€ç§æˆ–è€…å¤šç§ç‰¹å®šå…³ç³»çš„æ•°æ®å…ƒç´ çš„é›†åˆã€‚ æ•°æ®ç»“æ„æ˜¯ä¸€é—¨ç ”ç©¶éæ•°å€¼è®¡ç®—çš„ç¨‹åºè®¾è®¡é—®é¢˜ä¸­çš„æ“ä½œå¯¹è±¡ï¼Œä»¥åŠä»–ä»¬ä¹‹é—´çš„å…³ç³»å’Œæ“ä½œç›¸å…³é—®é¢˜çš„å­¦ç§‘ã€‚ ç¨‹åºè®¾è®¡=æ•°æ®ç»“æ„+ç®—æ³• ç®—æ³•çš„äº”å¤§ç‰¹æ€§ -&gt;å¤§è¯æ•°æ®ç»“æ„-ç¨‹æ° ç®—æ³•å…·æœ‰äº”ä¸ªåŸºæœ¬ç‰¹æ€§ï¼šè¾“å…¥ã€è¾“å‡ºã€æœ‰ç©·æ€§ã€ç¡®å®šæ€§å’Œå¯è¡Œæ€§ã€‚ è¾“å…¥è¾“å‡ºï¼š è¾“å…¥å’Œè¾“å‡ºç‰¹æ€§æ¯”è¾ƒå®¹æ˜“ç†è§£ï¼Œç®—æ³•å…·æœ‰é›¶ä¸ªæˆ–å¤šä¸ªè¾“å…¥ã€‚ç®—æ³•è‡³å°‘æœ‰ä¸€ä¸ªæˆ–å¤šä¸ªè¾“å‡ºï¼Œç®—æ³•æ˜¯ä¸€å®šéœ€è¦è¾“å‡ºçš„ï¼Œä¸éœ€è¦è¾“å‡ºï¼Œä½ ç”¨è¿™ä¸ªç®—æ³•å¹²å—ï¼Ÿè¾“å‡ºçš„å½¢å¼å¯ä»¥æ˜¯æ‰“å°è¾“å‡ºï¼Œä¹Ÿå¯ä»¥æ˜¯è¿”å›ä¸€ä¸ªæˆ–å¤šä¸ªå€¼ç­‰ã€‚ æœ‰ç©·æ€§ è®¤è¯†åˆ°ä¸€ä¸ªé—®é¢˜çš„è¾¹ç•Œã€‚æœ‰ç©·æ€§ï¼šæŒ‡ç®—æ³•åœ¨æ‰§è¡Œæœ‰é™çš„æ­¥éª¤ä¹‹åï¼Œè‡ªåŠ¨ç»“æŸè€Œä¸ä¼šå‡ºç°æ— é™å¾ªç¯ï¼Œå¹¶ä¸”æ¯ä¸€ä¸ªæ­¥éª¤åœ¨å¯æ¥å—çš„æ—¶é—´å†…å®Œæˆã€‚ç°å®ä¸­ç»å¸¸ä¼šå†™å‡ºæ­»å¾ªç¯çš„ä»£ç ï¼Œè¿™å°±æ˜¯ä¸æ»¡è¶³æœ‰ç©·æ€§ã€‚å½“ç„¶è¿™é‡Œæœ‰ç©·çš„æ¦‚å¿µå¹¶ä¸æ˜¯çº¯æ•°å­¦æ„ä¹‰çš„ï¼Œè€Œæ˜¯åœ¨å®é™…åº”ç”¨å½“ä¸­åˆç†çš„ã€å¯ä»¥æ¥å—çš„â€œæœ‰è¾¹ç•Œâ€ã€‚ ç¡®å®šæ€§ ç¡®å®šæ€§ï¼šç®—æ³•çš„æ¯ä¸€æ­¥éª¤éƒ½å…·æœ‰ç¡®å®šçš„å«ä¹‰ï¼Œä¸ä¼šå‡ºç°äºŒä¹‰æ€§ï¼Œç›¸åŒçš„è¾“å…¥åªèƒ½æœ‰å”¯ä¸€çš„è¾“å‡ºç»“æœã€‚ç®—æ³•çš„æ¯ä¸ªæ­¥éª¤è¢«ç²¾ç¡®å®šä¹‰è€Œæ— æ­§ä¹‰ã€‚ å¯è¡Œæ€§ å¯è¡Œæ€§ï¼šç®—æ³•çš„æ¯ä¸€æ­¥éƒ½å¿…é¡»æ˜¯å¯è¡Œçš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæ¯ä¸€æ­¥éƒ½èƒ½å¤Ÿé€šè¿‡æ‰§è¡Œæœ‰é™æ¬¡æ•°å®Œæˆã€‚å¯è¡Œæ€§æ„å‘³ç€ç®—æ³•å¯ä»¥è½¬æ¢ä¸ºç¨‹åºä¸Šæœºè¿è¡Œï¼Œå¹¶å¾—åˆ°æ­£ç¡®çš„ç»“æœã€‚ ç®—æ³•ä¸æ—¶ç©ºå¤æ‚åº¦ ç®—æ³•æ˜¯è§£å†³ç‰¹å®šé—®é¢˜çš„æ±‚è§£æ­¥éª¤æè¿°ï¼Œåœ¨è®¡ç®—æœºä¸­è¡¨ç°ä¸ºæŒ‡ä»¤çš„æœ‰é™åºåˆ—ï¼Œå¹¶ä¸”æ¯æ¡æŒ‡ä»¤è¡¨ç¤ºä¸€ä¸ªæˆ–è€…å¤šä¸ªæ“ä½œã€‚è®¾è®¡ç®—æ³•åº”è¯¥å°½é‡æ»¡è¶³æ—¶é—´æ•ˆç‡é«˜å’Œå­˜å‚¨é‡ä½çš„éœ€æ±‚ã€‚ å‡½æ•°çš„æ¸è¿›å¢é•¿ ç»™å®šä¸¤ä¸ªå‡½æ•°f(n)f(n)f(n)å’Œg(n)g(n)g(n),å¦‚æœå­˜åœ¨ä¸€ä¸ªæ•´æ•°N,ä½¿å¾—å¯¹äºæ‰€æœ‰çš„n&gt;N,f(n)f(n)f(n)æ€»æ˜¯æ¯”g(n)g(n)g(n)å¤§,é‚£ä¹ˆæˆ‘ä»¬è¯´f(n)f(n)f(n)çš„å¢é•¿æ¸è¿›å¿«äºg(n)g(n)g(n)ã€‚ æ—¶é—´å¤æ‚åº¦è®¡ç®— ä¸€å±‚å¾ªç¯ æ€è·¯ï¼š åˆ—å‡ºå¾ªç¯çš„è¶Ÿæ•°tåŠæ¯è½®å¾ªç¯içš„å˜åŒ–å€¼ æ‰¾åˆ°tä¸içš„å…³ç³» ç¡®å®šå¾ªç¯ç»ˆæ­¢çš„æ¡ä»¶ è”ç«‹ä¸¤ä¸ªå¼å­ï¼Œè§£æ–¹ç¨‹ å†™ç»“æœ ä¸¤å±‚å¾ªç¯ æ€è·¯ï¼š åˆ—å‡ºå¤–å±‚å¾ªç¯ä¸­içš„å˜åŒ–èŒƒå›´ åˆ—å‡ºå†…å±‚è¯­å¥çš„æ‰§è¡Œæ¬¡æ•° æ±‚å’Œå†™å‡ºç»“æœ åŸºç¡€ç»“æ„çš„å¤ç›˜ä¸å¼ºåŒ– å¤‡æˆ˜è€ƒç ”å‘¢ï¼Œä¹Ÿç®—æ˜¯å¤ä¹ ä¸€éCè¯­è¨€åŸºç¡€ï¼Œè·Ÿç€ç‹é“é¾™å“¥è¿‡ä¸€éC/C++åŸºç¡€ã€‚ å•é“¾è¡¨ å•é“¾è¡¨çš„å¢åˆ æ”¹æŸ¥ #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; //åœ¨æ­¤ç¨‹åºä¸­ï¼Œ*LinkListæ˜¯å˜é‡çš„æŒ‡é’ˆï¼›LinkListä¸ºæŒ‡é’ˆå˜é‡ã€‚ //å•é“¾è¡¨çš„å¢åˆ æ”¹æŸ¥ //çº¿æ€§è¡¨çš„é“¾å¼è¡¨ç¤ºå°±æ˜¯å•é“¾è¡¨ #define Maxsize 50 #define InitSize 100 //å®šä¹‰ä¸€ä¸ªæ•´å‹ç±»å‹çš„å˜é‡ typedef int ElemType; //å•é“¾è¡¨ç»“æ„åˆ›å»º-8ä¸ªå­—èŠ‚ typedef struct LNode {//å•é“¾è¡¨çš„ç»“æ„ ElemType data;//æ•°æ®åŸŸ struct LNode* next;//æŒ‡é’ˆåŸŸ }LNode,*LinkList; //LinkListä¸ºç»“æ„ä½“æŒ‡é’ˆç­‰ä»·äºstruct LNode* //åˆ«åLNodeå¯ä»¥å’Œä¸Šé¢ä¿æŒä¸€è‡´ //å¤´æ’æ³•æ’å…¥æ–°çš„èŠ‚ç‚¹ //åˆ›å»ºå•é“¾è¡¨-&gt;å¸¦æœ‰å¤´ç»“ç‚¹ //å¤´ç»“ç‚¹åªéœ€è¦å¤´æŒ‡é’ˆæŒ‡å‘ï¼Œå•¥ä¹Ÿä¸å­˜ LinkList CreatList1(LinkList &amp;L) { LNode* q; int x; L = (LinkList)malloc(sizeof(LNode));//å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨ L-&gt;next = NULL; scanf_s(&quot;%d&quot;, &amp;x); while (x != 9999) { q = (LinkList)malloc(sizeof(LNode)); q-&gt;data = x; q-&gt;next = L-&gt;next; L-&gt;next = q; scanf_s(&quot;%d&quot;, &amp;x); } return L; } //å°¾æ’æ³•åˆ›å»ºå•é“¾è¡¨ LinkList CreatList2(LinkList &amp;L) { int x; L = (LinkList)malloc(sizeof(LNode));//å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨ //åœ¨è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œræœ¬èº«å°±æ˜¯è¡¨å°¾èŠ‚ç‚¹,æŒ‡å‘é“¾è¡¨å°¾éƒ¨ LNode* s, * r = L;//ç­‰ä»·äºLinkList s,r=L; scanf_s(&quot;%d&quot;, &amp;x); while (x != 9999) { s = (LinkList)malloc(sizeof(LNode)); s-&gt;data = x; r-&gt;next = s; r = s;//ræŒ‡å‘æ–°çš„è¡¨å°¾èŠ‚ç‚¹ scanf_s(&quot;%d&quot;, &amp;x); } r-&gt;next = NULL;//å°¾èŠ‚ç‚¹æŒ‡é’ˆèµ‹å€¼ä¸ºç©º return L; } //æŸ¥æ‰¾èŠ‚ç‚¹ LNode* GetElem(LinkList L, int i) { int j = 1; //åˆå§‹æŒ‡å‘è™šæ‹Ÿå¤´ç»“ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ LNode* p = L-&gt;next; if (i == 0) { return L; } if (i &lt; 1) { return NULL; } //p-&gt;éç©º while (p &amp;&amp; j &lt; i) { p = p-&gt;next; j++; } return p; } //ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´æ’å…¥èŠ‚ç‚¹ //ç¬¬iä¸ªä½ç½®æ’å…¥å€¼ä¸ºeçš„èŠ‚ç‚¹ bool InsertFrontList(LinkList L,int i,ElemType e) { LinkList p = GetElem(L,i - 1); if (NULL == p) { return false; } LinkList s = (LNode*)malloc(sizeof(LNode));//ä¸ºæ–°æ’å…¥çš„èŠ‚ç‚¹ç”³è¯·å†…å­˜ç©ºé—´ s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; return true; } bool InsertBackList(LinkList L,ElemType e) { //L = (LinkList)malloc(sizeof(LNode));//å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨ while (L-&gt;next != NULL) { L = L-&gt;next; } LNode* q; int x; scanf_s(&quot;%d&quot;, &amp;x); while (x != 9999) { q = (LinkList)malloc(sizeof(LNode)); q-&gt;data = x; L-&gt;next = q; q-&gt;next = NULL; scanf_s(&quot;%d&quot;, &amp;x); } return L; } //æ— è®ºæ˜¯ä¸­é—´æ’å…¥è¿˜æ˜¯åˆ é™¤ï¼Œæ‰¾åˆ°éœ€è¦æ“ä½œèŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹æ˜¯å…³é”® //åˆ é™¤ç¬¬iä¸ªä½ç½®çš„èŠ‚ç‚¹ bool DeleteList(LinkList L,int i) { //æ‰¾åˆ°è¦åˆ é™¤å…ƒç´ çš„å‰é©±ç»“ç‚¹ LinkList p = GetElem(L, i - 1); LinkList q = p-&gt;next; if (p == NULL) { return false;//è¦åˆ é™¤çš„ä½ç½®ä¸å­˜åœ¨ } p-&gt;next = q-&gt;next;//æ–­é“¾ free(q); q = NULL; return true; } void PrintList(LinkList L) { //å¤´ç»“ç‚¹ L = L-&gt;next; while (L != NULL) { printf(&quot;%d\\t&quot;, L-&gt;data); L = L-&gt;next; } } //æŸ¥æ‰¾ç¬¬å‡ ä¸ªå…ƒç´  LinkList LocateElem(LinkList L, ElemType e) { int j = 1; LinkList p = L-&gt;next; while (p != NULL &amp;&amp; p-&gt;data != e) { p = p-&gt;next; j++; } return p; } int main() { //å®šä¹‰é“¾è¡¨å¤´,ç»“æ„ä½“æŒ‡é’ˆç±»å‹ LinkList L; LinkList search;//ç”¨æ¥å­˜å‚¨æ‹¿åˆ°çš„æŸä¸€ä¸ªèŠ‚ç‚¹ LinkList search1; printf(&quot;è¯·åœ¨ä¸‹æ–¹è¾“å…¥å•é“¾è¡¨çš„å€¼ï¼šï¼ˆ^_^å¤§äº5ä¸ªå…ƒç´ ä¸”è¾“å…¥9999ç»ˆæ­¢^_^ï¼‰\\n&quot;); CreatList1(L); printf(&quot;å¤´æ’æ³•çš„ç»“æœä¸ºï¼š&quot;); PrintList(L); search = GetElem(L, 2); if (search != NULL) { printf(&quot;\\næŒ‰åºå·æŸ¥æ‰¾æˆåŠŸï¼~\\n&quot;); printf(&quot;è¯¥ä½ç½®çš„å€¼ä¸ºï¼š%3d\\n&quot;, search-&gt;data); } search1 = LocateElem(L, 5); /* if (search1 != NULL) { printf(&quot;\\næŒ‰åºå·æŸ¥æ‰¾æˆåŠŸï¼~\\n&quot;); printf(&quot;è¯¥çš„å€¼ä¸ºï¼š%3d&quot;, search-&gt;data); } */ InsertFrontList(L, 3, 30); PrintList(L); printf(&quot;\\n-----------\\n&quot;); printf(&quot;åˆ é™¤åçš„ç»“æœä¸ºï¼š\\n&quot;); DeleteList(L, 3); PrintList(L); printf(&quot;\\n-----------\\n&quot;); printf(&quot;è¯·åœ¨ä¸‹æ–¹è¾“å…¥å•é“¾è¡¨çš„å€¼ï¼šï¼ˆ^_^å¤§äº5ä¸ªå…ƒç´ ä¸”è¾“å…¥9999ç»ˆæ­¢^_^ï¼‰\\n&quot;); CreatList2(L); printf(&quot;å°¾æ’æ³•çš„ç»“æœä¸ºï¼š&quot;); PrintList(L); return 0; } æ ˆå’Œé˜Ÿåˆ— æ ˆçš„å…¥æ ˆå‡ºæ ˆ #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #define Maxsize 50 //å †æ ˆçš„æ“ä½œ //LIFO-&gt;åè¿›å…ˆå‡ºçš„æ“ä½œæ–¹å¼ //s.topå°±æ˜¯ç”¨æ¥æŒ‡å‘æ•°ç»„ä¸‹æ ‡çš„æŒ‡é’ˆ typedef int ElemType; typedef struct { ElemType data[Maxsize];//æ•°ç»„ int top; }SqStack; //å¿…é¡»ä½¿ç”¨C++çš„å¼•ç”¨ï¼Œå› ä¸ºæ˜¯ä»ä¸­å‡½æ•°ä¼ å€¼è¿›æ¥ï¼Œæ”¹å˜å®å‚çš„å€¼ void InitStack(SqStack &amp;S) { S.top = -1;//æ ˆç©º } //åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©ºï¼šå› ä¸ºä¸éœ€è¦æ”¹å˜å®å‚çš„å€¼ï¼Œæ‰€ä»¥ä¸ç”¨åŠ å¼•ç”¨ bool StackEmpty(SqStack S) { if (S.top == -1) { return true; } return false; } //å‹æ ˆæ“ä½œ //éœ€è¦æ”¹å˜å®å‚ä¸­çš„æ ˆæ•°å€¼ï¼Œæ‰€ä»¥éœ€è¦åŠ å…¥å¼•ç”¨ bool Push(SqStack&amp; S, ElemType x) { //æ— è®ºæ˜¯æ ˆè¿˜æ˜¯é˜Ÿåˆ—ã€é“¾è¡¨ï¼›åœ¨è¿›è¡Œæ’å…¥æ“ä½œæ—¶ï¼Œä¸€å®šè®°å¾—è¦é¦–å…ˆåˆ¤æ–­æ˜¯æ»¡ if (S.top == Maxsize - 1) { return false; } //å‹æ ˆæ“ä½œ-&gt;å…ˆè¿›æ€§+æ“ä½œ //æ ˆå†…å…ƒç´ å­˜æ”¾åœ¨ä¸€ä¸ªæ•°ç»„å½“ä¸­ S.data[++S.top] = x; return true; } bool GetTop(SqStack S, ElemType&amp; x) { if (StackEmpty(S)) { return false; } x = S.data[S.top]; return true; } //å‡ºæ ˆæ“ä½œ bool Pop(SqStack &amp;S,ElemType x) { if (StackEmpty(S)) { return false; } //ä»¥ä¸‹ä¸¤å¥ç­‰ä»·äºx = S.data[S.top--]; x = S.data[S.top--]; //S.top--; return true; } int main() { SqStack S;//åˆå§‹åŒ– bool flag; ElemType m; InitStack(S); flag = StackEmpty(S); if (flag) { printf(&quot;æ ˆæ˜¯ç©ºçš„ï¼\\n&quot;); } //å…ƒç´ å‹æ ˆ Push(S, 3); Push(S, 4); Push(S, 5); Push(S, 6); flag = GetTop(S, m); if (flag) { printf(&quot;å¾—åˆ°çš„æ ˆé¡¶å…ƒç´ ä¸ºï¼š%d\\n&quot;, m); } flag = Pop(S, 6); if (flag) { printf(&quot;å¼¹å‡ºçš„å…ƒç´ ä¸ºï¼š%d\\n&quot;, m); } return 0; } é˜Ÿåˆ—ä¸å¾ªç¯é˜Ÿåˆ— #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; typedef int ElemType; typedef struct LinkNode { ElemType data; struct LinkNode* next; }LinkNode; typedef struct { struct LinkNode* front, * tail; }LinkQueue; bool InitQueue(LinkQueue &amp;Q) { Q.front = Q.tail = (LinkNode*)malloc(sizeof(LinkNode)); Q.front-&gt;next = NULL; return true; } //å°¾æ’æ³•å…¥é˜Ÿ void EnQueue(LinkQueue&amp; Q, ElemType x) { LinkNode *s = (LinkNode*)malloc(sizeof(LinkNode)); s-&gt;data = x; s-&gt;next = NULL; Q.tail-&gt;next = s; Q.tail = s; } //å¤´æ’æ³•åˆ é™¤ bool DeQueue(LinkQueue&amp; Q, ElemType&amp; x) { //åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º if (Q.front == Q.tail)return false; //é˜Ÿå¤´å‡ºé˜ŸèŠ‚ç‚¹ LinkNode* p = Q.front-&gt;next; x = p-&gt;data; Q.front-&gt;next = p-&gt;next; if (Q.tail == p) { Q.front = Q.tail; } free(p); return true; } int main(void) { LinkQueue Q; ElemType data; bool ret; InitQueue(Q); EnQueue(Q, 3); EnQueue(Q, 4); EnQueue(Q, 5); EnQueue(Q, 6); EnQueue(Q, 7); ret = DeQueue(Q, data); if (ret) { printf(&quot;å‡ºé˜ŸæˆåŠŸï¼ï¼ï¼\\n&quot;); printf(&quot;å‡ºé˜Ÿå…ƒç´ ä¸ºï¼š%d\\n&quot;,data); } else { printf(&quot;å‡ºé˜Ÿå¤±è´¥~~\\n&quot;); } return 0; } ----------------------------------------------------------- //å¾ªç¯é˜Ÿåˆ— #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; //408å¸¸è€ƒçš„å¾ªç¯é˜Ÿåˆ— #define Maxsize 5 typedef int ElemType; //å¾ªç¯é˜Ÿåˆ—çš„ç»“æ„ typedef struct { ElemType data[Maxsize]; int front, tail; }SqQueue; //åˆå§‹åŒ–å‡½æ•° void InitQueue(SqQueue&amp; q) { q.front = q.tail = 0; } //åˆ¤æ–­æ˜¯å¦ä¸ºç©º bool isEmpty(SqQueue q) { //é˜Ÿå¤´æŒ‡é’ˆ==é˜Ÿå°¾æŒ‡é’ˆ if (q.front == q.tail) { return true; } else { return false; } } //å…ƒç´ å…¥é˜Ÿå‡½æ•° bool EnQueue(SqQueue&amp; q, ElemType x) { //å…ˆåˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦æ»¡é˜Ÿ if ((q.tail + 1) % Maxsize == q.front) { return false; } q.data[q.tail + 1] = x; q.tail = (q.tail + 1) % Maxsize; return true; } int main() { SqQueue q; bool ret; ElemType m; InitQueue(q); EnQueue(q, 1); EnQueue(q, 2); EnQueue(q, 3); return 0; } äºŒå‰æ ‘ å±‚æ¬¡å»ºæ ‘ä¸ä¸‰ç§éå†æ–¹å¼ #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; //å±‚æ¬¡å»ºæ ‘ //æ ‘çš„ç»“æ„ä½“å»ºç«‹ typedef char BiElemType; typedef struct BiTNode { BiElemType root; struct BiTNode* left; struct BiTNode* right; }BiTNode,*BiTree; //å±‚æ¬¡é˜Ÿåˆ— typedef struct tag { BiTree p;//æ ‘çš„æŸä¸€ä¸ªèŠ‚ç‚¹çš„åœ°å€ struct tag* pnext; }tag_t,*ptag_t; //å‰åºéå† void PreOrder(BiTree p) { if (p != NULL) { putchar(p-&gt;root); PreOrder(p-&gt;left); PreOrder(p-&gt;right); } } //ä¸­åºéå† void InOrder(BiTree p) { if (p != NULL) { InOrder(p-&gt;left); putchar(p-&gt;root); InOrder(p-&gt;right); } } //ååºéå† void LastOrder(BiTree p) { if (p != NULL) { LastOrder(p-&gt;left); LastOrder(p-&gt;right); putchar(p-&gt;root); } } int main(void) { BiTree pnew; int i, j, pos; char c; BiTree tree = NULL;//æ ‘æ ¹ //å±‚æ¬¡å»ºæ ‘è¾…åŠ©é˜Ÿåˆ— ptag_t phead = NULL, ptail = NULL, listnew = NULL, pcur = NULL; while (scanf_s(&quot;%c&quot;, &amp;c) != EOF) { if (c == '\\n') { break; } pnew = (BiTree)calloc(1, sizeof(BiTNode));//callocç”³è¯·ç©ºé—´å¹¶å¯¹ç©ºé—´è¿›è¡Œåˆå§‹åŒ– pnew-&gt;root = c; listnew = (ptag_t)calloc(1, sizeof(tag_t)); listnew-&gt;p = pnew; if (tree == NULL) { tree = pnew; phead = listnew;//é˜Ÿåˆ—å¤´ ptail = listnew;//é˜Ÿåˆ—å°¾ pcur = listnew; continue; } else { ptail-&gt;pnext = listnew;//æ–°èŠ‚ç‚¹å…¥é˜Ÿï¼Œå°¾æ’æ³• ptail = listnew; } if (pcur-&gt;p-&gt;left == NULL) { pcur-&gt;p-&gt;left = pnew;//æŠŠæ–°èŠ‚ç‚¹æ”¾å…¥åˆ°å½“å‰èŠ‚ç‚¹çš„å·¦å­©å­ } else if (pcur-&gt;p-&gt;right == NULL) { pcur-&gt;p-&gt;right = pnew;//æŠŠæ–°èŠ‚ç‚¹æ”¾å…¥åˆ°å½“å‰èŠ‚ç‚¹çš„å·¦å­©å­ pcur = pcur-&gt;pnext;//å·¦å³éƒ½æ”¾äº†èŠ‚ç‚¹åï¼ŒpcuræŒ‡å‘é˜Ÿåˆ—çš„ä¸‹ä¸€ä¸ªå…ƒç´  } } printf(&quot;\\n-----------å‰åºéå†---------\\n&quot;); PreOrder(tree); printf(&quot;\\n-----------ä¸­åºéå†---------\\n&quot;); InOrder(tree); printf(&quot;\\n-----------ååºéå†---------\\n&quot;); LastOrder(tree); return 0; } æ€è€ƒ å‚è€ƒäºŒå‰æ ‘çš„ååºéå†ï¼Œå¦‚ä½•åˆ©ç”¨æ ˆå®ç°é€’å½’ä¸éé€’å½’çš„è½¬æ¢ï¼Ÿ é¦–å…ˆäºŒå‰æ ‘çš„ååºéå†è¿‡ç¨‹æ˜¯ä¸€ä¸ªè‡ªåº•å‘ä¸Šçš„å›æº¯è¿‡ç¨‹ï¼Œä¹Ÿå°±æ˜¯é€’å½’ä¸­å½’çš„è¿‡ç¨‹ã€‚é€’å½’è¿‡ç¨‹åˆ©ç”¨æ ˆçš„æ•°æ®ç»“æ„ï¼Œç”±é€’å½’çš„å¤–å±‚ï¼ˆé€’å½’æ ˆçš„åº•å±‚ï¼‰åˆ°base caseï¼ˆé€’å½’æ ˆçš„é¡¶å±‚ï¼‰ï¼›æ¯ä¸€ä¸ªé€’å½’è¿‡ç¨‹ç»†èŠ‚ä¸­éƒ½å°è£…åœ¨äº†å‡½æ•°çš„å†…éƒ¨ï¼Œå·²å®ç°é€’å½’é‡å¤è°ƒç”¨ã€‚è€Œå¯¹äºéé€’å½’çš„è½¬åŒ–ï¼Œå°±æ˜¯å°†å°è£…è¿‡ç¨‹æ‰“ç ´ï¼Œåˆ©ç”¨å¾ªç¯åµŒå¥—çš„æµç¨‹å»å®ç°é€’å½’è°ƒç”¨çš„è¿‡ç¨‹ã€‚è¿­ä»£å¾ªç¯æ˜¯ä¸€ä¸ªæ ¹æ®base caseçš„è‡ªåº•å‘ä¸Šè¿‡ç¨‹ã€‚ ä»‹ç»å¹¶ç†Ÿç»ƒæŒæ¡äº†åŸºç¡€çš„æ•°æ®ç»“æ„ï¼Œä¸‹é¢å°±å¼€å§‹çœŸæ­£çš„ç®—æ³•ä¹‹æ—…å–½~ åŒæŒ‡é’ˆæŠ€å·§åœ¨é“¾è¡¨ä¸æ•°ç»„ä¸­çš„è¿ç”¨ åŒæŒ‡é’ˆåˆ†ç±»ï¼š1.å¿«æ…¢æŒ‡é’ˆ 2.å·¦å³æŒ‡é’ˆ åŠ›æ‰£ä¸­çš„å¯¹åº”é¢˜ç›®å¦‚ä¸‹ï¼š æ•°ç»„ï¼š LeetCode åŠ›æ‰£ éš¾åº¦ 5. Longest Palindromic Substring 5. æœ€é•¿å›æ–‡å­ä¸² ğŸŸ  26. Remove Duplicates from Sorted Array 26. åˆ é™¤æœ‰åºæ•°ç»„ä¸­çš„é‡å¤é¡¹ ğŸŸ¢ 27. Remove Element 27. ç§»é™¤å…ƒç´  ğŸŸ¢ 83. Remove Duplicates from Sorted List 83. åˆ é™¤æ’åºé“¾è¡¨ä¸­çš„é‡å¤å…ƒç´  ğŸŸ¢ 167. Two Sum II - Input Array Is Sorted 167. ä¸¤æ•°ä¹‹å’Œ II - è¾“å…¥æœ‰åºæ•°ç»„ ğŸŸ¢ 283. Move Zeroes 283. ç§»åŠ¨é›¶ ğŸŸ¢ 344. Reverse String 344. åè½¬å­—ç¬¦ä¸² ğŸŸ¢ åœ¨å¤„ç†æ•°ç»„å’Œé“¾è¡¨ç›¸å…³é—®é¢˜æ—¶ï¼ŒåŒæŒ‡é’ˆæŠ€å·§æ˜¯ç»å¸¸ç”¨åˆ°çš„ï¼ŒåŒæŒ‡é’ˆæŠ€å·§ä¸»è¦åˆ†ä¸ºä¸¤ç±»ï¼šå·¦å³æŒ‡é’ˆå’Œå¿«æ…¢æŒ‡é’ˆã€‚ æ‰€è°“å·¦å³æŒ‡é’ˆï¼Œå°±æ˜¯ä¸¤ä¸ªæŒ‡é’ˆç›¸å‘è€Œè¡Œæˆ–è€…ç›¸èƒŒè€Œè¡Œï¼›è€Œæ‰€è°“å¿«æ…¢æŒ‡é’ˆï¼Œå°±æ˜¯ä¸¤ä¸ªæŒ‡é’ˆåŒå‘è€Œè¡Œï¼Œä¸€å¿«ä¸€æ…¢ã€‚ å¯¹äºå•é“¾è¡¨æ¥è¯´ï¼Œå¤§éƒ¨åˆ†æŠ€å·§éƒ½å±äºå¿«æ…¢æŒ‡é’ˆã€‚ åœ¨æ•°ç»„ä¸­å¹¶æ²¡æœ‰çœŸæ­£æ„ä¹‰ä¸Šçš„æŒ‡é’ˆï¼Œä½†æˆ‘ä»¬å¯ä»¥æŠŠç´¢å¼•å½“åšæ•°ç»„ä¸­çš„æŒ‡é’ˆï¼Œè¿™æ ·ä¹Ÿå¯ä»¥åœ¨æ•°ç»„ä¸­æ–½å±•åŒæŒ‡é’ˆæŠ€å·§ï¼Œæœ¬æ–‡å…ˆè®²æ•°ç»„ç›¸å…³çš„åŒæŒ‡é’ˆç®—æ³•ï¼Œå†è®²é“¾è¡¨æœ‰å…³çš„åŒæŒ‡é’ˆç®—æ³•ã€‚ Array~å¿«æ…¢æŒ‡é’ˆæŠ€å·§ æ•°ç»„é—®é¢˜ä¸­æ¯”è¾ƒå¸¸è§çš„å¿«æ…¢æŒ‡é’ˆæŠ€å·§ï¼Œæ˜¯è®©ä½ åŸåœ°ä¿®æ”¹æ•°ç»„ã€‚ ç®€å•è§£é‡Šä¸€ä¸‹ä»€ä¹ˆæ˜¯åŸåœ°ä¿®æ”¹ï¼š å¦‚æœä¸æ˜¯åŸåœ°ä¿®æ”¹çš„è¯ï¼Œæˆ‘ä»¬ç›´æ¥ new ä¸€ä¸ª int[] æ•°ç»„ï¼ŒæŠŠå»é‡ä¹‹åçš„å…ƒç´ æ”¾è¿›è¿™ä¸ªæ–°æ•°ç»„ä¸­ï¼Œç„¶åè¿”å›è¿™ä¸ªæ–°æ•°ç»„å³å¯ã€‚ ä½†æ˜¯ç°åœ¨é¢˜ç›®è®©ä½ åŸåœ°åˆ é™¤ï¼Œä¸å…è®¸ new æ–°æ•°ç»„ï¼Œåªèƒ½åœ¨åŸæ•°ç»„ä¸Šæ“ä½œï¼Œç„¶åè¿”å›ä¸€ä¸ªé•¿åº¦ï¼Œè¿™æ ·å°±å¯ä»¥é€šè¿‡è¿”å›çš„é•¿åº¦å’ŒåŸå§‹æ•°ç»„å¾—åˆ°æˆ‘ä»¬å»é‡åçš„å…ƒç´ æœ‰å“ªäº›äº†ã€‚ ç”±äºæ•°ç»„å·²ç»æ’åºï¼Œæ‰€ä»¥é‡å¤çš„å…ƒç´ ä¸€å®šè¿åœ¨ä¸€èµ·ï¼Œæ‰¾å‡ºå®ƒä»¬å¹¶ä¸éš¾ã€‚ä½†å¦‚æœæ¯æ‰¾åˆ°ä¸€ä¸ªé‡å¤å…ƒç´ å°±ç«‹å³åŸåœ°åˆ é™¤å®ƒï¼Œç”±äºæ•°ç»„ä¸­åˆ é™¤å…ƒç´ æ¶‰åŠæ•°æ®æ¬ç§»ï¼Œæ•´ä¸ªæ—¶é—´å¤æ‚åº¦æ˜¯ä¼šè¾¾åˆ° O(N^2)ã€‚ é«˜æ•ˆè§£å†³è¿™é“é¢˜å°±è¦ç”¨åˆ°å¿«æ…¢æŒ‡é’ˆæŠ€å·§ï¼š æˆ‘ä»¬è®©æ…¢æŒ‡é’ˆ slow èµ°åœ¨åé¢ï¼Œå¿«æŒ‡é’ˆ fast èµ°åœ¨å‰é¢æ¢è·¯ï¼Œæ‰¾åˆ°ä¸€ä¸ªä¸é‡å¤çš„å…ƒç´ å°±èµ‹å€¼ç»™ slow å¹¶è®© slow å‰è¿›ä¸€æ­¥ã€‚ è¿™æ ·ï¼Œå°±ä¿è¯äº† nums[0..slow] éƒ½æ˜¯æ— é‡å¤çš„å…ƒç´ ï¼Œå½“ fast æŒ‡é’ˆéå†å®Œæ•´ä¸ªæ•°ç»„ nums åï¼Œnums[0..slow] å°±æ˜¯æ•´ä¸ªæ•°ç»„å»é‡ä¹‹åçš„ç»“æœã€‚ //Javaå®ç° int removeDuplicates(int[] nums){ if (nums.length == 0) { return 0; } int slow = 0,fast = 0; while (fast &lt; nums.length) { if (nums[fast] != nums[slow]) { slow++; nums[slow] = nums[fast]; } fast++; } return slow + 1; } #pythonå®ç° class Solution(object): def removeDuplicates(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if(len(nums) == 0): return 0 #can't assign to literalçš„é”™è¯¯æ¥æºæ˜¯slow=0ï¼Œfast=0å†™åœ¨äº†ä¸€è¡Œä¸­ #è¦ä¹ˆç”¨é€—å·éš”å¼€ï¼Œç”¨ä¹ˆåˆ†æˆä¸¤è¡Œå†™ slow=0 fast=0 while(fast &lt; len(nums)): if(nums[fast] != nums[slow]): slow += 1 nums[slow] = nums[fast] fast += 1 return slow + 1 åŒç†ï¼Œå°†æœ¬é¢˜çš„æ€æƒ³ç”¨äºé“¾è¡¨å»é‡çš„ä»£ç å®ç°ä¸ºï¼š ListNode deleteDuplicates(ListNode head) { if (head == null) return null; ListNode slow = head, fast = head; while (fast != null) { if (fast.val != slow.val) { // nums[slow] = nums[fast]; slow.next = fast; // slow++; slow = slow.next; } // fast++ fast = fast.next; } // æ–­å¼€ä¸åé¢é‡å¤å…ƒç´ çš„è¿æ¥ slow.next = null; return head; } ç±»ä¼¼çš„ï¼Œä¾‹å¦‚åŠ›æ‰£ä¸­çš„ç§»åŠ¨é›¶é¢˜ç›®ï¼š ç»™å®šä¸€ä¸ªæ•°ç»„ numsï¼Œç¼–å†™ä¸€ä¸ªå‡½æ•°å°†æ‰€æœ‰ 0 ç§»åŠ¨åˆ°æ•°ç»„çš„æœ«å°¾ï¼ŒåŒæ—¶ä¿æŒéé›¶å…ƒç´ çš„ç›¸å¯¹é¡ºåºã€‚ æœ¬è´¨å°±æ˜¯æ•°ç»„å»é‡åå°†å°¾å·´éƒ¨åˆ†å…ƒç´ æ”¹ä¸º0 class Solution(object): def moveZeroes(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: None Do not return anything, modify nums in-place instead. &quot;&quot;&quot; #è€å¥—è·¯ï¼Œè®¾ç½®å¿«æ…¢æŒ‡é’ˆ slow=0 fast=0 #æ ¸å¿ƒä»£ç åŒºï¼ŒåŒºåˆ†ä¸åŒç›®æ ‡å€¼çš„è®¾ç½® while(fast &lt;len(nums)): if(nums[fast] != 0): nums[slow] = nums[fast] slow += 1 fast += 1 #ä¸å‰é¢é¢˜å”¯ä¸€çš„ä¸åŒç‚¹ï¼Œæ˜¯å°†æ•°ç»„å»é‡åå°¾éƒ¨å…ƒç´ ä¿®æ”¹ä¸º0ï¼Œæ­¤å¤„æˆ‘ç”¨çš„forå¾ªç¯ï¼Œæœ‰å…¶ä»–æ–°æ–¹æ³•æ¬¢è¿å¤§ä½¬ä»¬ä¿®æ”¹æå‡ºæ„è§ for i in range(slow,len(nums)): nums[i] = 0 æ•°ç»„ç§»é™¤å…ƒç´  class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: slow,fast = 0,0 while(fast &lt; len(nums)): if(nums[fast] != val): nums[slow] = nums[fast] slow += 1 fast += 1 return slow ç§»é™¤æ•°ç»„ä¸­çš„é‡å¤å…ƒç´  class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: slow,fast = 0,0 while(fast &lt; len(nums)): if(nums[fast] != nums[slow]): slow += 1 nums[slow] = nums[fast] fast += 1 return slow + 1 å»é‡çš„æ ¸å¿ƒä»£ç å— while(fast &lt;len(nums)): if(nums[fast] != 0): nums[slow] = nums[fast] slow += 1 fast += 1 å¯¹äºæ ¸å¿ƒä»£ç å—è€Œè¨€ï¼Œåœ¨ç†Ÿç»ƒä½¿ç”¨çš„æƒ…å†µä¸‹è¦è®°ç‰¢ï¼Œæ–¹ä¾¿ååºå†™ç¨‹åºæ˜¯æ•ˆç‡æé«˜ã€‚ Array~å·¦å³æŒ‡é’ˆæŠ€å·§ äºŒåˆ†æŸ¥æ‰¾ç®—æ³• LeetCode åŠ›æ‰£ éš¾åº¦ 34. Find First and Last Position of Element in Sorted Array 34. åœ¨æ’åºæ•°ç»„ä¸­æŸ¥æ‰¾å…ƒç´ çš„ç¬¬ä¸€ä¸ªå’Œæœ€åä¸€ä¸ªä½ç½® ğŸŸ  704. Binary Search 704. äºŒåˆ†æŸ¥æ‰¾ ğŸŸ¢ é¦–å…ˆä»‹ç»ä»¥ä¸‹äºŒåˆ†æŸ¥æ‰¾çš„ä»£ç æ¡†æ¶ï¼š å…¶ä¸­ ... æ ‡è®°çš„éƒ¨åˆ†ï¼Œå°±æ˜¯å¯èƒ½å‡ºç°ç»†èŠ‚é—®é¢˜çš„åœ°æ–¹ï¼Œå½“ä½ è§åˆ°ä¸€ä¸ªäºŒåˆ†æŸ¥æ‰¾çš„ä»£ç æ—¶ï¼Œé¦–å…ˆæ³¨æ„è¿™å‡ ä¸ªåœ°æ–¹ã€‚åæ–‡ç”¨å®ä¾‹åˆ†æè¿™äº›åœ°æ–¹èƒ½æœ‰ä»€ä¹ˆæ ·çš„å˜åŒ–ã€‚ å¦å¤–æå‰è¯´æ˜ä¸€ä¸‹ï¼Œè®¡ç®— mid æ—¶éœ€è¦é˜²æ­¢æº¢å‡ºï¼Œä»£ç ä¸­ left + (right - left) / 2 å°±å’Œ (left + right) / 2 çš„ç»“æœç›¸åŒï¼Œä½†æ˜¯æœ‰æ•ˆé˜²æ­¢äº† left å’Œ right å¤ªå¤§ï¼Œç›´æ¥ç›¸åŠ å¯¼è‡´æº¢å‡ºçš„æƒ…å†µã€‚ def binarySearch(int[] nums, int target) { #è®¾ç½®å·¦å³æŒ‡é’ˆ int left = 0, right = ...; while(...) { #å…³é”®åœ¨midå€¼çš„è®¾å®šä¸å·¦å³è¾¹ç•Œç¡®å®š int mid = left + (right - left) / 2; if (nums[mid] == target) { ... } else if (nums[mid] &lt; target) { left = ... } else if (nums[mid] &gt; target) { right = ... } } return ...; } äºŒåˆ†æŸ¥æ‰¾å¹¶ä¸ç®€å•ï¼ŒKnuth å¤§ä½¬ï¼ˆè‘—æœ‰å¤§éƒ¨å¤´ã€Šè®¡ç®—æœºç¨‹åºè®¾è®¡ã€‹ä¸€ä¹¦ï¼Œæ— æ•°ç¨‹åºå‘˜çš„åœ£ç»ï¼‰éƒ½è¯´äºŒåˆ†æŸ¥æ‰¾ï¼šæ€è·¯å¾ˆç®€å•ï¼Œç»†èŠ‚æ˜¯é­”é¬¼ã€‚äºŒåˆ†æŸ¥æ‰¾çœŸæ­£çš„å‘æ ¹æœ¬å°±ä¸æ˜¯é‚£äº›æœ‰å…³äºæº¢å‡ºçš„ç»†èŠ‚é—®é¢˜ï¼Œè€Œæ˜¯åœ¨äºåˆ°åº•è¦ç»™ mid åŠ ä¸€è¿˜æ˜¯å‡ä¸€ï¼Œwhile é‡Œåˆ°åº•ç”¨ &lt;= è¿˜æ˜¯ &lt;ã€‚ å‡ ä¸ªæœ€å¸¸ç”¨çš„äºŒåˆ†æŸ¥æ‰¾åœºæ™¯ï¼šå¯»æ‰¾ä¸€ä¸ªæ•°ã€å¯»æ‰¾å·¦ä¾§è¾¹ç•Œã€å¯»æ‰¾å³ä¾§è¾¹ç•Œã€‚ æˆ‘ä»¬è¦æ·±å…¥ç»†èŠ‚ï¼Œæ¯”å¦‚ä¸ç­‰å·æ˜¯å¦åº”è¯¥å¸¦ç­‰å·ï¼Œmid æ˜¯å¦åº”è¯¥åŠ ä¸€ç­‰ç­‰ã€‚åˆ†æè¿™äº›ç»†èŠ‚çš„å·®å¼‚ä»¥åŠå‡ºç°è¿™äº›å·®å¼‚çš„åŸå› ï¼Œä¿è¯ä½ èƒ½çµæ´»å‡†ç¡®åœ°å†™å‡ºæ­£ç¡®çš„äºŒåˆ†æŸ¥æ‰¾ç®—æ³•ã€‚ å¤§å®¶å†™äºŒåˆ†æ³•ç»å¸¸å†™ä¹±ï¼Œä¸»è¦æ˜¯å› ä¸ºå¯¹åŒºé—´çš„å®šä¹‰æ²¡æœ‰æƒ³æ¸…æ¥šï¼ŒåŒºé—´çš„å®šä¹‰å°±æ˜¯ä¸å˜é‡ã€‚è¦åœ¨äºŒåˆ†æŸ¥æ‰¾çš„è¿‡ç¨‹ä¸­ï¼Œä¿æŒä¸å˜é‡ï¼Œå°±æ˜¯åœ¨whileå¯»æ‰¾ä¸­æ¯ä¸€æ¬¡è¾¹ç•Œçš„å¤„ç†éƒ½è¦åšæŒæ ¹æ®åŒºé—´çš„å®šä¹‰æ¥æ“ä½œï¼Œè¿™å°±æ˜¯å¾ªç¯ä¸å˜é‡è§„åˆ™ã€‚ å†™äºŒåˆ†æ³•ï¼ŒåŒºé—´çš„å®šä¹‰ä¸€èˆ¬ä¸ºä¸¤ç§ï¼Œå·¦é—­å³é—­å³[left, right]ï¼Œæˆ–è€…å·¦é—­å³å¼€å³[left, right)ã€‚ ä»æœ¬ä¹¦ä¸­å­¦åˆ°äº†ï¼Œåœ¨åˆ†æäºŒåˆ†æŸ¥æ‰¾æ—¶ï¼Œå¯¹äºé€‰æ‹©åˆ†æ”¯ç»“æ„if-elseå¾ˆå°‘ä½¿ç”¨ï¼Œè€Œæ˜¯ç”¨else if å–ä»£ï¼Œè¿™æ ·å¯ä»¥å±•ç¤ºäºŒåˆ†æŸ¥æ‰¾çš„æ‰€æœ‰ç»†èŠ‚ã€‚ å¯»æ‰¾ä¸€ä¸ªæ•° è¿™æ®µä»£ç å¯ä»¥è§£å†³åŠ›æ‰£ç¬¬ 704 é¢˜ã€Œ äºŒåˆ†æŸ¥æ‰¾ã€ã€‚ ä¸‹é¢æå‡ºè§£å†³æœ¬é¢˜éœ€è¦å…³æ³¨çš„ç»†èŠ‚ï¼š æœç´¢ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œæœç´¢åŒºé—´ä¸¤ç«¯é—­ï¼›whileæ¡ä»¶å¸¦ç­‰å·ï¼Œå¦åˆ™éœ€è¦æ‰“è¡¥ä¸ã€‚ ifç›¸ç­‰å°±è¿”å›ï¼Œå…¶ä»–çš„æ˜¯ç”­æ“å¿ƒï¼›midå¿…é¡»åŠ å‡ä¸€ï¼Œå› ä¸ºåŒºé—´ä¸¤ç«¯é—­ã€‚ whileç»“æŸå°±å‡‰å‡‰ï¼Œå‡„å‡„æƒ¨æƒ¨è¿”-1. class Solution(object): def search(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; left = 0 right = len(nums)-1 #æ˜“é”™ç‚¹ while(left &lt;= right): mid = left + (right - left)/2 if(nums[mid] == target): return mid elif(nums[mid] &lt; target): #å¯¹äºmidçš„æ“ä½œæ—¶äºŒåˆ†æŸ¥æ‰¾çš„ä¸€ä¸ªéš¾ç‚¹ã€‚ left = mid + 1 elif(nums[mid] &gt; target): right = mid - 1 return -1 while(left &lt;= right)çš„ç»ˆæ­¢æ¡ä»¶æ˜¯ï¼šleft == right + 1-&gt;[right + 1,right]ã€‚ while(left &lt; right)çš„ç»ˆæ­¢æ¡ä»¶æ˜¯ï¼šleft == right -&gt;[left,right]ã€‚ å¯»æ‰¾å·¦ä¾§è¾¹ç•Œ å·¦ä¾§è¾¹ç•Œæ˜¯å·¦é—­å³å¼€çš„æœç´¢åŒºé—´ï¼š[left,right),å› æ­¤éœ€è¦æ³¨æ„whileçš„æ¡ä»¶æ˜¯while(left&lt;right)ã€‚ right = len(nums) å¯»æ‰¾å³ä¾§è¾¹ç•Œ åè½¬ç³»åˆ—ä¸å›æ–‡ å›æ–‡æ¨¡æ¿ï¼š bool isPalindrome(const string&amp; s,int start,int end){ for(int i = start,j = end;i &lt; j;i++,j--){ if(s[i] != s[j]){ return false; } } return true; è¿­ä»£åè½¬å•é“¾è¡¨ # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def reverseList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; if head == None or head.next == None: return head pre = None tmp = None #åˆ‡è®°ç†è§£ç»ˆæ­¢æ¡ä»¶ while(head != None): #è¿­ä»£åè½¬è¿‡ç¨‹ tmp = head.next head.next = pre pre = head head = tmp return pre é€’å½’åè½¬å•é“¾è¡¨ # Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def reverseList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; #ç‰¹æ®Šæƒ…å†µ if head == None or head.next == None: return head last = self.reverseList(head.next) head.next.next = head head.next = None return last å›æ–‡é“¾è¡¨ #æ•°ç»„æ¨¡æ‹Ÿ class Solution: def isPalindrome(self, head: ListNode) -&gt; bool: length = 0 tmp = head while tmp: #æ±‚é“¾è¡¨é•¿åº¦ length += 1 tmp = tmp.next result = [0] * length tmp = head index = 0 while tmp: #é“¾è¡¨å…ƒç´ åŠ å…¥æ•°ç»„ result[index] = tmp.val index += 1 tmp = tmp.next i, j = 0, length - 1 while i &lt; j: # åˆ¤æ–­å›æ–‡ if result[i] != result[j]: return False i += 1 j -= 1 return True #åè½¬ååŠéƒ¨åˆ†é“¾è¡¨ class Solution: def isPalindrome(self, head: ListNode) -&gt; bool: if head == None or head.next == None: return True slow, fast = head, head while fast and fast.next: pre = slow slow = slow.next fast = fast.next.next pre.next = None # åˆ†å‰²é“¾è¡¨ cur1 = head # å‰åŠéƒ¨åˆ† cur2 = self.reverseList(slow) # åè½¬ååŠéƒ¨åˆ†ï¼Œæ€»é“¾è¡¨é•¿åº¦å¦‚æœæ˜¯å¥‡æ•°ï¼Œcur2æ¯”cur1å¤šä¸€ä¸ªèŠ‚ç‚¹ while cur1: if cur1.val != cur2.val: return False cur1 = cur1.next cur2 = cur2.next return True def reverseList(self, head: ListNode) -&gt; ListNode: cur = head pre = None while(cur!=None): temp = cur.next # ä¿å­˜ä¸€ä¸‹curçš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ cur.next = pre # åè½¬ pre = cur cur = temp return pre åè½¬æ•´æ•° class Solution: def reverse(self, x: int) -&gt; int: if(x == 0): return 0 if(x &gt; 0): y = int(str(x)[::-1]) return y if -2147483648&lt;y&lt;2147483647 else 0 if(x &lt; 0): y = -int(str(abs(x))[::-1]) return y if -2147483648&lt;y&lt;2147483647 else 0 æœ€é•¿å›æ–‡å­—ç¬¦ä¸² class Solution: def longestPalindrome(self, s: str) -&gt; str: res = ' ' for i in range(len(s)): start = max(0,i-len(res)-1) tmp = s[start : i+1] #åˆ†æƒ…å†µï¼šsä¸­å«æœ‰å­—æ¯çš„ä¸ªæ•° if tmp == tmp[::-1]: res = tmp else: tmp = tmp[1:] if tmp == tmp[::-1]: res = tmp return res åè½¬å­—ç¬¦ä¸² class Solution: def reverseString(self, s: List[str]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify s in-place instead. &quot;&quot;&quot; left, right = 0, len(s) - 1 # è¯¥æ–¹æ³•å·²ç»ä¸éœ€è¦åˆ¤æ–­å¥‡å¶æ•°ï¼Œç»æµ‹è¯•åæ—¶é—´ç©ºé—´å¤æ‚åº¦æ¯”ç”¨ for i in range(right//2)æ›´ä½ # æ¨èè¯¥å†™æ³•ï¼Œæ›´åŠ é€šä¿—æ˜“æ‡‚ while left &lt; right: s[left], s[right] = s[right], s[left] left += 1 right -= 1 Linked List~åŒæŒ‡é’ˆæŠ€å·§ é“¾è¡¨ï¼š LeetCode åŠ›æ‰£ éš¾åº¦ 19. Remove Nth Node From End of List 19. åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ N ä¸ªç»“ç‚¹ ğŸŸ  21. Merge Two Sorted Lists 21. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ ğŸŸ¢ 23. Merge k Sorted Lists 23. åˆå¹¶Kä¸ªå‡åºé“¾è¡¨ ğŸ”´ 86. Partition List 86. åˆ†éš”é“¾è¡¨ ğŸŸ  141. Linked List Cycle 141. ç¯å½¢é“¾è¡¨ ğŸŸ¢ 142. Linked List Cycle II 142. ç¯å½¢é“¾è¡¨ II ğŸŸ  160. Intersection of Two Linked Lists 160. ç›¸äº¤é“¾è¡¨ ğŸŸ¢ 876. Middle of the Linked List 876. é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹ ğŸŸ¢ è§£å†³é—®é¢˜ï¼š æœ¬èŠ‚çš„éš¾ç‚¹åœ¨äºï¼Œç›®å‰æ— æ³•çªç ´åœ¨åŠ›æ‰£ä¸­å¯¹äº**ã€Œè™šæ‹Ÿå¤´ç»“ç‚¹ã€**çš„å»ºç«‹ä½¿ç”¨ã€‚æ‰€ä»¥ä»£ç å…ˆæŒ‰ä¸œå“¥Javaå®ç°ï¼ŒåŠªåŠ›çªç ´éš¾ç‚¹åï¼Œå…¨éƒ¨æ›´æ–°ä¸ºpythonä»£ç ã€‚ è®¾è®¡é“¾è¡¨-å……åˆ†æŒæ¡ åœ¨é“¾è¡¨ç±»ä¸­å®ç°è¿™äº›åŠŸèƒ½ï¼š -get(index)ï¼šè·å–é“¾è¡¨ä¸­ç¬¬ index ä¸ªèŠ‚ç‚¹çš„å€¼ã€‚å¦‚æœç´¢å¼•æ— æ•ˆï¼Œåˆ™è¿”å›-1ã€‚ -addAtHead(val)ï¼šåœ¨é“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰æ·»åŠ ä¸€ä¸ªå€¼ä¸º val çš„èŠ‚ç‚¹ã€‚æ’å…¥åï¼Œæ–°èŠ‚ç‚¹å°†æˆä¸ºé“¾è¡¨çš„ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ã€‚ -addAtTail(val)ï¼šå°†å€¼ä¸º val çš„èŠ‚ç‚¹è¿½åŠ åˆ°é“¾è¡¨çš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚ -addAtIndex(index,val)ï¼šåœ¨é“¾è¡¨ä¸­çš„ç¬¬ index ä¸ªèŠ‚ç‚¹ä¹‹å‰æ·»åŠ å€¼ä¸º val çš„èŠ‚ç‚¹ã€‚å¦‚æœ index ç­‰äºé“¾è¡¨çš„é•¿åº¦ï¼Œåˆ™è¯¥èŠ‚ç‚¹å°†é™„åŠ åˆ°é“¾è¡¨çš„æœ«å°¾ã€‚å¦‚æœ index å¤§äºé“¾è¡¨é•¿åº¦ï¼Œåˆ™ä¸ä¼šæ’å…¥èŠ‚ç‚¹ã€‚å¦‚æœindexå°äº0ï¼Œåˆ™åœ¨å¤´éƒ¨æ’å…¥èŠ‚ç‚¹ã€‚ -deleteAtIndex(index)ï¼šå¦‚æœç´¢å¼• index æœ‰æ•ˆï¼Œåˆ™åˆ é™¤é“¾è¡¨ä¸­çš„ç¬¬ index ä¸ªèŠ‚ç‚¹ã€‚ # å•é“¾è¡¨ class Node: def __init__(self, val): self.val = val self.next = None class MyLinkedList: def __init__(self): self._head = Node(0) # è™šæ‹Ÿå¤´éƒ¨èŠ‚ç‚¹ self._count = 0 # æ·»åŠ çš„èŠ‚ç‚¹æ•° def get(self, index: int) -&gt; int: &quot;&quot;&quot; Get the value of the index-th node in the linked list. If the index is invalid, return -1. &quot;&quot;&quot; if 0 &lt;= index &lt; self._count: node = self._head for _ in range(index + 1): node = node.next return node.val else: return -1 def addAtHead(self, val: int) -&gt; None: &quot;&quot;&quot; Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. &quot;&quot;&quot; self.addAtIndex(0, val) def addAtTail(self, val: int) -&gt; None: &quot;&quot;&quot; Append a node of value val to the last element of the linked list. &quot;&quot;&quot; self.addAtIndex(self._count, val) def addAtIndex(self, index: int, val: int) -&gt; None: &quot;&quot;&quot; Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. &quot;&quot;&quot; if index &lt; 0: index = 0 elif index &gt; self._count: return # è®¡æ•°ç´¯åŠ  self._count += 1 add_node = Node(val) prev_node, current_node = None, self._head for _ in range(index + 1): prev_node, current_node = current_node, current_node.next else: prev_node.next, add_node.next = add_node, current_node def deleteAtIndex(self, index: int) -&gt; None: &quot;&quot;&quot; Delete the index-th node in the linked list, if the index is valid. &quot;&quot;&quot; if 0 &lt;= index &lt; self._count: # è®¡æ•°-1 self._count -= 1 prev_node, current_node = None, self._head for _ in range(index + 1): prev_node, current_node = current_node, current_node.next else: prev_node.next, current_node.next = current_node.next, None # åŒé“¾è¡¨ # ç›¸å¯¹äºå•é“¾è¡¨, Nodeæ–°å¢äº†prevå±æ€§ class Node: def __init__(self, val): self.val = val self.prev = None self.next = None class MyLinkedList: def __init__(self): self._head, self._tail = Node(0), Node(0) # è™šæ‹ŸèŠ‚ç‚¹ self._head.next, self._tail.prev = self._tail, self._head self._count = 0 # æ·»åŠ çš„èŠ‚ç‚¹æ•° def _get_node(self, index: int) -&gt; Node: # å½“indexå°äº_count//2æ—¶, ä½¿ç”¨_headæŸ¥æ‰¾æ›´å¿«, åä¹‹_tailæ›´å¿« if index &gt;= self._count // 2: # ä½¿ç”¨prevå¾€å‰æ‰¾ node = self._tail for _ in range(self._count - index): node = node.prev else: # ä½¿ç”¨nextå¾€åæ‰¾ node = self._head for _ in range(index + 1): node = node.next return node def get(self, index: int) -&gt; int: &quot;&quot;&quot; Get the value of the index-th node in the linked list. If the index is invalid, return -1. &quot;&quot;&quot; if 0 &lt;= index &lt; self._count: node = self._get_node(index) return node.val else: return -1 def addAtHead(self, val: int) -&gt; None: &quot;&quot;&quot; Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. &quot;&quot;&quot; self._update(self._head, self._head.next, val) def addAtTail(self, val: int) -&gt; None: &quot;&quot;&quot; Append a node of value val to the last element of the linked list. &quot;&quot;&quot; self._update(self._tail.prev, self._tail, val) def addAtIndex(self, index: int, val: int) -&gt; None: &quot;&quot;&quot; Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. &quot;&quot;&quot; if index &lt; 0: index = 0 elif index &gt; self._count: return node = self._get_node(index) self._update(node.prev, node, val) def _update(self, prev: Node, next: Node, val: int) -&gt; None: &quot;&quot;&quot; æ›´æ–°èŠ‚ç‚¹ :param prev: ç›¸å¯¹äºæ›´æ–°çš„å‰ä¸€ä¸ªèŠ‚ç‚¹ :param next: ç›¸å¯¹äºæ›´æ–°çš„åä¸€ä¸ªèŠ‚ç‚¹ :param val: è¦æ·»åŠ çš„èŠ‚ç‚¹å€¼ &quot;&quot;&quot; # è®¡æ•°ç´¯åŠ  self._count += 1 node = Node(val) prev.next, next.prev = node, node node.prev, node.next = prev, next def deleteAtIndex(self, index: int) -&gt; None: &quot;&quot;&quot; Delete the index-th node in the linked list, if the index is valid. &quot;&quot;&quot; if 0 &lt;= index &lt; self._count: node = self._get_node(index) # è®¡æ•°-1 self._count -= 1 node.prev.next, node.next.prev = node.next, node.prev ä»£ç éšæƒ³å½•ï¼šcarlsun-2 åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ è¿™ä¸ªç®—æ³•çš„é€»è¾‘ç±»ä¼¼äºæ‹‰æ‹‰é“¾ï¼Œä¸¤ä¸ªéœ€è¦åˆå¹¶çš„å•é“¾è¡¨ï¼Œç±»ä¼¼äºæ‹‰é“¾ä¸¤ä¾§çš„é”¯é½¿ï¼ŒæŒ‡é’ˆ p å°±å¥½åƒæ‹‰é“¾çš„æ‹‰ç´¢ï¼Œå°†ä¸¤ä¸ªæœ‰åºé“¾è¡¨åˆå¹¶ï¼›è¿‡ç¨‹ä¸è›‹ç™½è´¨çš„å½¢æˆè¿‡ç¨‹é«˜åº¦ç›¸ä¼¼ã€‚ï¼ˆé«˜ä¸­ç”Ÿç‰©çŸ¥è¯†çš„å¤ä¹ ï¼‰ è¿ç”¨çš„æŠ€å·§ï¼šä»£ç ä¸­è¿˜ç”¨åˆ°ä¸€ä¸ªé“¾è¡¨çš„ç®—æ³•é¢˜ä¸­æ˜¯å¾ˆå¸¸è§çš„ã€Œè™šæ‹Ÿå¤´ç»“ç‚¹ã€æŠ€å·§ï¼Œä¹Ÿå°±æ˜¯ dummy èŠ‚ç‚¹ã€‚å¦‚æœä¸ä½¿ç”¨ dummy è™šæ‹ŸèŠ‚ç‚¹ï¼Œä»£ç ä¼šå¤æ‚å¾ˆå¤šï¼Œè€Œæœ‰äº† dummy èŠ‚ç‚¹è¿™ä¸ªå ä½ç¬¦ï¼Œå¯ä»¥é¿å…å¤„ç†ç©ºæŒ‡é’ˆçš„æƒ…å†µï¼Œé™ä½ä»£ç çš„å¤æ‚æ€§ã€‚ //javaå®ç° class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { // è™šæ‹Ÿå¤´ç»“ç‚¹ ListNode dummy = new ListNode(-1), p = dummy; ListNode p1 = l1, p2 = l2; while (p1 != null &amp;&amp; p2 != null) { // æ¯”è¾ƒ p1 å’Œ p2 ä¸¤ä¸ªæŒ‡é’ˆ // å°†å€¼è¾ƒå°çš„çš„èŠ‚ç‚¹æ¥åˆ° p æŒ‡é’ˆ if (p1.val &gt; p2.val) { p.next = p2; p2 = p2.next; } else { p.next = p1; p1 = p1.next; } // p æŒ‡é’ˆä¸æ–­å‰è¿› p = p.next; } if (p1 != null) { p.next = p1; } if (p2 != null) { p.next = p2; } return dummy.next; } } è¿ç”¨é€’å½’æ–¹æ³•å®ç°åˆå¹¶ï¼šç¨‹åºçš„å¯è¯»æ€§é™ä½ï¼Œä½†ä»£ç æ›´ç®€æ´â€”â€”é€’å½’æ€æƒ³ååºæ€»ç»“ï¼Œéœ€è¦æŒæ¡å¥½ï¼ # Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def mergeTwoLists(self, list1, list2): &quot;&quot;&quot; :type list1: Optional[ListNode] :type list2: Optional[ListNode] :rtype: Optional[ListNode] &quot;&quot;&quot; if not list1: return list2 if not list2: return list1 if(list1.val &lt;= list2.val): #é€’å½’æ ¸å¿ƒ list1.next = self.mergeTwoLists(list1.next,list2) return list1 else: #é€’å½’æ ¸å¿ƒ list2.next = self.mergeTwoLists(list1,list2.next) return list2 é“¾è¡¨çš„åˆ†è§£ åœ¨åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨æ—¶è®©ä½ åˆäºŒä¸ºä¸€ï¼Œè€Œè¿™é‡Œéœ€è¦åˆ†è§£è®©ä½ æŠŠåŸé“¾è¡¨ä¸€åˆ†ä¸ºäºŒã€‚å…·ä½“æ¥è¯´ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠåŸé“¾è¡¨åˆ†æˆä¸¤ä¸ªå°é“¾è¡¨ï¼Œä¸€ä¸ªé“¾è¡¨ä¸­çš„å…ƒç´ å¤§å°éƒ½å°äº xï¼Œå¦ä¸€ä¸ªé“¾è¡¨ä¸­çš„å…ƒç´ éƒ½å¤§äºç­‰äº xï¼Œæœ€åå†æŠŠè¿™ä¸¤æ¡é“¾è¡¨æ¥åˆ°ä¸€èµ·ï¼Œå°±å¾—åˆ°äº†é¢˜ç›®æƒ³è¦çš„ç»“æœã€‚ 3ã€åˆå¹¶ k ä¸ªæœ‰åºé“¾è¡¨ åˆå¹¶ k ä¸ªæœ‰åºé“¾è¡¨çš„é€»è¾‘ç±»ä¼¼åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ï¼Œéš¾ç‚¹åœ¨äºï¼Œå¦‚ä½•å¿«é€Ÿå¾—åˆ° k ä¸ªèŠ‚ç‚¹ä¸­çš„æœ€å°èŠ‚ç‚¹ï¼Œæ¥åˆ°ç»“æœé“¾è¡¨ä¸Šï¼Ÿ è¿™é‡Œæˆ‘ä»¬å°±è¦ç”¨åˆ° ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼ˆäºŒå‰å †ï¼‰ è¿™ç§æ•°æ®ç»“æ„ï¼ŒæŠŠé“¾è¡¨èŠ‚ç‚¹æ”¾å…¥ä¸€ä¸ªæœ€å°å †ï¼Œå°±å¯ä»¥æ¯æ¬¡è·å¾— k ä¸ªèŠ‚ç‚¹ä¸­çš„æœ€å°èŠ‚ç‚¹ï¼š ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) return null; // è™šæ‹Ÿå¤´ç»“ç‚¹ ListNode dummy = new ListNode(-1); ListNode p = dummy; // ä¼˜å…ˆçº§é˜Ÿåˆ—ï¼Œæœ€å°å † PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;( lists.length, (a, b)-&gt;(a.val - b.val)); // å°† k ä¸ªé“¾è¡¨çš„å¤´ç»“ç‚¹åŠ å…¥æœ€å°å † for (ListNode head : lists) { if (head != null) pq.add(head); } while (!pq.isEmpty()) { // è·å–æœ€å°èŠ‚ç‚¹ï¼Œæ¥åˆ°ç»“æœé“¾è¡¨ä¸­ ListNode node = pq.poll(); p.next = node; if (node.next != null) { pq.add(node.next); } // p æŒ‡é’ˆä¸æ–­å‰è¿› p = p.next; } return dummy.next; } è¿™ä¸ªç®—æ³•æ˜¯é¢è¯•å¸¸è€ƒé¢˜ï¼Œå®ƒçš„æ—¶é—´å¤æ‚åº¦: ä¼˜å…ˆé˜Ÿåˆ— pq ä¸­çš„å…ƒç´ ä¸ªæ•°æœ€å¤šæ˜¯ kï¼Œæ‰€ä»¥ä¸€æ¬¡ poll æˆ–è€… add æ–¹æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(logk)ï¼›æ‰€æœ‰çš„é“¾è¡¨èŠ‚ç‚¹éƒ½ä¼šè¢«åŠ å…¥å’Œå¼¹å‡º pqï¼Œæ‰€ä»¥ç®—æ³•æ•´ä½“çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(Nlogk)ï¼Œå…¶ä¸­ k æ˜¯é“¾è¡¨çš„æ¡æ•°ï¼ŒN æ˜¯è¿™äº›é“¾è¡¨çš„èŠ‚ç‚¹æ€»æ•°ã€‚ å¯»æ‰¾å•é“¾è¡¨çš„ä¸­ç‚¹ åŠ›æ‰£ç¬¬ 876 é¢˜ã€Œ é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹ã€å°±æ˜¯è¿™ä¸ªé¢˜ç›®ï¼Œé—®é¢˜çš„å…³é”®ä¹Ÿåœ¨äºæˆ‘ä»¬æ— æ³•ç›´æ¥å¾—åˆ°å•é“¾è¡¨çš„é•¿åº¦ nï¼Œå¸¸è§„æ–¹æ³•ä¹Ÿæ˜¯å…ˆéå†é“¾è¡¨è®¡ç®— nï¼Œå†éå†ä¸€æ¬¡å¾—åˆ°ç¬¬ n / 2 ä¸ªèŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯ä¸­é—´èŠ‚ç‚¹ã€‚ å¦‚æœæƒ³ä¸€æ¬¡éå†å°±å¾—åˆ°ä¸­é—´èŠ‚ç‚¹ï¼Œä¹Ÿéœ€è¦è€ç‚¹å°èªæ˜ï¼Œä½¿ç”¨ã€Œå¿«æ…¢æŒ‡é’ˆã€çš„æŠ€å·§ï¼š æˆ‘ä»¬è®©ä¸¤ä¸ªæŒ‡é’ˆ slow å’Œ fast åˆ†åˆ«æŒ‡å‘é“¾è¡¨å¤´ç»“ç‚¹ headã€‚ æ¯å½“æ…¢æŒ‡é’ˆ slow å‰è¿›ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆ fast å°±å‰è¿›ä¸¤æ­¥ï¼Œè¿™æ ·ï¼Œå½“ fast èµ°åˆ°é“¾è¡¨æœ«å°¾æ—¶ï¼Œslow å°±æŒ‡å‘äº†é“¾è¡¨ä¸­ç‚¹ã€‚ # Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def middleNode(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; #å¿«æ…¢æŒ‡é’ˆåˆå§‹åŒ–æŒ‡å‘ head slow = head fast = head while(fast != None and fast.next != None): slow = slow.next fast = fast.next.next return slow å¯»æ‰¾å•é“¾è¡¨çš„å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹ ä»¥ä¸‹æ˜¯ä¸œå“¥æ–‡ç« ä¸­çš„è¯¦ç»†è§£é¢˜æ€è·¯ï¼š ä»å‰å¾€åå¯»æ‰¾å•é“¾è¡¨çš„ç¬¬ k ä¸ªèŠ‚ç‚¹å¾ˆç®€å•ï¼Œä¸€ä¸ª for å¾ªç¯éå†è¿‡å»å°±æ‰¾åˆ°äº†ï¼Œä½†æ˜¯å¦‚ä½•å¯»æ‰¾ä»åå¾€å‰æ•°çš„ç¬¬ k ä¸ªèŠ‚ç‚¹å‘¢ï¼Ÿ é‚£ä½ å¯èƒ½è¯´ï¼Œå‡è®¾é“¾è¡¨æœ‰ n ä¸ªèŠ‚ç‚¹ï¼Œå€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹å°±æ˜¯æ­£æ•°ç¬¬ n - k + 1 ä¸ªèŠ‚ç‚¹ï¼Œä¸ä¹Ÿæ˜¯ä¸€ä¸ª for å¾ªç¯çš„äº‹å„¿å—ï¼Ÿ æ˜¯çš„ï¼Œä½†æ˜¯ç®—æ³•é¢˜ä¸€èˆ¬åªç»™ä½ ä¸€ä¸ª ListNode å¤´ç»“ç‚¹ä»£è¡¨ä¸€æ¡å•é“¾è¡¨ï¼Œä½ ä¸èƒ½ç›´æ¥å¾—å‡ºè¿™æ¡é“¾è¡¨çš„é•¿åº¦ nï¼Œè€Œéœ€è¦å…ˆéå†ä¸€éé“¾è¡¨ç®—å‡º n çš„å€¼ï¼Œç„¶åå†éå†é“¾è¡¨è®¡ç®—ç¬¬ n - k + 1 ä¸ªèŠ‚ç‚¹ã€‚ ä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™ä¸ªè§£æ³•éœ€è¦éå†ä¸¤æ¬¡é“¾è¡¨æ‰èƒ½å¾—åˆ°å‡ºå€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹ é‚£ä¹ˆï¼Œæˆ‘ä»¬èƒ½ä¸èƒ½åªéå†ä¸€æ¬¡é“¾è¡¨ï¼Œå°±ç®—å‡ºå€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹ï¼Ÿå¯ä»¥åšåˆ°çš„ï¼Œå¦‚æœæ˜¯é¢è¯•é—®åˆ°è¿™é“é¢˜ï¼Œé¢è¯•å®˜è‚¯å®šä¹Ÿæ˜¯å¸Œæœ›ä½ ç»™å‡ºåªéœ€éå†ä¸€æ¬¡é“¾è¡¨çš„è§£æ³•ã€‚ è¿™ä¸ªè§£æ³•å°±æ¯”è¾ƒå·§å¦™äº†ï¼Œå‡è®¾ k = 2ï¼Œæ€è·¯å¦‚ä¸‹ï¼š é¦–å…ˆï¼Œæˆ‘ä»¬å…ˆè®©ä¸€ä¸ªæŒ‡é’ˆ p1 æŒ‡å‘é“¾è¡¨çš„å¤´èŠ‚ç‚¹ headï¼Œç„¶åèµ° k æ­¥ï¼š ç°åœ¨çš„ p1ï¼Œåªè¦å†èµ° n - k æ­¥ï¼Œå°±èƒ½èµ°åˆ°é“¾è¡¨æœ«å°¾çš„ç©ºæŒ‡é’ˆäº†å¯¹å§ï¼Ÿ è¶è¿™ä¸ªæ—¶å€™ï¼Œå†ç”¨ä¸€ä¸ªæŒ‡é’ˆ p2 æŒ‡å‘é“¾è¡¨å¤´èŠ‚ç‚¹ headï¼š æ¥ä¸‹æ¥å°±å¾ˆæ˜¾ç„¶äº†ï¼Œè®© p1 å’Œ p2 åŒæ—¶å‘å‰èµ°ï¼Œp1 èµ°åˆ°é“¾è¡¨æœ«å°¾çš„ç©ºæŒ‡é’ˆæ—¶å‰è¿›äº† n - k æ­¥ï¼Œp2 ä¹Ÿä» head å¼€å§‹å‰è¿›äº† n - k æ­¥ï¼Œåœç•™åœ¨ç¬¬ n - k + 1 ä¸ªèŠ‚ç‚¹ä¸Šï¼Œå³æ°å¥½åœé“¾è¡¨çš„å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹ä¸Šï¼š è¿™æ ·ï¼Œåªéå†äº†ä¸€æ¬¡é“¾è¡¨ï¼Œå°±è·å¾—äº†å€’æ•°ç¬¬ k ä¸ªèŠ‚ç‚¹ p2ã€‚ ä¸œå“¥å¾ˆè¯¦ç»†åœ°è¯´äº†ä¸€å¤§å †ï¼Œå…¶å®ç®€å•æ€»ç»“èµ·æ¥å°±æ˜¯ï¼šå…ˆåˆ©ç”¨forå¾ªç¯è®©å¿«æŒ‡é’ˆå…ˆèµ°kæ­¥ï¼Œåœ¨åˆ©ç”¨ä¸Šé¢˜å¯»æ‰¾ä¸­ç‚¹æ€è·¯å³å¯è§£å†³ã€‚ # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def getKthFromEnd(self, head, k): &quot;&quot;&quot; :type head: ListNode :type k: int :rtype: ListNode &quot;&quot;&quot; slow = head fast = head #å…ˆè®©å¿«æŒ‡é’ˆfastå‘å‰èµ°kæ­¥ for i in range(k): fast = fast.next #while(fast != None and fast.next != None)å¤šåŠ ä¸€ä¸ªfastçš„nextçš„ç»“æœä¸º[3,4,5]ä¸åŸé¢˜ç»“æœä¸ç¬¦åˆ;æ³¨æ„æ¡ä»¶æ§åˆ¶ while(fast != None): slow = slow.next fast = fast.next return slow åˆ¤æ–­å•é“¾è¡¨æ˜¯å¦åŒ…å«ç¯å¹¶æ‰¾å‡ºç¯èµ·ç‚¹ ç»å…¸é—®é¢˜çš„è§£å†³æ–¹æ¡ˆä»ç„¶æ˜¯ï¼šå¿«æ…¢æŒ‡é’ˆã€‚æ¯å½“æ…¢æŒ‡é’ˆ slow å‰è¿›ä¸€æ­¥ï¼Œå¿«æŒ‡é’ˆ fast å°±å‰è¿›ä¸¤æ­¥ã€‚ å¦‚æœ fast æœ€ç»ˆé‡åˆ°ç©ºæŒ‡é’ˆï¼Œè¯´æ˜é“¾è¡¨ä¸­æ²¡æœ‰ç¯ï¼›å¦‚æœ fast æœ€ç»ˆå’Œ slow ç›¸é‡ï¼Œé‚£è‚¯å®šæ˜¯ fast è¶…è¿‡äº† slow ä¸€åœˆï¼Œè¯´æ˜é“¾è¡¨ä¸­å«æœ‰ç¯ã€‚åªéœ€è¦æŠŠå¯»æ‰¾é“¾è¡¨ä¸­ç‚¹çš„ä»£ç ç¨åŠ ä¿®æ”¹å°±è¡Œäº†ï¼š # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def hasCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; slow = head fast = head #å¯»æ‰¾ä¸­ç‚¹çš„å¥—è·¯ while(fast != None and fast.next != None): #å¿«æŒ‡é’ˆå‰è¿›ä¸¤æ­¥ fast = head.next.next #æ…¢æŒ‡é’ˆå‰è¿›ä¸€æ­¥ slow = head.next #å½“å¿«æŒ‡é’ˆæ¯”æ…¢æŒ‡é’ˆå¤šèµ°ä¸€åœˆæ—¶ï¼Œç›¸é‡ä¾¿æˆç¯ if(fast == slow): return True return False #ä¸çŸ¥é“ä¸ºå•¥è¿™ä¸ªä»£ç æ€»æ˜¯è¿è¡Œè¶…æ—¶ï¼Œæ˜¯æ—¶é—´å¤æ‚åº¦å¤ªå¤§å—ï¼Ÿ-2022.06.21 åˆ¤æ–­ä¸¤ä¸ªå•é“¾è¡¨æ˜¯å¦ç›¸äº¤å¹¶æ‰¾å‡ºäº¤ç‚¹ å¦‚æœç”¨ä¸¤ä¸ªæŒ‡é’ˆ p1 å’Œ p2 åˆ†åˆ«åœ¨ä¸¤æ¡é“¾è¡¨ä¸Šå‰è¿›ï¼Œå¹¶ä¸èƒ½åŒæ—¶èµ°åˆ°å…¬å…±èŠ‚ç‚¹ï¼Œä¹Ÿå°±æ— æ³•å¾—åˆ°ç›¸äº¤èŠ‚ç‚¹ c1ã€‚ è§£å†³è¿™ä¸ªé—®é¢˜çš„å…³é”®æ˜¯ï¼Œé€šè¿‡æŸäº›æ–¹å¼ï¼Œè®© p1 å’Œ p2 èƒ½å¤ŸåŒæ—¶åˆ°è¾¾ç›¸äº¤èŠ‚ç‚¹ c1ã€‚ æ‰€ä»¥ï¼Œæˆ‘ä»¬å¯ä»¥è®© p1 éå†å®Œé“¾è¡¨ A ä¹‹åå¼€å§‹éå†é“¾è¡¨ Bï¼Œè®© p2 éå†å®Œé“¾è¡¨ B ä¹‹åå¼€å§‹éå†é“¾è¡¨ Aï¼Œè¿™æ ·ç›¸å½“äºã€Œé€»è¾‘ä¸Šã€ä¸¤æ¡é“¾è¡¨æ¥åœ¨äº†ä¸€èµ·ã€‚ å¦‚æœè¿™æ ·è¿›è¡Œæ‹¼æ¥ï¼Œå°±å¯ä»¥è®© p1 å’Œ p2 åŒæ—¶è¿›å…¥å…¬å…±éƒ¨åˆ†ï¼Œä¹Ÿå°±æ˜¯åŒæ—¶åˆ°è¾¾ç›¸äº¤èŠ‚ç‚¹ c1 # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def getIntersectionNode(self, headA, headB): &quot;&quot;&quot; :type head1, head1: ListNode :rtype: ListNode &quot;&quot;&quot; p1 = headA p2 = headB while(p1 != p2): #p1 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° A é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° B é“¾è¡¨ if(p1 == None): p1 = headB else: p1 = p1.next #p2 èµ°ä¸€æ­¥ï¼Œå¦‚æœèµ°åˆ° B é“¾è¡¨æœ«å°¾ï¼Œè½¬åˆ° A é“¾è¡¨ if(p2 == None): p2 = headA else: p2 = p2.next return p1 æ»‘åŠ¨çª—å£ åŒæŒ‡é’ˆè¿ç”¨æœ€éš¾å¾—éƒ¨åˆ†ï¼ LeetCode åŠ›æ‰£ éš¾åº¦ 3. Longest Substring Without Repeating Characters 3. æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸² ğŸŸ  438. Find All Anagrams in a String 438. æ‰¾åˆ°å­—ç¬¦ä¸²ä¸­æ‰€æœ‰å­—æ¯å¼‚ä½è¯ ğŸŸ  567. Permutation in String 567. å­—ç¬¦ä¸²çš„æ’åˆ— ğŸŸ  76. Minimum Window Substring 76. æœ€å°è¦†ç›–å­ä¸² ğŸ”´ - å‰‘æŒ‡ Offer 48. æœ€é•¿ä¸å«é‡å¤å­—ç¬¦çš„å­å­—ç¬¦ä¸² ğŸŸ  - å‰‘æŒ‡ Offer II 014. å­—ç¬¦ä¸²ä¸­çš„å˜ä½è¯ ğŸŸ  - å‰‘æŒ‡ Offer II 015. å­—ç¬¦ä¸²ä¸­çš„æ‰€æœ‰å˜ä½è¯ ğŸŸ  - å‰‘æŒ‡ Offer II 016. ä¸å«é‡å¤å­—ç¬¦çš„æœ€é•¿å­å­—ç¬¦ä¸² ğŸŸ  - å‰‘æŒ‡ Offer II 017. å«æœ‰æ‰€æœ‰å­—ç¬¦çš„æœ€çŸ­å­—ç¬¦ä¸² ğŸ”´ é¢˜ç›®ç‰¹ç‚¹ï¼š æœ€é•¿/æœ€çŸ­-&gt;å­æ•°ç»„ã€å­åºåˆ—ã€å­ä¸² è§£å†³ä¸€ç±»æœ€éš¾æŒæ¡çš„åŒæŒ‡é’ˆæŠ€å·§ï¼šæ»‘åŠ¨çª—å£æŠ€å·§ï¼›è¿™ä¸ªç®—æ³•æŠ€å·§çš„æ€è·¯éå¸¸ç®€å•ï¼Œå°±æ˜¯ç»´æŠ¤ä¸€ä¸ªçª—å£ï¼Œä¸æ–­æ»‘åŠ¨ï¼Œç„¶åæ›´æ–°ç­”æ¡ˆã€‚ è¿™ä¸ªç®—æ³•æŠ€å·§çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(N)ï¼Œæ¯”å­—ç¬¦ä¸²æš´åŠ›ç®—æ³•è¦é«˜æ•ˆå¾—å¤šã€‚ å…¶å®å›°æ‰°å¤§å®¶çš„ï¼Œä¸æ˜¯ç®—æ³•çš„æ€è·¯ï¼Œè€Œæ˜¯å„ç§ç»†èŠ‚é—®é¢˜ã€‚æ¯”å¦‚è¯´å¦‚ä½•å‘çª—å£ä¸­æ·»åŠ æ–°å…ƒç´ ï¼Œå¦‚ä½•ç¼©å°çª—å£ï¼Œåœ¨çª—å£æ»‘åŠ¨çš„å“ªä¸ªé˜¶æ®µæ›´æ–°ç»“æœã€‚å³ä¾¿ä½ æ˜ç™½äº†è¿™äº›ç»†èŠ‚ï¼Œä¹Ÿå®¹æ˜“å‡º bugï¼Œæ‰¾ bug è¿˜ä¸çŸ¥é“æ€ä¹ˆæ‰¾ï¼ŒçœŸçš„æŒºè®©äººå¿ƒçƒ¦çš„ã€‚ æ¡†æ¶ï¼š /* æ»‘åŠ¨çª—å£ç®—æ³•æ¡†æ¶ */ void slidingWindow(string s) { unordered_map&lt;char, int&gt; window; int left = 0, right = 0; while (right &lt; s.size()) { // c æ˜¯å°†ç§»å…¥çª—å£çš„å­—ç¬¦ char c = s[right]; // å¢å¤§çª—å£ right++; // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–° ... /*** debug è¾“å‡ºçš„ä½ç½® ***/ printf(&quot;window: [%d, %d)\\n&quot;, left, right); /********************/ // åˆ¤æ–­å·¦ä¾§çª—å£æ˜¯å¦è¦æ”¶ç¼© while (window needs shrink) { // d æ˜¯å°†ç§»å‡ºçª—å£çš„å­—ç¬¦ char d = s[left]; // ç¼©å°çª—å£ left++; // è¿›è¡Œçª—å£å†…æ•°æ®çš„ä¸€ç³»åˆ—æ›´æ–° ... } } } å…¶ä¸­ä¸¤å¤„ ... è¡¨ç¤ºçš„æ›´æ–°çª—å£æ•°æ®çš„åœ°æ–¹ï¼Œåˆ°æ—¶å€™ä½ ç›´æ¥å¾€é‡Œé¢å¡«å°±è¡Œäº†ï¼›è€Œä¸”ï¼Œè¿™ä¸¤ä¸ª ... å¤„çš„æ“ä½œåˆ†åˆ«æ˜¯æ‰©å¤§å’Œç¼©å°çª—å£çš„æ›´æ–°æ“ä½œã€‚ åœ¨å¤„ç†å­—ç¬¦ä¸²åé¢ï¼Œc/c++è¦æ¯”Javaæœ‰ä¼˜åŠ¿ã€‚ æ»‘åŠ¨çª—å£ç®—æ³•çš„æ€è·¯ï¼š 1ã€æˆ‘ä»¬åœ¨å­—ç¬¦ä¸² S ä¸­ä½¿ç”¨åŒæŒ‡é’ˆä¸­çš„å·¦å³æŒ‡é’ˆæŠ€å·§ï¼Œåˆå§‹åŒ– left = right = 0ï¼ŒæŠŠç´¢å¼•å·¦é—­å³å¼€åŒºé—´ [left, right) ç§°ä¸ºä¸€ä¸ªã€Œçª—å£ã€ã€‚ PSï¼šç†è®ºä¸Šä½ å¯ä»¥è®¾è®¡ä¸¤ç«¯éƒ½å¼€æˆ–è€…ä¸¤ç«¯éƒ½é—­çš„åŒºé—´ï¼Œä½†è®¾è®¡ä¸ºå·¦é—­å³å¼€åŒºé—´æ˜¯æœ€æ–¹ä¾¿å¤„ç†çš„ã€‚å› ä¸ºè¿™æ ·åˆå§‹åŒ– left = right = 0 æ—¶åŒºé—´ [0, 0) ä¸­æ²¡æœ‰å…ƒç´ ï¼Œä½†åªè¦è®© right å‘å³ç§»åŠ¨ï¼ˆæ‰©å¤§ï¼‰ä¸€ä½ï¼ŒåŒºé—´ [0, 1) å°±åŒ…å«ä¸€ä¸ªå…ƒç´  0 äº†ã€‚å¦‚æœä½ è®¾ç½®ä¸ºä¸¤ç«¯éƒ½å¼€çš„åŒºé—´ï¼Œé‚£ä¹ˆè®© right å‘å³ç§»åŠ¨ä¸€ä½åå¼€åŒºé—´ (0, 1) ä»ç„¶æ²¡æœ‰å…ƒç´ ï¼›å¦‚æœä½ è®¾ç½®ä¸ºä¸¤ç«¯éƒ½é—­çš„åŒºé—´ï¼Œé‚£ä¹ˆåˆå§‹åŒºé—´ [0, 0] å°±åŒ…å«äº†ä¸€ä¸ªå…ƒç´ ã€‚è¿™ä¸¤ç§æƒ…å†µéƒ½ä¼šç»™è¾¹ç•Œå¤„ç†å¸¦æ¥ä¸å¿…è¦çš„éº»çƒ¦ã€‚ 2ã€æˆ‘ä»¬å…ˆä¸æ–­åœ°å¢åŠ  right æŒ‡é’ˆæ‰©å¤§çª—å£ [left, right)ï¼Œç›´åˆ°çª—å£ä¸­çš„å­—ç¬¦ä¸²ç¬¦åˆè¦æ±‚ï¼ˆåŒ…å«äº† T ä¸­çš„æ‰€æœ‰å­—ç¬¦ï¼‰ã€‚ 3ã€æ­¤æ—¶ï¼Œæˆ‘ä»¬åœæ­¢å¢åŠ  rightï¼Œè½¬è€Œä¸æ–­å¢åŠ  left æŒ‡é’ˆç¼©å°çª—å£ [left, right)ï¼Œç›´åˆ°çª—å£ä¸­çš„å­—ç¬¦ä¸²ä¸å†ç¬¦åˆè¦æ±‚ï¼ˆä¸åŒ…å« T ä¸­çš„æ‰€æœ‰å­—ç¬¦äº†ï¼‰ã€‚åŒæ—¶ï¼Œæ¯æ¬¡å¢åŠ  leftï¼Œæˆ‘ä»¬éƒ½è¦æ›´æ–°ä¸€è½®ç»“æœã€‚ 4ã€é‡å¤ç¬¬ 2 å’Œç¬¬ 3 æ­¥ï¼Œç›´åˆ° right åˆ°è¾¾å­—ç¬¦ä¸² S çš„å°½å¤´ã€‚ è¿™ä¸ªæ€è·¯å…¶å®ä¹Ÿä¸éš¾ï¼Œç¬¬ 2 æ­¥ç›¸å½“äºåœ¨å¯»æ‰¾ä¸€ä¸ªã€Œå¯è¡Œè§£ã€ï¼Œç„¶åç¬¬ 3 æ­¥åœ¨ä¼˜åŒ–è¿™ä¸ªã€Œå¯è¡Œè§£ã€ï¼Œæœ€ç»ˆæ‰¾åˆ°æœ€ä¼˜è§£ï¼Œä¹Ÿå°±æ˜¯æœ€çŸ­çš„è¦†ç›–å­ä¸²ã€‚å·¦å³æŒ‡é’ˆè½®æµå‰è¿›ï¼Œçª—å£å¤§å°å¢å¢å‡å‡ï¼Œçª—å£ä¸æ–­å‘å³æ»‘åŠ¨ï¼Œè¿™å°±æ˜¯ã€Œæ»‘åŠ¨çª—å£ã€è¿™ä¸ªåå­—çš„æ¥å†ã€‚ é•¿åº¦æœ€å°å­æ•°ç»„ ç»™å®šä¸€ä¸ªå«æœ‰ n ä¸ªæ­£æ•´æ•°çš„æ•°ç»„å’Œä¸€ä¸ªæ­£æ•´æ•° target ã€‚ æ‰¾å‡ºè¯¥æ•°ç»„ä¸­æ»¡è¶³å…¶å’Œ â‰¥ target çš„é•¿åº¦æœ€å°çš„ è¿ç»­å­æ•°ç»„ [numsl, numsl+1, ..., numsr-1, numsr] ï¼Œå¹¶è¿”å›å…¶é•¿åº¦ã€‚å¦‚æœä¸å­˜åœ¨ç¬¦åˆæ¡ä»¶çš„å­æ•°ç»„ï¼Œè¿”å› 0 class Solution(object): def minSubArrayLen(self, target, nums): &quot;&quot;&quot; :type target: int :type nums: List[int] :rtype: int &quot;&quot;&quot; #åˆ¤æ–­æç«¯æƒ…å†µ if len(nums) == 0: return 0 #ç¡®å®šæœ€å€¼ res = len(nums) + 1 s = 0 #å®šä¹‰åŒæŒ‡é’ˆ right = left = 0 #æ‰©å¤§çª—å£ while(right &lt; len(nums)): s = s + nums[right] right += 1 #æ¯”è¾ƒç›®æ ‡å€¼ï¼Œæ‰©å¤§çª—å£çš„ç»ˆæ­¢æ¡ä»¶ while s &gt;= target: #righ-leftä¸ºçª—å£å†…çš„å…ƒç´  res = min(res,right-left) #ä»å·¦ä¾§ç¼©å°çª—å£ s = s - nums[left] left += 1 #æ‰€æœ‰å…ƒç´ çš„å’Œå°äºtarget if res == len(nums)+1: return 0 #ç¬¦åˆæ¡ä»¶è¾“å‡º else: return res æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸² class Solution(object): def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; #æç«¯æ¡ä»¶åˆ¤æ–­ if len(s) == 0: return 0 #å®šä¹‰æ‰€éœ€å˜é‡ left = count = res = 0 #éå†åˆ—è¡¨çš„æ—¶é—´å¤æ‚åº¦æ˜¯Oï¼ˆnï¼‰ï¼Œéå†é›†åˆçš„æ—¶é—´å¤æ‚åº¦æ˜¯Oï¼ˆ1ï¼‰ windows = set() #æœ‰æŒ‡é’ˆä¾æ¬¡å‘åéå† for i in range(len(s)): #è®¡æ•° count += 1 #å³æŒ‡é’ˆæŒ‡å‘å…ƒç´ å·²ç»åœ¨çª—å£ä¸­ï¼Œå³å‡ºç°é‡å¤å…ƒç´  while s[i] in windows: #ç¼©å°çª—å£ windows.remove(s[left]) count -= 1 left += 1 #ä¿ç•™æœ€å€¼ res = max(res,count) #çª—å£å³ä¾§åŠ å…¥å…ƒç´  windows.add(s[i]) #è¿”å›ç»“æœ return res ä¹˜ç§¯å°äºKçš„å­æ•°ç»„ class Solution(object): def numSubarrayProductLessThanK(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; #ç‰¹æ®Šæƒ…å†µ if k &lt;= 1: return 0 #åŒæŒ‡é’ˆ left = 0 right = 0 #è®°å½•å™¨ä¸è®¡æ•°å™¨ res = 1 result = 0 #æ‰©å¤§çª—å£ while right &lt; len(nums): res *= nums[right] #ç¼©å°çª—å£ while res &gt;= k: res /= nums[left] left += 1 result += (right-left+1) right += 1 return result æœ€å¤§è¿ç»­1çš„ä¸ªæ•° class Solution: def longestOnes(self, nums: List[int], k: int) -&gt; int: #è®¾ç½®åŒæŒ‡é’ˆ left = 0 right = 0 #è®°å½•å™¨å’Œè®¡æ•°å™¨ res = 0 count = 0 while right &lt; len(nums): #æ‰©å¤§çª—å£ if nums[right] == 0: count += 1 right += 1 #ç¼©å°çª—å£ if count &gt; k: if nums[left] == 0: count -= 1 left += 1 res = max(res,right - left) return res äºŒå‰æ ‘ è§†é¢‘å¯¼å­¦ï¼š äºŒå‰æ ‘/é€’å½’çš„æ¡†æ¶æ€ç»´ï¼ˆçº²é¢†ç¯‡ï¼‰ äºŒå‰æ ‘é¢˜ç›®çš„é€’å½’è§£æ³•å¯ä»¥åˆ†ä¸¤ç±»æ€è·¯ï¼Œç¬¬ä¸€ç±»æ˜¯éå†ä¸€éäºŒå‰æ ‘å¾—å‡ºç­”æ¡ˆï¼Œç¬¬äºŒç±»æ˜¯é€šè¿‡åˆ†è§£é—®é¢˜è®¡ç®—å‡ºç­”æ¡ˆï¼Œè¿™ä¸¤ç±»æ€è·¯åˆ†åˆ«å¯¹åº”ç€ å›æº¯ç®—æ³•æ ¸å¿ƒæ¡†æ¶ å’Œ åŠ¨æ€è§„åˆ’æ ¸å¿ƒæ¡†æ¶ã€‚äºŒå‰æ ‘æ¨¡å‹å‡ ä¹æ˜¯æ‰€æœ‰é«˜çº§ç®—æ³•çš„åŸºç¡€ï¼Œå°¤å…¶æ˜¯é‚£ä¹ˆå¤šäººè¯´å¯¹é€’å½’çš„ç†è§£ä¸åˆ°ä½ï¼Œæ›´åº”è¯¥å¥½å¥½åˆ·äºŒå‰æ ‘ç›¸å…³é¢˜ç›®ã€‚ 2022.08.28æ·»åŠ ï¼šå¯¹äºé€’å½’å‡½æ•°ä¹¦å†™çš„ä¸€äº›æ–°çš„æ€è€ƒä¸å¯å‘ å­¦ä¹ æœ¬éƒ¨åˆ†ä¸»è¦æ˜¯å­¦ä¼šä½¿ç”¨é€’å½’å‡½æ•°çš„ä¹¦å†™é€»è¾‘ï¼š å†æ¬¡æ¸©ä¹ ä¸€ä¸‹ä¹‹å‰å­¦è¿‡çš„é€’å½’ä¸‰éƒ¨æ›²ï¼š 1.é€’å½’å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼çš„è®¾ç½® æ¯”å¦‚åœ¨åœ¨å†™å›æº¯å‡½æ•°æ—¶ï¼Œå‡½æ•°å‚æ•°éœ€è¦è‡ªå·±å»å®šä¹‰ã€‚æ­¤æ—¶å°±è¦è€ƒè™‘ï¼Œé‚£äº›å‚æ•°æ˜¯æˆ‘éœ€è¦çš„ï¼Œé‚£äº›å‚æ•°æ˜¯é¢˜ç›®ä¸­å·²çŸ¥çš„ï¼›è‡ªå®šä¹‰çš„è¿™ä¸ªå‡½æ•°çš„ç±»å‹æ˜¯ä»€ä¹ˆï¼šviodæ³›å‹ï¼Ÿboolå‹ï¼Ÿintå‹ï¼Ÿ void traverse(å‚æ•°1ï¼Œå‚æ•°2....){ } 2.ç»ˆæ­¢æ¡ä»¶ å¤šæ•°æƒ…å†µä¸‹å°±æ˜¯éå†åˆ°æ ‘çš„æ ¹èŠ‚ç‚¹åå¼€å§‹è¿”å›ï¼› if(rooot == NULL){ return; } 3.é€’å½’çš„é€»è¾‘ åœ¨ç»ˆæ­¢æ¡ä»¶ä¹‹åç´§æ¥ç€å°±æ˜¯é€’å½’å‡½æ•°çš„è°ƒç”¨ï¼›ç»å¤§å¤šæ•°é€’å½’çš„é€»è¾‘æ˜¯å‰åºé€»è¾‘ï¼Œé¢˜ç›®è®©å¹²å•¥å’±å°±å¹²å•¥ï¼Œè€Œä¸”é€’å½’çš„é¡ºåºä¸€èˆ¬å°±æ˜¯å…ˆå·¦å­æ ‘åå³å­æ ‘ï¼Œä»ä¸Šåˆ°ä¸‹çš„DFSã€‚ //å‰åºæ“ä½œï¼ˆçœ‹é¢˜ç›®è¦æ±‚ï¼‰ traverse(root-&gt;left,....); traverse(root-&gt;right,....); å¯¹äºå¤§å¤šæ•°çš„ç®—æ³•ï¼Œæš´åŠ›è§£å†³æ˜¯å¯ä»¥çš„ï¼›ä½†æ˜¯æ— æ•°ä¸ªforå¾ªç¯åµŒå¥—æ—¢æµªè´¹æ—¶é—´åˆæµªè´¹ç©ºé—´ï¼Œå½“æƒ…å†µè¾ƒå¤æ‚æ˜¯ï¼Œforå¾ªç¯åµŒå¥—å¿…å®šä¼šå‡ºé”™ã€‚è€Œé€’å½’å›æº¯å‡½æ•°çš„ä¹¦å†™ï¼Œå°±æ˜¯è®©è®¡ç®—æœºè‡ªå·±å»æ·±å¤„éå†è¿­ä»£ï¼Œç©ºé—´æ—¶é—´éƒ½å¯èŠ‚çœï¼Œå¯è°“æ˜¯è®¡ç®—æœºæ€ç»´çš„ç²¾é«“ä¹‹å¤„ã€‚ æ ‘æ—¢æœ‰é€’å½’éå†åˆæœ‰è¿­ä»£éå†ï¼Œåœ¨è¿­ä»£éå†æ—¶ä¸€å®šè¦æ³¨æ„whileå¾ªç¯çš„ç»ˆæ­¢æ¡ä»¶ï¼Œä¸€èˆ¬æ˜¯å½“èŠ‚ç‚¹ä¸ä¸ºç©ºæ—¶ï¼Œç»ˆæ­¢å¾ªç¯whileï¼›å³ï¼šwhile(!=root) äºŒå‰æ ‘-çº²é¢†ç¯‡ LeetCode åŠ›æ‰£ éš¾åº¦ 104. Maximum Depth of Binary Tree 104. äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ ğŸŸ¢ 144. Binary Tree Preorder Traversal 144. äºŒå‰æ ‘çš„å‰åºéå† ğŸŸ¢ 543. Diameter of Binary Tree 543. äºŒå‰æ ‘çš„ç›´å¾„ ğŸŸ¢ - å‰‘æŒ‡ Offer 55 - I. äºŒå‰æ ‘çš„æ·±åº¦ ğŸŸ¢ æ€»çš„è€è¯´ï¼ŒäºŒå‰æ ‘çš„ä¸¤ç§è§£å†³æ€è·¯ï¼š 1.éå†-&gt;å›æº¯é—®é¢˜-&gt;å‰åºæ“ä½œ 2.åˆ†è§£-&gt;åŠ¨è§„é—®é¢˜-&gt;ååºæ“ä½œ é‡åˆ°ä¸€é“äºŒå‰æ ‘çš„é¢˜ç›®æ—¶çš„é€šç”¨æ€è€ƒè¿‡ç¨‹æ˜¯ï¼š 1ã€æ˜¯å¦å¯ä»¥é€šè¿‡éå†ä¸€éäºŒå‰æ ‘å¾—åˆ°ç­”æ¡ˆï¼Ÿå¦‚æœå¯ä»¥ï¼Œç”¨ä¸€ä¸ª traverse å‡½æ•°é…åˆå¤–éƒ¨å˜é‡æ¥å®ç°ã€‚ 2ã€æ˜¯å¦å¯ä»¥å®šä¹‰ä¸€ä¸ªé€’å½’å‡½æ•°ï¼Œé€šè¿‡å­é—®é¢˜ï¼ˆå­æ ‘ï¼‰çš„ç­”æ¡ˆæ¨å¯¼å‡ºåŸé—®é¢˜çš„ç­”æ¡ˆï¼Ÿå¦‚æœå¯ä»¥ï¼Œå†™å‡ºè¿™ä¸ªé€’å½’å‡½æ•°çš„å®šä¹‰ï¼Œå¹¶å……åˆ†åˆ©ç”¨è¿™ä¸ªå‡½æ•°çš„è¿”å›å€¼ã€‚ 3ã€æ— è®ºä½¿ç”¨å“ªä¸€ç§æ€ç»´æ¨¡å¼ï¼Œä½ éƒ½è¦æ˜ç™½äºŒå‰æ ‘çš„æ¯ä¸€ä¸ªèŠ‚ç‚¹éœ€è¦åšä»€ä¹ˆï¼Œéœ€è¦åœ¨ä»€ä¹ˆæ—¶å€™ï¼ˆå‰ä¸­ååºï¼‰åšã€‚ äºŒå‰æ ‘çš„æ¡†æ¶æ€ç»´ï¼š void traverse(TreeNode root) { if (root == null) { return; } // å‰åºä½ç½® traverse(root.left); // ä¸­åºä½ç½® traverse(root.right); // ååºä½ç½® ä»¥æ•°ç»„å’Œé“¾è¡¨ä¸ºä¾‹ï¼Œçœ‹éå†å’Œåˆ†è§£çš„åŒºåˆ«ä¸è”ç³»ï¼š /* è¿­ä»£éå†æ•°ç»„ */ #void traverse(int[] arr) { #for (int i = 0; i &lt; arr.length; i++) { #} #} def traverse(int[] arr): for i in range(len(arr)): /* é€’å½’éå†æ•°ç»„ */ #void traverse(int[] arr, int i) { #if (i == arr.length) { #return; #} #// å‰åºä½ç½® #traverse(arr, i + 1); #// ååºä½ç½® #} def traverse(int[] arr, int i): if (i == len(arr)): return // å‰åºä½ç½® traverse(arr, i + 1); // ååºä½ç½® /* è¿­ä»£éå†å•é“¾è¡¨ */ #void traverse(ListNode head) { #for (ListNode p = head; p != null; p = p.next) { #} #} def traverse(ListNode head): p = head while(p != None and p.next != None): p = p.next /* é€’å½’éå†å•é“¾è¡¨ */ #void traverse(ListNode head) { #if (head == null) { #return; #} #// å‰åºä½ç½® #traverse(head.next); #// ååºä½ç½® #} def traverse(ListNode head): if (head == None): return // å‰åºä½ç½® traverse(head.next); // ååºä½ç½® é€’å½’ä¸‰éƒ¨æ›²ï¼š é€’å½’å‡½æ•°çš„å‚æ•°è¿”å›å€¼ ç»ˆæ­¢æ¡ä»¶ é€’å½’çš„é€»è¾‘ äºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def maxDepth(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; #åˆ†è§£é—®é¢˜ï¼šå…ˆæ‰¾å·¦å³å­æ ‘çš„æœ€å¤§æ·±åº¦ç„¶ååŠ ä¸€-åŠ¨æ€è§„åˆ’æ€è·¯(ååºä½ç½®æ“ä½œ) #é€’å½’åˆ°æ ¹èŠ‚ç‚¹ if(root == None): return 0 leftmax = self.maxDepth(root.left) rightmax = self.maxDepth(root.right) #æ¨åˆ°åŸäºŒå‰æ ‘çš„æœ€å¤§æ·±åº¦ return max(leftmax,rightmax) + 1 #å›æº¯æ€è·¯ class Solution { int depth = 0; int res = 0; public int maxDepth(TreeNode root) { traverse(root); return res; } // éå†äºŒå‰æ ‘ void traverse(TreeNode root) { if (root == null) { return; } // å‰åºéå†ä½ç½® depth++; // éå†çš„è¿‡ç¨‹ä¸­è®°å½•æœ€å¤§æ·±åº¦ res = Math.max(res, depth); traverse(root.left); traverse(root.right); // ååºéå†ä½ç½® depth--; } } äºŒå‰æ ‘æœ€å°æ·±åº¦ # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def minDepth(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; if not root: return 0 if not root.left and not root.right: return 1 min_depth = 10**9 if root.left: min_depth = min(self.minDepth(root.left), min_depth) # è·å¾—å·¦å­æ ‘çš„æœ€å°é«˜åº¦ if root.right: min_depth = min(self.minDepth(root.right), min_depth) # è·å¾—å³å­æ ‘çš„æœ€å°é«˜åº¦ return min_depth + 1 äºŒå‰æ ‘çš„éå† å‰åºéå† é€’å½’è§£æ³• # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right #é€’å½’è§£æ³• class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: def preorder(root: TreeNode): if not root: return res.append(root.val) preorder(root.left) preorder(root.right) res = list() preorder(root) return res # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def preorderTraversal(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[int] &quot;&quot;&quot; #ä¿å­˜ç»“æœ res = [] #å®šä¹‰éå†å‡½æ•° def traversal(root): #æ ¹èŠ‚ç‚¹åˆ¤æ–­ if root == None: return res.append(root.val) traversal(root.left) traversal(root.right) traversal(root) return res è¿­ä»£è§£æ³• class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: res = list() if not root: return res stack = [] node = root while stack or node: while node: res.append(node.val) stack.append(node) node = node.left node = stack.pop() node = node.right return res ä¸­åºéå† # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def inorderTraversal(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[int] &quot;&quot;&quot; #ä¿å­˜ç»“æœ res = [] def traervsal(root): #æ ¹èŠ‚ç‚¹åˆ¤æ–­ if root == None: return #é€’å½’éå† traervsal(root.left) #ä¸­åºæ“ä½œ res.append(root.val) traervsal(root.right) traervsal(root) return res ååºéå† # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def postorderTraversal(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[int] &quot;&quot;&quot; #ä¿å­˜ç»“æœ res = [] #å®šä¹‰éå†å‡½æ•° def traversal(root): if root == None: return traversal(root.left) traversal(root.right) #ååºæ“ä½œ res.append(root.val) traversal(root) return res äºŒå‰æ ‘çš„æœ€å¤§ç›´å¾„ ååºéå† # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def diameterOfBinaryTree(self, root: TreeNode) -&gt; int: self.ans = 1 def depth(node): # è®¿é—®åˆ°ç©ºèŠ‚ç‚¹äº†ï¼Œè¿”å›0 if not node: return 0 # å·¦å­©å­ä¸ºæ ¹çš„å­æ ‘çš„æ·±åº¦ L = depth(node.left) # å³å­©å­ä¸ºæ ¹çš„å­æ ‘çš„æ·±åº¦ R = depth(node.right) # è®¡ç®—d_nodeå³L+R+1 å¹¶æ›´æ–°ans self.ans = max(self.ans, L + R + 1) # è¿”å›è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘çš„æ·±åº¦ return max(L, R) + 1 depth(root) return self.ans - 1 äºŒå‰æ ‘çš„å±‚åºéå† å±‚åºéå†å°±æ˜¯ä»å·¦åˆ°å³ä¸€å±‚ä¸€å±‚å»éå†äºŒå‰æ ‘ã€‚éœ€è¦å€Ÿç”¨ä¸€ä¸ªè¾…åŠ©æ•°æ®ç»“æ„å³é˜Ÿåˆ—æ¥å®ç°ï¼Œé˜Ÿåˆ—å…ˆè¿›å…ˆå‡ºï¼Œç¬¦åˆä¸€å±‚ä¸€å±‚éå†çš„é€»è¾‘ï¼Œè€Œæ˜¯ç”¨æ ˆå…ˆè¿›åå‡ºé€‚åˆæ¨¡æ‹Ÿæ·±åº¦ä¼˜å…ˆéå†ä¹Ÿå°±æ˜¯é€’å½’çš„é€»è¾‘ã€‚è€Œè¿™ç§å±‚åºéå†æ–¹å¼å°±æ˜¯å›¾è®ºä¸­çš„å¹¿åº¦ä¼˜å…ˆéå†ï¼Œåªä¸è¿‡æˆ‘ä»¬åº”ç”¨åœ¨äºŒå‰æ ‘ä¸Š[1] å±‚åºéå† #å±‚åºéå†è¿­ä»£æ³•ï¼š # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def levelOrder(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[List[int]] &quot;&quot;&quot; results = [] if not root: return results from collections import deque que = deque([root]) while que: size = len(que) result = [] for _ in range(size): cur = que.popleft() result.append(cur.val) if cur.left: que.append(cur.left) if cur.right: que.append(cur.right) results.append(result) return results #å±‚åºéå†é€’å½’æ³• # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def levelOrder(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[List[int]] &quot;&quot;&quot; res = [] def cengxu(root,depth): if not root: return [] if len(res) == depth: res.append([]) res[depth].append(root.val) if root.left: cengxu(root.left,depth+1) if root.right: cengxu(root.right,depth+1) cengxu(root,0) return res #[[3],[9,20],[15,7]]æœ€åçš„ç»“æœæ˜¯åˆ—è¡¨çš„åµŒå¥— #è‡ªåº•å‘ä¸Šå±‚åºéå† # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]: #è®°å½•ç»“æœ res = [] #å®šä¹‰å±‚åºéå†å‡½æ•° def cengxu(root,depth): #æ ¹èŠ‚ç‚¹åˆ¤æ–­ if not root: return None #ä¸€å¼€å§‹å¾ˆä¸ç†è§£è¿™ä¸€æ­¥ #è§‚å¯Ÿç»“æœ:[[15,7],[9,20],[3]]ï¼›æ¶‰åŠåˆ°åˆ—è¡¨çš„åµŒå¥— #æ¯å½“æ·±åº¦åŠ ä¸€,å°±è¦å¢åŠ ä¸€ä¸ªå­åˆ—è¡¨ if len(res) == depth: res.append([]) res[depth].append(root.val) if root.left: cengxu(root.left,depth + 1) if root.right: cengxu(root.right,depth + 1) cengxu(root,0) return res[::-1] äºŒå‰æ ‘çš„å³è§†å›¾ # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def rightSideView(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[int] &quot;&quot;&quot; #ç»“æœè®°å½• res = [] #å®šä¹‰å±‚åºéå†å‡½æ•° def cengxu(root,depth): if not root: return None if len(res) == depth: res.append(root.val) #res[depth].append(root.val) #åªå»éå†å³å­æ ‘-å‡†ç¡®æ¥è¯´æ˜¯å»éå†æ¯ä¸ªèŠ‚ç‚¹çš„å³å­æ ‘ if root.right: cengxu(root.right,depth + 1) if root.left: cengxu(root.left,depth + 1) cengxu(root,0) return res è®¡ç®—äºŒå‰æ ‘æ¯å±‚èŠ‚ç‚¹çš„å¹³å‡æ•° # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def averageOfLevels(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[float] &quot;&quot;&quot; #ä¿å­˜ç»“æœ res = [] ans = [] #å®šä¹‰å±‚åºéå†å‡½æ•° def cengxu(root,depth): if not root: return None if len(res) == depth: res.append([]) res[depth].append(root.val) #éå†å·¦å³å­æ ‘ if root.left: cengxu(root.left,depth + 1) if root.right: cengxu(root.right,depth + 1) cengxu(root,0) for i in range(len(res)): sum1 = sum(res[i]) num = len(res[i]) ans.append(sum1 / num) return ans äºŒå‰æ ‘-æ€è·¯ç¯‡ å±‚åºéå†+æ ˆå°±æ˜¯ååºéå†ç»“æœ åˆ·å®Œä¸Šé¢çº²é¢†ç¯‡å¹…çš„ä¸€äº›ä½“ä¼šï¼š äºŒå‰æ ‘é‡è¦çš„éƒ¨åˆ†ï¼šæ¡†æ¶+ç»†èŠ‚ï¼›æ¡†æ¶ä¸»è¦æ˜¯å¯¹é€’å½’å‡½æ•°çš„ä¹¦å†™ï¼Œç»†èŠ‚å°±æ˜¯-å‰åºéå†ORååºéå†-ä»£ç çš„æ‘†æ”¾ä½ç½® LeetCode åŠ›æ‰£ éš¾åº¦ 114. Flatten Binary Tree to Linked List 114. äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨ ğŸŸ  116. Populating Next Right Pointers in Each Node 116. å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ ğŸŸ  226. Invert Binary Tree 226. ç¿»è½¬äºŒå‰æ ‘ ğŸŸ¢ - å‰‘æŒ‡ Offer 27. äºŒå‰æ ‘çš„é•œåƒ ğŸŸ¢ åè½¬äºŒå‰æ ‘ åè½¬çš„æ€æƒ³å°±æ˜¯å€ŸåŠ©tmpæŒ‡é’ˆè¿›è¡Œå·¦å³èŠ‚ç‚¹çš„äº¤æ¢ åˆ†è§£é—®é¢˜æ€è·¯ï¼š # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def invertTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; #åˆ¤æ–­æ ¹èŠ‚ç‚¹ if root == None: return #åˆ†è§£é—®é¢˜çš„æ€è·¯ self.invertTree(root.left) self.invertTree(root.right) tmp = root.left root.left = root.right root.right = tmp return root å›æº¯æ€è·¯ï¼š # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def invertTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; self.traverse(root) return root def traverse(self, root): if root == None: return #å‰åºä½ç½® tmp = root.left root.left = root.right root.right = tmp #éå†æ¡†æ¶ï¼Œå»éå†å·¦å³å­æ ‘çš„èŠ‚ç‚¹ self.traverse(root.left) self.traverse(root.right) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* invertTree(TreeNode* root) { /* //ç»ˆæ­¢èŠ‚ç‚¹åˆ¤æ–­ //ä»ä¸Šåˆ°ä¸‹é€’å½’éå† if(root == NULL) return root; swap(root-&gt;left,root-&gt;right); invertTree(root-&gt;left); invertTree(root-&gt;right); return root; */ //è¿­ä»£éå† if(root == NULL) return root; stack&lt;TreeNode*&gt; st; st.push(root); while(!st.empty()){ TreeNode* node = st.top(); st.pop(); swap(node-&gt;left,node-&gt;right); if(node-&gt;right) st.push(node-&gt;right); if(node-&gt;left) st.push(node-&gt;left); } return root; } }; å¯¹ç§°äºŒå‰æ ‘ # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def isSymmetric(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; if not root: return True return self.compare(root.left, root.right) def compare(self, left, right): #å¯¹ç§°äºŒå‰æ ‘çš„æ¡ä»¶ if left != None and right == None: return False elif left == None and right != None: return False elif left == None and right == None: return True elif left.val != right.val: return False #æ­¤æ—¶å°±æ˜¯å·¦å³èŠ‚ç‚¹ç›¸åŒè¿›å…¥ä¸‹ä¸€å±‚éå† ots = self.compare(left.left,right.right) ins = self.compare(left.right,right.left) isSymmetric = ots and ins return isSymmetric å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ å‰åºéå†ï¼š å‰åºéå†æ—¶è¦å®šä¹‰ä¸€ä¸ªtraverseå‡½æ•°ç”¨äºé€’å½’å‰åºèŠ‚ç‚¹ã€‚ &quot;&quot;&quot; # Definition for a Node. class Node(object): def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next &quot;&quot;&quot; class Solution(object): def connect(self, root): &quot;&quot;&quot; :type root: Node :rtype: Node &quot;&quot;&quot; #æ ¹èŠ‚ç‚¹æƒ…å†µ if root == None: return self.traverse(root.left,root.right) return root def traverse(self,node1,node2): if node1 == None and node2 == None: return #è¿æ¥ä¼ å…¥çš„ä¸¤ä¸ªèŠ‚ç‚¹ node1.next = node2 #å‰åºéå† self.traverse(node1.left,node1.right) self.traverse(node2.left,node2.right) self.traverse(node1.right,node2.left) å°†äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨ é¦–å…ˆé€šè¿‡éå†å¯»æ±‚è§£é¢˜æ€è·¯ï¼šå‘ç°éå†è™½ç„¶å¾—åˆ°äº†å‰åºéå†ç»“æœä½†æ˜¯æ— æ³•æŠŠåŸæ¥çš„äºŒå‰æ ‘æ‹‰å¹³ä¸ºä¸€ä¸ªé“¾è¡¨ å› æ­¤å¯»æ±‚åˆ†è§£é—®é¢˜çš„è§£å†³æ–¹æ³•ï¼šå…ˆæ‹‰å¹³å·¦å­æ ‘ï¼Œåœ¨æ‹‰å¹³å³å­æ ‘ï¼›æœ€åå°†å³å­æ ‘å«æ¥åˆ°å·¦å­æ ‘ä¸Šå³å¯å®Œæˆã€‚ # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def flatten(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: None Do not return anything, modify root in-place instead. &quot;&quot;&quot; #æ ¹èŠ‚ç‚¹æ“ä½œ if root == None: return #æ‹‰å¹³å·¦å³å­æ ‘ self.flatten(root.left) self.flatten(root.right) #ååºæ“ä½œ:åˆ†åˆ«å°†å­æ ‘æ‹‰å¹³ä¸ºé“¾è¡¨ l = root.left r = root.right #å°†å·¦å­æ ‘ä½œä¸ºå³å­æ ‘ root.left = None root.right = l #å°†åŸå…ˆçš„å³å­æ ‘æ¥åˆ°å½“å‰å³å­æ ‘çš„æœ«ç«¯ p = root while(p.right != None): p = p.right p.right = r å·¦å¶å­ä¹‹å’Œ # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def sumOfLeftLeaves(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; #æ ¹èŠ‚ç‚¹åˆ¤æ–­ if not root: return 0 left_left_leaves_sum = self.sumOfLeftLeaves(root.left) # å·¦ right_left_leaves_sum = self.sumOfLeftLeaves(root.right) # å³ cur_val = 0 if root.left and not root.left.left and not root.left.right: cur_val = root.left.val # ä¸­ return cur_val + left_left_leaves_sum + right_left_leaves_sum äºŒå‰æ ‘-æ„é€ ç¯‡ æ¯æ—¥ä¸€éè§£é¢˜æ€è·¯ï¼š äºŒå‰æ ‘è§£é¢˜çš„æ€ç»´æ¨¡å¼åˆ†ä¸¤ç±»ï¼š 1ã€æ˜¯å¦å¯ä»¥é€šè¿‡éå†ä¸€éäºŒå‰æ ‘å¾—åˆ°ç­”æ¡ˆï¼Ÿå¦‚æœå¯ä»¥ï¼Œç”¨ä¸€ä¸ª traverse å‡½æ•°é…åˆå¤–éƒ¨å˜é‡æ¥å®ç°ï¼Œè¿™å«ã€Œéå†ã€çš„æ€ç»´æ¨¡å¼ã€‚ 2ã€æ˜¯å¦å¯ä»¥å®šä¹‰ä¸€ä¸ªé€’å½’å‡½æ•°ï¼Œé€šè¿‡å­é—®é¢˜ï¼ˆå­æ ‘ï¼‰çš„ç­”æ¡ˆæ¨å¯¼å‡ºåŸé—®é¢˜çš„ç­”æ¡ˆï¼Ÿå¦‚æœå¯ä»¥ï¼Œå†™å‡ºè¿™ä¸ªé€’å½’å‡½æ•°çš„å®šä¹‰ï¼Œå¹¶å……åˆ†åˆ©ç”¨è¿™ä¸ªå‡½æ•°çš„è¿”å›å€¼ï¼Œè¿™å«ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€ç»´æ¨¡å¼ã€‚ æ— è®ºä½¿ç”¨å“ªç§æ€ç»´æ¨¡å¼ï¼Œä½ éƒ½éœ€è¦æ€è€ƒï¼š å¦‚æœå•ç‹¬æŠ½å‡ºä¸€ä¸ªäºŒå‰æ ‘èŠ‚ç‚¹ï¼Œå®ƒéœ€è¦åšä»€ä¹ˆäº‹æƒ…ï¼Ÿéœ€è¦åœ¨ä»€ä¹ˆæ—¶å€™ï¼ˆå‰/ä¸­/ååºä½ç½®ï¼‰åšï¼Ÿå…¶ä»–çš„èŠ‚ç‚¹ä¸ç”¨ä½ æ“å¿ƒï¼Œé€’å½’å‡½æ•°ä¼šå¸®ä½ åœ¨æ‰€æœ‰èŠ‚ç‚¹ä¸Šæ‰§è¡Œç›¸åŒçš„æ“ä½œã€‚ äºŒå‰æ ‘çš„æ„é€ é—®é¢˜ä¸€èˆ¬éƒ½æ˜¯ä½¿ç”¨ã€Œåˆ†è§£é—®é¢˜ã€çš„æ€è·¯ï¼šæ„é€ æ•´æ£µæ ‘ = æ ¹èŠ‚ç‚¹ + æ„é€ å·¦å­æ ‘ + æ„é€ å³å­æ ‘ã€‚ æœ€å¤§äºŒå‰æ ‘ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def constructMaximumBinaryTree(self, nums: List[int]) -&gt; TreeNode: if not nums: return None #å…ˆæ‰¾åˆ°æœ€å¤§å€¼ä¸å…¶å¯¹åº”çš„ç´¢å¼• æ ¹èŠ‚ç‚¹ maxvalue = max(nums) index = nums.index(maxvalue) #å°†æœ€å¤§å€¼ç¡®å®šä¸ºçˆ¶èŠ‚ç‚¹ æ ¹èŠ‚ç‚¹ root = TreeNode(maxvalue) #å‰åºæ“ä½œåˆ’åˆ†å·¦å³å­æ ‘ æ„é€ å·¦å­æ ‘ + æ„é€ å³å­æ ‘ left = nums[:index] right = nums[index + 1:] #é€’å½’éå† root.left = self.constructMaximumBinaryTree(left) root.right = self.constructMaximumBinaryTree(right) return root é€šè¿‡å‰åºå’Œä¸­åºéå†ç»“æœæ„é€ äºŒå‰æ ‘ æˆ‘ä»¬è‚¯å®šè¦æƒ³åŠæ³•ç¡®å®šæ ¹èŠ‚ç‚¹çš„å€¼ï¼ŒæŠŠæ ¹èŠ‚ç‚¹åšå‡ºæ¥ï¼Œç„¶åé€’å½’æ„é€ å·¦å³å­æ ‘å³å¯ã€‚ å‰åºéå†å’Œä¸­åºéå†çš„ç»“æœæœ‰ä»€ä¹ˆç‰¹ç‚¹ï¼š void traverse(TreeNode root) { // å‰åºéå† preorder.add(root.val); traverse(root.left); traverse(root.right); } void traverse(TreeNode root) { traverse(root.left); // ä¸­åºéå† inorder.add(root.val); traverse(root.right); æ‰¾åˆ°æ ¹èŠ‚ç‚¹æ˜¯å¾ˆç®€å•çš„ï¼Œå‰åºéå†çš„ç¬¬ä¸€ä¸ªå€¼ preorder[0] å°±æ˜¯æ ¹èŠ‚ç‚¹çš„å€¼ã€‚ å…³é”®åœ¨äºå¦‚ä½•é€šè¿‡æ ¹èŠ‚ç‚¹çš„å€¼ï¼Œå°† preorder å’Œ postorder æ•°ç»„åˆ’åˆ†æˆä¸¤åŠï¼Œæ„é€ æ ¹èŠ‚ç‚¹çš„å·¦å³å­æ ‘ï¼Ÿ æ¢å¥è¯è¯´ï¼Œå¯¹äºä»¥ä¸‹ä»£ç ä¸­çš„ ? éƒ¨åˆ†åº”è¯¥å¡«å…¥ä»€ä¹ˆï¼š /* ä¸»å‡½æ•° */ public TreeNode buildTree(int[] preorder, int[] inorder) { // æ ¹æ®å‡½æ•°å®šä¹‰ï¼Œç”¨ preorder å’Œ inorder æ„é€ äºŒå‰æ ‘ return build(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1); } /* build å‡½æ•°çš„å®šä¹‰ï¼š è‹¥å‰åºéå†æ•°ç»„ä¸º preorder[preStart..preEnd]ï¼Œ ä¸­åºéå†æ•°ç»„ä¸º inorder[inStart..inEnd]ï¼Œ æ„é€ äºŒå‰æ ‘ï¼Œè¿”å›è¯¥äºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ */ TreeNode build(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) { // root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯å‰åºéå†æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´  int rootVal = preorder[preStart]; // rootVal åœ¨ä¸­åºéå†æ•°ç»„ä¸­çš„ç´¢å¼• int index = 0; for (int i = inStart; i &lt;= inEnd; i++) { if (inorder[i] == rootVal) { index = i; break; } } TreeNode root = new TreeNode(rootVal); // é€’å½’æ„é€ å·¦å³å­æ ‘ root.left = build(preorder, ?, ?, inorder, ?, ?); root.right = build(preorder, ?, ?, inorder, ?, ?); return root; } # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def buildTree(self, preorder, inorder): &quot;&quot;&quot; :type preorder: List[int] :type inorder: List[int] :rtype: TreeNode &quot;&quot;&quot; #æ ‘ä¸ºç©ºï¼Œè¿›è¡Œé€’å½’ç»ˆæ­¢ if not preorder: return None #æ‰¾åˆ°å¹¶æ„é€ æ ¹èŠ‚ç‚¹ rootval = preorder[0] root = TreeNode(rootval) #ä»ä¸­åºéå†åˆ‡å‰² index = inorder.index(rootval) inleft = inorder[:index] inright = inorder[index + 1:] #é‡ç‚¹ï¼šåˆ‡å‰²å‰åºæ•°ç»„ï¼šæ³¨æ„å­æ•°ç»„å¤§å°ä¸€å®šä¿æŒä¸å˜ preleft = preorder[1:1+len(inleft)] preright = preorder[len(inleft)+1:] #é€’å½’ root.left = self.buildTree(preleft,inleft) root.right = self.buildTree(preright,inright) return root ä»ä¸­åºä¸ååºéå†åºåˆ—æ„é€ äºŒå‰æ ‘ # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def buildTree(self, inorder, postorder): &quot;&quot;&quot; :type inorder: List[int] :type postorder: List[int] :rtype: TreeNode &quot;&quot;&quot; #ç‰¹æ®Šæƒ…å†µåˆ¤æ–­ if not postorder: return None #æ‰¾åˆ°å¹¶æ„å»ºæ ¹èŠ‚ç‚¹ rootval = postorder[-1] root = TreeNode(rootval) #ä¸­åºæ•°ç»„åœ¨ç¡®å®šä½ç½®å¹¶åˆ‡å‰²æ•°ç»„ index = inorder.index(rootval) inleft = inorder[:index] inright = inorder[index+1:] #é‡ç‚¹æ˜¯ååºæ•°ç»„åˆ‡å‰²å¤§å° poleft = postorder[:len(inleft)] poright = postorder[len(inleft):len(postorder)-1] #é€’å½’ root.left = self.buildTree(inleft,poleft) root.right = self.buildTree(inright,poright) return root å®Œå…¨äºŒå‰æ ‘èŠ‚ç‚¹ä¸ªæ•° class Solution: def countNodes(self, root: TreeNode) -&gt; int: return self.getNodesNum(root) def getNodesNum(self, cur): if not cur: return 0 leftNum = self.getNodesNum(cur.left) #å·¦ rightNum = self.getNodesNum(cur.right) #å³ treeNum = leftNum + rightNum + 1 #ä¸­ return treeNum #ç®€åŒ–ç‰ˆ class Solution: def countNodes(self, root: TreeNode) -&gt; int: if not root: return 0 return 1 + self.countNodes(root.left) + self.countNodes(root.right) å¹³è¡¡äºŒå‰æ ‘ # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isBalanced(self, root: TreeNode) -&gt; bool: if self.get_height(root) != -1: return True else: return False def get_height(self, root: TreeNode) -&gt; int: # Base Case if not root: return 0 # å·¦ if (left_height := self.get_height(root.left)) == -1: return -1 # å³ if (right_height := self.get_height(root.right)) == -1: return -1 # ä¸­ if abs(left_height - right_height) &gt; 1: return -1 else: return 1 + max(left_height, right_height) äºŒå‰æ ‘çš„è·¯å¾„ # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def binaryTreePaths(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[str] &quot;&quot;&quot; path = '' res = [] if not root: return res self.road(root,path,res) return res #å®šä¹‰éå†å‡½æ•° def road(self,cur,path,res): #è·¯å¾„è¡¨ç¤º path += str(cur.val) #å¶å­ç»“ç‚¹åˆ¤æ–­ if not cur.left and not cur.right: res.append(path) #é€’å½’å·¦å³å­æ ‘ if cur.left: self.road(cur.left,path + '-&gt;',res) if cur.right: self.road(cur.right,path + '-&gt;',res) äºŒå‰æ ‘å‡æ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* pruneTree(TreeNode* root) { //åˆ¤æ–­ç©ºå€¼ if(!root){ return nullptr; } //é€’å½’å·¦å³å­æ ‘ root-&gt;left = pruneTree(root-&gt;left); root-&gt;right = pruneTree(root-&gt;right); //åˆ¤æ–­æ ¹èŠ‚ç‚¹ if(root-&gt;val == 0 &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right){ return nullptr; } return root; } }; æœ€å¤§äºŒå‰æ ‘ ç»™å®šä¸€ä¸ªä¸é‡å¤çš„æ•´æ•°æ•°ç»„ nums ã€‚ æœ€å¤§äºŒå‰æ ‘ å¯ä»¥ç”¨ä¸‹é¢çš„ç®—æ³•ä» nums é€’å½’åœ°æ„å»º: åˆ›å»ºä¸€ä¸ªæ ¹èŠ‚ç‚¹ï¼Œå…¶å€¼ä¸º nums ä¸­çš„æœ€å¤§å€¼ã€‚ é€’å½’åœ°åœ¨æœ€å¤§å€¼ å·¦è¾¹ çš„ å­æ•°ç»„å‰ç¼€ä¸Š æ„å»ºå·¦å­æ ‘ã€‚ é€’å½’åœ°åœ¨æœ€å¤§å€¼ å³è¾¹ çš„ å­æ•°ç»„åç¼€ä¸Š æ„å»ºå³å­æ ‘ã€‚ è¿”å› nums æ„å»ºçš„ æœ€å¤§äºŒå‰æ ‘ ã€‚ é“¾æ¥ï¼šhttps://leetcode.cn/problems/maximum-binary-tree /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) { TreeNode* node = new TreeNode(0); if (nums.size() == 1) { node-&gt;val = nums[0]; return node; } // æ‰¾åˆ°æ•°ç»„ä¸­æœ€å¤§çš„å€¼å’Œå¯¹åº”çš„ä¸‹è¡¨ int maxValue = 0; int maxValueIndex = 0; for (int i = 0; i &lt; nums.size(); i++) { if (nums[i] &gt; maxValue) { maxValue = nums[i]; maxValueIndex = i; } } node-&gt;val = maxValue; // æœ€å¤§å€¼æ‰€åœ¨çš„ä¸‹è¡¨å·¦åŒºé—´ æ„é€ å·¦å­æ ‘ if (maxValueIndex &gt; 0) { vector&lt;int&gt; newVec(nums.begin(), nums.begin() + maxValueIndex); node-&gt;left = constructMaximumBinaryTree(newVec); } // æœ€å¤§å€¼æ‰€åœ¨çš„ä¸‹è¡¨å³åŒºé—´ æ„é€ å³å­æ ‘ if (maxValueIndex &lt; (nums.size() - 1)) { vector&lt;int&gt; newVec(nums.begin() + maxValueIndex + 1, nums.end()); node-&gt;right = constructMaximumBinaryTree(newVec); } return node; } }; //ä¼˜åŒ–éå†ä»£ç  class Solution { private: // åœ¨å·¦é—­å³å¼€åŒºé—´[left, right)ï¼Œæ„é€ äºŒå‰æ ‘ TreeNode* traversal(vector&lt;int&gt;&amp; nums, int left, int right) { if (left &gt;= right) return nullptr; // åˆ†å‰²ç‚¹ä¸‹è¡¨ï¼šmaxValueIndex int maxValueIndex = left; for (int i = left + 1; i &lt; right; ++i) { if (nums[i] &gt; nums[maxValueIndex]) maxValueIndex = i; } TreeNode* root = new TreeNode(nums[maxValueIndex]); // å·¦é—­å³å¼€ï¼š[left, maxValueIndex) root-&gt;left = traversal(nums, left, maxValueIndex); // å·¦é—­å³å¼€ï¼š[maxValueIndex + 1, right) root-&gt;right = traversal(nums, maxValueIndex + 1, right); return root; } public: TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) { return traversal(nums, 0, nums.size()); } }; åˆå¹¶äºŒå‰æ ‘ ç»™ä½ ä¸¤æ£µäºŒå‰æ ‘ï¼š root1 å’Œ root2 ã€‚ æƒ³è±¡ä¸€ä¸‹ï¼Œå½“ä½ å°†å…¶ä¸­ä¸€æ£µè¦†ç›–åˆ°å¦ä¸€æ£µä¹‹ä¸Šæ—¶ï¼Œä¸¤æ£µæ ‘ä¸Šçš„ä¸€äº›èŠ‚ç‚¹å°†ä¼šé‡å ï¼ˆè€Œå¦ä¸€äº›ä¸ä¼šï¼‰ã€‚ä½ éœ€è¦å°†è¿™ä¸¤æ£µæ ‘åˆå¹¶æˆä¸€æ£µæ–°äºŒå‰æ ‘ã€‚åˆå¹¶çš„è§„åˆ™æ˜¯ï¼šå¦‚æœä¸¤ä¸ªèŠ‚ç‚¹é‡å ï¼Œé‚£ä¹ˆå°†è¿™ä¸¤ä¸ªèŠ‚ç‚¹çš„å€¼ç›¸åŠ ä½œä¸ºåˆå¹¶åèŠ‚ç‚¹çš„æ–°å€¼ï¼›å¦åˆ™ï¼Œä¸ä¸º null çš„èŠ‚ç‚¹å°†ç›´æ¥ä½œä¸ºæ–°äºŒå‰æ ‘çš„èŠ‚ç‚¹ã€‚ è¿”å›åˆå¹¶åçš„äºŒå‰æ ‘ã€‚ æ³¨æ„: åˆå¹¶è¿‡ç¨‹å¿…é¡»ä»ä¸¤ä¸ªæ ‘çš„æ ¹èŠ‚ç‚¹ é“¾æ¥ï¼šhttps://leetcode.cn/problems/merge-two-binary-trees /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) { //ç»ˆæ­¢æ¡ä»¶ if(root1 == NULL) return root2; if(root2 == NULL) return root1; //å•å±‚é€’å½’çš„é€»è¾‘ root1-&gt;val += root2-&gt;val; root1-&gt;left = mergeTrees(root1-&gt;left,root2-&gt;left); root1-&gt;right = mergeTrees(root1-&gt;right,root2-&gt;right); return root1; } }; äºŒå‰æ ‘-ååºç¯‡ ååºéå†äºŒå‰æ ‘æ˜¯ä¸€ç§è‡ªåº•å‘ä¸Šçš„éå†è¿‡ç¨‹ï¼›ååºéå†æ€æƒ³åœ¨å›æº¯ç®—æ³•ä¸­åº”ç”¨æœ€ä¸ºå¹¿æ³›ï¼Œæœ¬è´¨å°±æ˜¯ä¸€æ£µæ ‘å…ˆä»ä¸Šåˆ°ä¸‹ä¸æ“ä½œï¼Œä¸€æ’¸åˆ°åº•ï¼Œç„¶åä»å¶å­ç»“ç‚¹å¼€å§‹ï¼Œå‘ä¸Šæ ¹èŠ‚ç‚¹å›æº¯çš„è¿‡ç¨‹ï¼›è¯´ç™½äº†ä¹Ÿå°±æ˜¯é€’å½’çš„é€†è¿‡ç¨‹ã€‚ ä¸ºä»€ä¹ˆéƒ½æ˜¯ååºéå†å‘¢ï¼Ÿè¿™æ˜¯ä¸€ä¸ªå€¼å¾—æ€è€ƒçš„é—®é¢˜ã€‚ ç”¨å‰ªæçš„æ€æƒ³ï¼Œå»ç±»æ¯”é—®é¢˜ã€‚æ— è®ºæ˜¯å¯»æ‰¾æœ€å¤§ç›´å¾„ã€æœ€é•¿ç›¸åŒè·¯å¾„è¿˜æ˜¯æœ€å¤§è·¯å¾„å’Œï¼Œæœ¬è´¨ä¸Šéƒ½æ˜¯ä¸€ä¸ªä»æ ‘çš„åº•éƒ¨å‘æ ‘çš„é¡¶éƒ¨ï¼ˆrootï¼‰å»å‰ªæä¼˜åŒ–çš„è¿‡ç¨‹ã€‚å…¶å®å‰ªæè¯´çš„ä¸å‡†ç¡®ï¼Œä½†æ˜¯å‰ªæçš„ç›®çš„ä¹Ÿæ˜¯å¯»æ‰¾æœ€ä¼˜è·¯å¾„çš„é€‰å–è¿‡ç¨‹ã€‚å§‹ç»ˆè®°ä½ï¼Œååºæ˜¯å› ä¸ºè‡ªåº•å‘ä¸Šå¯»æ‰¾çš„æ€è·¯ï¼Œé‚£ä¹ˆè¿™äº›é—®é¢˜å°±å¯ä»¥æ€»ç»“å‡ºä¸€ä¸ªå¾ˆå¥½æ¨¡æ¿æ€è·¯ã€‚ äºŒå‰æ ‘çš„æœ€å¤§ç›´å¾„ ç»™å®šä¸€æ£µäºŒå‰æ ‘ï¼Œä½ éœ€è¦è®¡ç®—å®ƒçš„ç›´å¾„é•¿åº¦ã€‚ä¸€æ£µäºŒå‰æ ‘çš„ç›´å¾„é•¿åº¦æ˜¯ä»»æ„ä¸¤ä¸ªç»“ç‚¹è·¯å¾„é•¿åº¦ä¸­çš„æœ€å¤§å€¼ã€‚è¿™æ¡è·¯å¾„å¯èƒ½ç©¿è¿‡ä¹Ÿå¯èƒ½ä¸ç©¿è¿‡æ ¹ç»“ç‚¹ã€‚ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ //ååºéå†å¦‚ä½•ç”¨ï¼Ÿ //éå†å‡½æ•°æ€ä¹ˆå†™ï¼Ÿ //è¿”å›å€¼æ˜¯ä»€ä¹ˆï¼Ÿ //ç»ˆæ­¢æ¡ä»¶æ˜¯ä»€ä¹ˆï¼Ÿ //å•å±‚éå†çš„é€»è¾‘æ˜¯ä»€ä¹ˆï¼Ÿ class Solution { private: //int ans = 1; //dfsæ·±åº¦ä¼˜å…ˆ //å‡½æ•°å®šä¹‰çš„ç±»å‹ä¸€å®šè¦å’Œè¿”å›å€¼å¯†åˆ‡ç›¸å…³ã€‚ int travseral(TreeNode* node){ //ç»ˆæ­¢æ¡ä»¶å°±æ˜¯å‘ä¸‹éå†åˆ°æ ¹èŠ‚ç‚¹ if(node == NULL){ return 0; } return max(travseral(node-&gt;left),travseral(node-&gt;right)) + 1; } public: int diameterOfBinaryTree(TreeNode* root) { if(root == NULL) return 0; //å®šä¹‰å·¦å³å­æ ‘ä¹‹é—´çš„æœ€å¤§å€¼ int cur = travseral(root-&gt;left) + travseral(root-&gt;right); //diameterOfBinaryTreeå‡½æ•°æ˜¯è¿”å›å·¦å³å­æ ‘è‡ªèº«çš„æœ€å¤§å€¼ //æœ€åè¿”å›çš„æ˜¯å·¦å³å­æ ‘ã€å·¦å­æ ‘è‡ªèº«ã€å³å­æ ‘è‡ªèº«ä¸‰è€…ä¹‹é—´çš„æœ€å¤§å€¼ return max({cur,diameterOfBinaryTree(root-&gt;left),diameterOfBinaryTree(root-&gt;right)}); } }; æœ€é•¿åŒå€¼è·¯å¾„ ç»™å®šä¸€ä¸ªäºŒå‰æ ‘çš„ root ï¼Œè¿”å› æœ€é•¿çš„è·¯å¾„çš„é•¿åº¦ ï¼Œè¿™ä¸ªè·¯å¾„ä¸­çš„ æ¯ä¸ªèŠ‚ç‚¹å…·æœ‰ç›¸åŒå€¼ ã€‚ è¿™æ¡è·¯å¾„å¯ä»¥ç»è¿‡ä¹Ÿå¯ä»¥ä¸ç»è¿‡æ ¹èŠ‚ç‚¹ã€‚ ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´çš„è·¯å¾„é•¿åº¦ ç”±å®ƒä»¬ä¹‹é—´çš„è¾¹æ•°è¡¨ç¤ºã€‚ é“¾æ¥ï¼šhttps://leetcode.cn/problems/longest-univalue-path /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private: int res = 0; //éå†å‡½æ•°æ—¶ä»€ä¹ˆã€è¿”å›å€¼æ˜¯ä»€ä¹ˆï¼Ÿ int dfs(TreeNode* root,int parentVal){ //ç»ˆæ­¢æ¡ä»¶ if(root == NULL){ return 0; } // åˆ©ç”¨å‡½æ•°å®šä¹‰ï¼Œè®¡ç®—å·¦å³å­æ ‘å€¼ä¸º root.val çš„æœ€é•¿æ ‘æé•¿åº¦ int left = dfs(root-&gt;left,root-&gt;val); int right = dfs(root-&gt;right,root-&gt;val); //ååºæ“ä½œ:ç›´æ¥è¿”å›å·¦å³å­æ ‘æœ€å¤§è·¯å¾„ä¹‹å’Œ res = max(res, left + right); // å¦‚æœ root æœ¬èº«å’Œä¸Šçº§å€¼ä¸åŒï¼Œé‚£ä¹ˆæ•´æ£µå­æ ‘éƒ½ä¸å¯èƒ½æœ‰åŒå€¼æ ‘æ if(root-&gt;val != parentVal){ //æ³¨æ„è¿”å›å€¼çš„è®¾å®š return 0; } // å®ç°å‡½æ•°çš„å®šä¹‰ï¼š // ä»¥ root ä¸ºæ ¹çš„äºŒå‰æ ‘ä» root å¼€å§‹å€¼ä¸º parentVal çš„æœ€é•¿æ ‘æé•¿åº¦ // ç­‰äºå·¦å³å­æ ‘çš„æœ€é•¿æ ‘æé•¿åº¦çš„æœ€å¤§å€¼åŠ ä¸Š root èŠ‚ç‚¹æœ¬èº« return 1 + max(left,right); } public: int longestUnivaluePath(TreeNode* root) { if(root == NULL){ return 0; } dfs(root,root-&gt;val); return res; } }; äºŒå‰æ ‘ä¸­æœ€å¤§è·¯å¾„å’Œ è·¯å¾„ è¢«å®šä¹‰ä¸ºä¸€æ¡ä»æ ‘ä¸­ä»»æ„èŠ‚ç‚¹å‡ºå‘ï¼Œæ²¿çˆ¶èŠ‚ç‚¹-å­èŠ‚ç‚¹è¿æ¥ï¼Œè¾¾åˆ°ä»»æ„èŠ‚ç‚¹çš„åºåˆ—ã€‚åŒä¸€ä¸ªèŠ‚ç‚¹åœ¨ä¸€æ¡è·¯å¾„åºåˆ—ä¸­ è‡³å¤šå‡ºç°ä¸€æ¬¡ ã€‚è¯¥è·¯å¾„ è‡³å°‘åŒ…å«ä¸€ä¸ª èŠ‚ç‚¹ï¼Œä¸”ä¸ä¸€å®šç»è¿‡æ ¹èŠ‚ç‚¹ã€‚ è·¯å¾„å’Œ æ˜¯è·¯å¾„ä¸­å„èŠ‚ç‚¹å€¼çš„æ€»å’Œã€‚ ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å›å…¶ æœ€å¤§è·¯å¾„å’Œ ã€‚ é“¾æ¥ï¼šhttps://leetcode.cn/problems/binary-tree-maximum-path-sum /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private: int ret = INT_MIN; //å‡½æ•°å®šä¹‰å’Œè¿”å›å€¼æ˜¯ä»€ä¹ˆï¼Ÿ // å®šä¹‰ï¼šè®¡ç®—ä»æ ¹èŠ‚ç‚¹ root ä¸ºèµ·ç‚¹çš„æœ€å¤§å•è¾¹è·¯å¾„å’Œ int dfs(TreeNode* root){ //ç»ˆæ­¢æ¡ä»¶ if(root == NULL){ return 0; } int leftsum = max(0,dfs(root-&gt;left)); int rightsum = max(0,dfs(root-&gt;right)); // ååºéå†ä½ç½®ï¼Œé¡ºä¾¿æ›´æ–°æœ€å¤§è·¯å¾„å’Œ int pathsum = root-&gt;val + leftsum + rightsum; ret = max(ret,pathsum); // å®ç°å‡½æ•°å®šä¹‰ï¼Œå·¦å³å­æ ‘çš„æœ€å¤§å•è¾¹è·¯å¾„å’ŒåŠ ä¸Šæ ¹èŠ‚ç‚¹çš„å€¼ // å°±æ˜¯ä»æ ¹èŠ‚ç‚¹ root ä¸ºèµ·ç‚¹çš„æœ€å¤§å•è¾¹è·¯å¾„å’Œ return max(leftsum,rightsum) + root-&gt;val; } public: int maxPathSum(TreeNode* root) { if(root == NULL){ return 0; } dfs(root); return ret; } }; äºŒå‰æœç´¢æ ‘ äºŒå‰æœç´¢æ ‘çš„åŸºæœ¬æ¦‚å¿µï¼š äºŒå‰æœç´¢æ ‘æ˜¯ä¸€é¢—æœ‰åºæ ‘ï¼Œæ»¡è¶³å¦‚ä¸‹è§„åˆ™ï¼š è‹¥å®ƒçš„å·¦å­æ ‘ä¸ç©ºï¼Œåˆ™å·¦å­æ ‘ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„å€¼éƒ½å°äºå®ƒçš„æ ¹èŠ‚ç‚¹ä¸Šçš„å€¼ã€‚ è‹¥å®ƒçš„å³å­æ ‘ä¸ç©ºï¼Œåˆ™å³å­æ ‘ä¸Šæ‰€æœ‰èŠ‚ç‚¹çš„å€¼éƒ½å¤§äºå®ƒçš„æ ¹èŠ‚ç‚¹ä¸Šçš„å€¼ã€‚ å®ƒçš„å·¦å³å­æ ‘ä¹Ÿåˆ†åˆ«ä¹¦äºŒå‰æ’åºæ ‘ã€‚ äºŒå‰æœç´¢æ ‘çš„ä¸­åºéå†æ˜¯ä¸€ä¸ªä¸¥æ ¼çš„é€’å¢åºåˆ—ã€‚æ‰€æœ‰åœ¨é‡åˆ°äºŒå‰æœç´¢æ ‘çš„ç›¸å…³é—®é¢˜æ—¶ï¼Œå·§ç”¨ä¸­åºéå†æ˜¯è§£é¢˜çš„å…³é”®ä¹Ÿæ˜¯è§£å†³é—®é¢˜çš„å¿«é€Ÿæ–¹æ³•ã€‚ ä¸­åºéå†ä»£ç ï¼š void searchBST(TreeNode* cur){ if(cur == NULL) return; searchBST(root-&gt;left);//å·¦ (ä¸­åºæ“ä½œ) searchBST(root-&gt;right);//å³ } åœ¨è§£å†³äºŒå‰æœç´¢æ ‘çš„æœ€å€¼é—®é¢˜æ—¶ï¼Œé€’å½’å¯ä»¥é‡‡ç”¨ä¸¤ç§åŸºæœ¬çš„æ–¹å¼ï¼š 1.ä»¥æ•°ç»„ä¸ºåŸºæœ¬æ•°æ®ç»“æ„çš„æ–¹å¼ æ€è·¯ï¼š ä»¥æ•°ç»„ä¸ºåŸºæœ¬çš„å­˜å‚¨æ–¹å¼ä¸­åºéå†å†™èµ·æ¥è¾ƒä¸ºç›´è§‚ vector&lt;int&gt; res; void travser(TreeNode* root){ if(root == NULL) return; travser(root-&gt;left); res.push_back(root-&gt;val); travser(root-&gt;right); æ“ä½œæ˜¯æ”¾åœ¨ä¸»å‡½æ•°ä¸­è¿›è¡Œï¼Œåœ¨ä¸»å‡½æ•°åˆ©ç”¨forå¾ªç¯è¿›è¡Œæ±‚è§£æœ€å€¼å¾—é—®é¢˜ï¼›ä¸­åºéå†çš„æ–¹æ³•åªæ˜¯ä¸ºäº†å¾—åˆ°ä¸€ä¸ªå‡åºçš„æ•°ç»„ï¼Œå¾—ä»¥æŠŠä¸€é¢—äºŒå‰æ’åºæ ‘è½¬åŒ–æˆä¸€ä¸ªå•è°ƒé€’å¢çš„æ•°ç»„ï¼Œä»¥æ–¹ä¾¿å¤„ç†ã€‚ 2.ä»¥å•é“¾è¡¨ä¸ºåŸºæœ¬æ•°æ®ç»“æ„çš„æ–¹å¼ æ€è·¯ï¼š å•é“¾è¡¨çš„æ–¹å¼éœ€è¦è®¾ç½®ä¸¤ä¸ªèŠ‚ç‚¹æŒ‡é’ˆï¼šcurå’Œpreï¼Œç›¸å½“äºä¸€ä¸ªå¤´æŒ‡é’ˆå’Œä¸€ä¸ªå°¾æŒ‡é’ˆï¼›æ— è®ºæ˜¯åœ¨è¿­ä»£è¿˜æ˜¯åœ¨é€’å½’ä¸­ï¼Œå¤´å°¾æŒ‡é’ˆçš„è®¾å®šå°±æ˜¯å»æ‘†è„±åœ¨ä¸»å‡½æ•°ä¸­çš„äºŒæ¬¡forå¾ªç¯æ“ä½œï¼Œè€Œé™ä½æ—¶é—´å¤æ‚åº¦ï¼Œåœ¨é€’å½’çš„è¿‡ç¨‹ä¸­å³å®ç°æ“ä½œçš„ä¸€æ­¥åˆ°ä½ã€‚ TreeNode* pur = NULL;//è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹ //TreeNode* cur = root; if(root == NULL) return true; //ä¸­åºéå†æ€è·¯ bool left = isValidBST(root-&gt;left); //ç›¸å½“äºæ˜¯ä¸­åºéå†æ“ä½œä¸­åœ¨æ“ä½œçš„åˆ¤æ–­ //è¿ç”¨å¤´ç»“ç‚¹puråˆ¤æ–­æ˜¯å¦æ˜¯ä¸€ä¸ªé€’å¢çš„åºåˆ— if(pur != NULL &amp;&amp; pur-&gt;val &gt;= root-&gt;val) return false; pur = root; bool right = isValidBST(root-&gt;right); //ç›¸å½“äºä¸­åºéå†å¤šåŠ äº†ä¸€ä¸ªifåˆ¤æ–­æ“ä½œ åœ¨äºŒå‰æœç´¢æ ‘ä¸­å¯»æ‰¾èŠ‚ç‚¹ ç»™å®šäºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„æ ¹èŠ‚ç‚¹ root å’Œä¸€ä¸ªæ•´æ•°å€¼ valã€‚ ä½ éœ€è¦åœ¨ BST ä¸­æ‰¾åˆ°èŠ‚ç‚¹å€¼ç­‰äº val çš„èŠ‚ç‚¹ã€‚ è¿”å›ä»¥è¯¥èŠ‚ç‚¹ä¸ºæ ¹çš„å­æ ‘ã€‚ å¦‚æœèŠ‚ç‚¹ä¸å­˜åœ¨ï¼Œåˆ™è¿”å› null ã€‚ é“¾æ¥ï¼šhttps://leetcode.cn/problems/search-in-a-binary-search-tree /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: //ç¡®å®šé€’å½’å‡½æ•°å’Œå‚æ•°è®¾ç½® TreeNode* searchBST(TreeNode* root, int val) { //ç»ˆæ­¢æ¡ä»¶ if(root == NULL || root-&gt;val == val) return root; //å› ä¸ºäºŒå‰æœç´¢æ ‘çš„èŠ‚ç‚¹å¤§å°æ˜¯æœ‰è§„å¾‹çš„æ‰€ä»¥å¯ä»¥ç®€åŒ–æœç´¢ if(root-&gt;val &gt; val) return searchBST(root-&gt;left,val); if(root-&gt;val &lt; val) return searchBST(root-&gt;right,val); return NULL; } }; éªŒè¯äºŒå‰æœç´¢æ ‘ ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œåˆ¤æ–­å…¶æ˜¯å¦æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„äºŒå‰æœç´¢æ ‘ã€‚ æœ‰æ•ˆ äºŒå‰æœç´¢æ ‘å®šä¹‰å¦‚ä¸‹ï¼š èŠ‚ç‚¹çš„å·¦å­æ ‘åªåŒ…å« å°äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚ èŠ‚ç‚¹çš„å³å­æ ‘åªåŒ…å« å¤§äº å½“å‰èŠ‚ç‚¹çš„æ•°ã€‚ æ‰€æœ‰å·¦å­æ ‘å’Œå³å­æ ‘è‡ªèº«å¿…é¡»ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ã€‚ é“¾æ¥ï¼šhttps://leetcode.cn/problems/validate-binary-search-tree /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private: //æ€è·¯ï¼šä¸­åºéå†æ„å»ºä¸€ä¸ªé€’å¢çš„æ•°ç»„ vector&lt;int&gt; res; void travser(TreeNode* root){ if(root == NULL) return; travser(root-&gt;left); res.push_back(root-&gt;val); travser(root-&gt;right); } public: bool isValidBST(TreeNode* root) { res.clear(); travser(root); for(int i = 1;i &lt; res.size();i++){ if(res[i] &lt;= res[i - 1]){ return false; } } return true; } }; æ”¹è¿›ï¼š /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* pur = NULL;//è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹ //TreeNode* cur = root; bool isValidBST(TreeNode* root) { if(root == NULL) return true; //ä¸­åºéå†æ€è·¯ bool left = isValidBST(root-&gt;left); //ç›¸å½“äºæ˜¯ä¸­åºéå†æ“ä½œä¸­åœ¨æ“ä½œçš„åˆ¤æ–­ //è¿ç”¨å¤´ç»“ç‚¹puråˆ¤æ–­æ˜¯å¦æ˜¯ä¸€ä¸ªé€’å¢çš„åºåˆ— if(pur != NULL &amp;&amp; pur-&gt;val &gt;= root-&gt;val) return false; pur = root; bool right = isValidBST(root-&gt;right); return left &amp;&amp; right; } }; äºŒå‰æœç´¢æ ‘çš„æœ€å°ç»å¯¹å·® ç»™ä½ ä¸€ä¸ªäºŒå‰æœç´¢æ ‘çš„æ ¹èŠ‚ç‚¹ root ï¼Œè¿”å› æ ‘ä¸­ä»»æ„ä¸¤ä¸åŒèŠ‚ç‚¹å€¼ä¹‹é—´çš„æœ€å°å·®å€¼ ã€‚ å·®å€¼æ˜¯ä¸€ä¸ªæ­£æ•°ï¼Œå…¶æ•°å€¼ç­‰äºä¸¤å€¼ä¹‹å·®çš„ç»å¯¹å€¼ã€‚ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private: vector&lt;int&gt; vec; void traversal(TreeNode* root) { if (root == NULL) return; traversal(root-&gt;left); vec.push_back(root-&gt;val); // å°†äºŒå‰æœç´¢æ ‘è½¬æ¢ä¸ºæœ‰åºæ•°ç»„ traversal(root-&gt;right); } public: int getMinimumDifference(TreeNode* root) { vec.clear(); traversal(root); if (vec.size() &lt; 2) return 0; int result = INT_MAX; for (int i = 1; i &lt; vec.size(); i++) { // ç»Ÿè®¡æœ‰åºæ•°ç»„çš„æœ€å°å·®å€¼ result = min(result, vec[i] - vec[i-1]); } return result; } }; //è®¾ç½®åŒèŠ‚ç‚¹çš„å¦ä¸€ç§åšæ³• class Solution { private: int result = INT_MAX; TreeNode* pre; void traversal(TreeNode* cur) { if (cur == NULL) return; traversal(cur-&gt;left); // å·¦ if (pre != NULL){ // ä¸­ result = min(result, cur-&gt;val - pre-&gt;val); } pre = cur; // è®°å½•å‰ä¸€ä¸ª traversal(cur-&gt;right); // å³ } public: int getMinimumDifference(TreeNode* root) { traversal(root); return result; } }; äºŒå‰æœç´¢æ ‘ä¸­çš„ä¼—æ•° ç»™ä½ ä¸€ä¸ªå«é‡å¤å€¼çš„äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„æ ¹èŠ‚ç‚¹ root ï¼Œæ‰¾å‡ºå¹¶è¿”å› BST ä¸­çš„æ‰€æœ‰ ä¼—æ•°ï¼ˆå³ï¼Œå‡ºç°é¢‘ç‡æœ€é«˜çš„å…ƒç´ ï¼‰ã€‚ å¦‚æœæ ‘ä¸­æœ‰ä¸æ­¢ä¸€ä¸ªä¼—æ•°ï¼Œå¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›ã€‚ é“¾æ¥ï¼šhttps://leetcode.cn/problems/find-mode-in-binary-search-tree class Solution { private: int maxCount; // æœ€å¤§é¢‘ç‡ int count; // ç»Ÿè®¡é¢‘ç‡ TreeNode* pre; vector&lt;int&gt; result; void searchBST(TreeNode* cur) { if (cur == NULL) return ; searchBST(cur-&gt;left); // å·¦ // ä¸­ if (pre == NULL) { // ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ count = 1; } else if (pre-&gt;val == cur-&gt;val) { // ä¸å‰ä¸€ä¸ªèŠ‚ç‚¹æ•°å€¼ç›¸åŒ count++; } else { // ä¸å‰ä¸€ä¸ªèŠ‚ç‚¹æ•°å€¼ä¸åŒ count = 1; } pre = cur; // æ›´æ–°ä¸Šä¸€ä¸ªèŠ‚ç‚¹ if (count == maxCount) { // å¦‚æœå’Œæœ€å¤§å€¼ç›¸åŒï¼Œæ”¾è¿›resultä¸­ result.push_back(cur-&gt;val); } if (count &gt; maxCount) { // å¦‚æœè®¡æ•°å¤§äºæœ€å¤§å€¼é¢‘ç‡ maxCount = count; // æ›´æ–°æœ€å¤§é¢‘ç‡ result.clear(); // å¾ˆå…³é”®çš„ä¸€æ­¥ï¼Œä¸è¦å¿˜è®°æ¸…ç©ºresultï¼Œä¹‹å‰resulté‡Œçš„å…ƒç´ éƒ½å¤±æ•ˆäº† result.push_back(cur-&gt;val); } searchBST(cur-&gt;right); // å³ return ; } public: vector&lt;int&gt; findMode(TreeNode* root) { count = 0; maxCount = 0; TreeNode* pre = NULL; // è®°å½•å‰ä¸€ä¸ªèŠ‚ç‚¹ result.clear(); searchBST(root); return result; } }; //è¿­ä»£æ³• class Solution { public: vector&lt;int&gt; findMode(TreeNode* root) { stack&lt;TreeNode*&gt; st; TreeNode* cur = root; TreeNode* pre = NULL; int maxCount = 0; // æœ€å¤§é¢‘ç‡ int count = 0; // ç»Ÿè®¡é¢‘ç‡ vector&lt;int&gt; result; while (cur != NULL || !st.empty()) { if (cur != NULL) { // æŒ‡é’ˆæ¥è®¿é—®èŠ‚ç‚¹ï¼Œè®¿é—®åˆ°æœ€åº•å±‚ st.push(cur); // å°†è®¿é—®çš„èŠ‚ç‚¹æ”¾è¿›æ ˆ cur = cur-&gt;left; // å·¦ } else { cur = st.top(); st.pop(); // ä¸­ if (pre == NULL) { // ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ count = 1; } else if (pre-&gt;val == cur-&gt;val) { // ä¸å‰ä¸€ä¸ªèŠ‚ç‚¹æ•°å€¼ç›¸åŒ count++; } else { // ä¸å‰ä¸€ä¸ªèŠ‚ç‚¹æ•°å€¼ä¸åŒ count = 1; } if (count == maxCount) { // å¦‚æœå’Œæœ€å¤§å€¼ç›¸åŒï¼Œæ”¾è¿›resultä¸­ result.push_back(cur-&gt;val); } if (count &gt; maxCount) { // å¦‚æœè®¡æ•°å¤§äºæœ€å¤§å€¼é¢‘ç‡ maxCount = count; // æ›´æ–°æœ€å¤§é¢‘ç‡ result.clear(); // å¾ˆå…³é”®çš„ä¸€æ­¥ï¼Œä¸è¦å¿˜è®°æ¸…ç©ºresultï¼Œä¹‹å‰resulté‡Œçš„å…ƒç´ éƒ½å¤±æ•ˆäº† result.push_back(cur-&gt;val); } pre = cur; cur = cur-&gt;right; // å³ } } return result; } }; äºŒå‰æ ‘/æœç´¢æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ ç»™å®šä¸€ä¸ªäºŒå‰æ ‘, æ‰¾åˆ°è¯¥æ ‘ä¸­ä¸¤ä¸ªæŒ‡å®šèŠ‚ç‚¹çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚ ç™¾åº¦ç™¾ç§‘ä¸­æœ€è¿‘å…¬å…±ç¥–å…ˆçš„å®šä¹‰ä¸ºï¼šâ€œå¯¹äºæœ‰æ ¹æ ‘ T çš„ä¸¤ä¸ªèŠ‚ç‚¹ pã€qï¼Œæœ€è¿‘å…¬å…±ç¥–å…ˆè¡¨ç¤ºä¸ºä¸€ä¸ªèŠ‚ç‚¹ xï¼Œæ»¡è¶³ x æ˜¯ pã€q çš„ç¥–å…ˆä¸” x çš„æ·±åº¦å°½å¯èƒ½å¤§ï¼ˆä¸€ä¸ªèŠ‚ç‚¹ä¹Ÿå¯ä»¥æ˜¯å®ƒè‡ªå·±çš„ç¥–å…ˆï¼‰ã€‚â€ é“¾æ¥ï¼šhttps://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree //æ™®é€šäºŒå‰æ ‘çš„æœ€è¿‘ç¥–å…ˆ /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root == p || root == q || root == NULL){ return root; } //å¯»æ‰¾å…¬å…±ç¥–å…ˆçš„æ€è·¯æ˜¯è¦é€šè¿‡è‡ªåº•å‘ä¸Šçš„ååºéå†åˆ¤æ–­å…¬å…±ç¥–å…ˆ TreeNode *left = lowestCommonAncestor(root-&gt;left,p,q); TreeNode *right = lowestCommonAncestor(root-&gt;right,p,q); //ååºæ“ä½œ if(left != NULL &amp;&amp; right != NULL) return root; if(left == NULL &amp;&amp; right != NULL) return right; else if(left != NULL &amp;&amp; right == NULL) return left; else{ return NULL; } } }; //äºŒå‰æœç´¢æ ‘çš„æœ€è¿‘ç¥–å…ˆ //æ³¨æ„ç»“åˆæœç´¢åŒºé—´è¿›è¡Œåˆ¤æ–­ class Solution { private: TreeNode* traversal(TreeNode* cur, TreeNode* p, TreeNode* q) { if (cur == NULL) return cur; // ä¸­ if (cur-&gt;val &gt; p-&gt;val &amp;&amp; cur-&gt;val &gt; q-&gt;val) { // å·¦ TreeNode* left = traversal(cur-&gt;left, p, q); if (left != NULL) { return left; } } if (cur-&gt;val &lt; p-&gt;val &amp;&amp; cur-&gt;val &lt; q-&gt;val) { // å³ TreeNode* right = traversal(cur-&gt;right, p, q); if (right != NULL) { return right; } } return cur; } public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { return traversal(root, p, q); } }; å›¾è®ºç®—æ³• å›¾è®ºç« èŠ‚ä¸»è¦æ˜¯æ¶‰åŠåˆ°äº†å›¾çš„ä¸¤ç§éå†æ–¹å¼-&gt;æ·±åº¦ä¼˜å…ˆæœç´¢å’Œå¹¿åº¦æœ‰ä¼˜å…ˆæœç´¢ã€‚ å›¾çš„åŸºæœ¬æ•°æ®ç»“æ„çš„å®ç° ç»“æ„ä½“æ˜¯ä¸€ä¸ªç”±ç¨‹åºå‘˜å®šä¹‰çš„æ•°æ®ç±»å‹ï¼Œå¯ä»¥å®¹çº³è®¸å¤šä¸åŒçš„æ•°æ®å€¼ã€‚åœ¨è¿‡å»ï¼Œé¢å‘å¯¹è±¡ç¼–ç¨‹çš„åº”ç”¨å°šæœªæ™®åŠä¹‹å‰ï¼Œç¨‹åºå‘˜é€šå¸¸ä½¿ç”¨è¿™äº›ä»é€»è¾‘ä¸Šè¿æ¥åœ¨ä¸€èµ·çš„æ•°æ®ç»„åˆåˆ°ä¸€ä¸ªå•å…ƒä¸­ã€‚ä¸€æ—¦ç»“æ„ä½“ç±»å‹è¢«å£°æ˜å¹¶ä¸”å…¶æ•°æ®æˆå‘˜è¢«æ ‡è¯†ï¼Œå³å¯åˆ›å»ºè¯¥ç±»å‹çš„å¤šä¸ªå˜é‡ï¼Œå°±åƒå¯ä»¥ä¸ºåŒä¸€ä¸ªç±»åˆ›å»ºå¤šä¸ªå¯¹è±¡ä¸€æ ·ã€‚ å£°æ˜ç»“æ„ä½“çš„æ–¹å¼å’Œå£°æ˜ç±»çš„æ–¹å¼å¤§è‡´ç›¸åŒï¼Œå…¶åŒºåˆ«å¦‚ä¸‹ï¼š ä½¿ç”¨å…³é”®å­— struct è€Œä¸æ˜¯å…³é”®å­— classã€‚ å°½ç®¡ç»“æ„ä½“å¯ä»¥åŒ…å«æˆå‘˜å‡½æ•°ï¼Œä½†å®ƒä»¬å¾ˆå°‘è¿™æ ·åšã€‚æ‰€ä»¥ï¼Œé€šå¸¸æƒ…å†µä¸‹ç»“æ„ä½“å£°æ˜åªä¼šå£°æ˜æˆå‘˜å˜é‡ã€‚ ç»“æ„ä½“å£°æ˜é€šå¸¸ä¸åŒ…æ‹¬ public æˆ– private çš„è®¿é—®ä¿®é¥°ç¬¦ã€‚ ç±»æˆå‘˜é»˜è®¤æƒ…å†µæ˜¯ç§æœ‰çš„ï¼Œè€Œç»“æ„ä½“çš„æˆå‘˜åˆ™é»˜è®¤ä¸º publicã€‚ç¨‹åºå‘˜é€šå¸¸å¸Œæœ›å®ƒä»¬ä¿æŒå…¬å¼€ï¼Œåªéœ€ä½¿ç”¨é»˜è®¤å€¼å³å¯ã€‚ ä»¥ä¸‹æ˜¯ä¸€ä¸ªç»“æ„ä½“å£°æ˜çš„ç¤ºä¾‹ï¼Œè¯¥ç»“æ„ä½“å°† 5 ä¸ªå˜é‡ç»‘å®šåœ¨ä¸€èµ·ï¼Œä¿å­˜äº†å‘˜å·¥çš„å·¥èµ„å•æ•°æ®ã€‚è¿™ä¸ªç‰¹æ®Šç»“æ„ä½“çš„åç§°æ˜¯ PayRollã€‚è¯·æ³¨æ„ï¼Œå®ƒä»¥å¤§å†™å­—æ¯å¼€å¤´ï¼Œè¿™å’Œç±»åä½¿ç”¨å¤§å†™å­—æ¯å¼€å¤´çš„çº¦å®šä¸€æ ·ã€‚å¦å¤–è¿˜è¦æ³¨æ„ï¼Œä¸ç±»å£°æ˜ä¸€æ ·ï¼Œåœ¨ç»“æ„ä½“å£°æ˜çš„å¤§æ‹¬å·åé¢å¿…é¡»æœ‰ä¸€ä¸ªåˆ†å·ã€‚ struct PayRoll { int empNumber; string name; double hours,payRate,grossPay; }; ç»“æ„ä½“ å½“å®šä¹‰ç»“æ„ä½“å˜é‡æ—¶ï¼Œå¯ä»¥é€šè¿‡ä¸¤ç§æ–¹å¼åˆå§‹åŒ–å®ƒï¼šä½¿ç”¨åˆå§‹åŒ–åˆ—è¡¨æˆ–æ„é€ å‡½æ•°ã€‚ åˆå§‹åŒ–åˆ—è¡¨ åˆå§‹åŒ–ç»“æ„ä½“å˜é‡æˆå‘˜çš„æœ€ç®€å•çš„æ–¹æ³•æ˜¯ä½¿ç”¨åˆå§‹åŒ–åˆ—è¡¨ã€‚åˆå§‹åŒ–åˆ—è¡¨æ˜¯ç”¨äºåˆå§‹åŒ–ä¸€ç»„å†…å­˜ä½ç½®çš„å€¼åˆ—è¡¨ã€‚åˆ—è¡¨ä¸­çš„é¡¹ç›®ç”¨é€—å·åˆ†éš”å¹¶ç”¨å¤§æ‹¬å·æ‹¬èµ·æ¥ã€‚ ä¾‹å¦‚ï¼Œå‡è®¾å·²ç»å£°æ˜äº†ä»¥ä¸‹ Date ç»“æ„ä½“ï¼š struct Date{ int day, month, year; }; å®šä¹‰å’Œåˆå§‹åŒ– Date å˜é‡çš„æ–¹å¼æ˜¯ï¼šå…ˆæŒ‡å®šå˜é‡åï¼Œåæ¥èµ‹å€¼è¿ç®—ç¬¦å’Œåˆå§‹åŒ–åˆ—è¡¨ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š Date birthday = {23, 8, 1983}; è¯¥å£°æ˜å®šä¹‰ birthday æ˜¯ä¸€ä¸ª Date ç»“æ„ä½“çš„å˜é‡ï¼Œå¤§æ‹¬å·å†…çš„å€¼æŒ‰é¡ºåºåˆ†é…ç»™å…¶æˆå‘˜ã€‚ BFSå¹¿åº¦ä¼˜å…ˆæœç´¢ äºŒå‰æ ‘çš„å¹¿åº¦ä¼˜å…ˆæœç´¢-&gt;äºŒå‰æ ‘çš„å±‚åºéå†ï¼›è€Œè®²åˆ°å±‚åºéå†ï¼Œåˆå¯ä»¥æŠŠè§£é¢˜æ€è·¯åˆ†æˆä¸¤ç§ï¼šé€’å½’æ³•ã€è¿­ä»£æ³•ã€‚ è¿™æ˜¯ä¸»è¦å†™è¿­ä»£æ³•ï¼Œå› ä¸ºç›¸æ¯”äºé€’å½’æ³•çš„å±‚åºéå†ï¼Œè¿­ä»£æ³•çš„BFSç®—æ³•æ˜¯æœ€èƒ½ä½“ç°å‡ºBFSæ€è·¯çš„æ–¹æ³•ã€‚ éœ€è¦ç”¨åˆ°çš„æ•°æ®ç»“æ„ï¼šé˜Ÿåˆ—-&gt;å‡†ç¡®çš„è¯´æ˜¯æŒ‡é’ˆé˜Ÿåˆ—. ä¸‹é¢å’±ä»¬å°±æ‰‹æ’¸ä¸€ä¸ªBFSç®—æ³•ï¼š #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;stdlib.h&gt; #include&lt;vector&gt; using namespace std; struct TreeNode{ int val; TreeNode* left; TreeNode* right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; int BFS(TreeNode * root){ if(root == NULL) return 0; //ç»ˆæ­¢æ¡ä»¶åˆ¤æ–­ queue&lt;TreeNode*&gt; que; //åˆ›å»ºé˜Ÿåˆ— que.push(root); //å°†æ ¹èŠ‚ç‚¹å…¥é˜Ÿ int sum = 0;//è®¾ç½®è®°å½•ä¿¡å· while(!que.empty()){ sum = 0;//æ¯æ¬¡å¾ªç¯ä¹‹å‰å½’é›¶ï¼Œè®°å½•å•å±‚çš„å’Œ int sz = que.size();//æ±‚å‡ºé˜Ÿåˆ—é•¿åº¦ for(int i = 0;i &lt; sz;i++){ //forå¾ªç¯ä¾æ¬¡å¯¹æ¯å±‚æ±‚å’Œ TreeNode* cur = que.front();//å–å¯¹å¤´å…ƒç´ ä¸ºåˆå§‹æŒ‡é’ˆèŠ‚ç‚¹ que.pop(); sum += cur-&gt;val; if(cur-&gt;left != NULL){ que.push(cur-&gt;left); } if(cur-&gt;right != NULL){ que.push(cur-&gt;right); } } } return sum; } å¹¿åº¦ä¼˜å…ˆæœç´¢â€”â€”æœ¬è´¨ä¸Šæ˜¯äºŒå‰æ ‘çš„å±‚åºéå†ï¼ˆåŠ›æ‰£102é¢˜ï¼‰ è¿ç”¨çš„æ•°æ®ç»“æ„æ˜¯é˜Ÿåˆ—å’Œæ•°ç»„ï¼›è¿ç”¨æ•°ç»„ä¿å­˜æœ€åçš„ç»“æœï¼Œè¿ç”¨é˜Ÿåˆ—å»æ¨¡æ‹Ÿå±‚åºéå†çš„è¿‡ç¨‹ã€‚ class Solution { public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { queue&lt;TreeNode*&gt; que; if (root != NULL) que.push(root); vector&lt;vector&lt;int&gt;&gt; result; while (!que.empty()) { int size = que.size(); vector&lt;int&gt; vec; // è¿™é‡Œä¸€å®šè¦ä½¿ç”¨å›ºå®šå¤§å°sizeï¼Œä¸è¦ä½¿ç”¨que.size()ï¼Œå› ä¸ºque.sizeæ˜¯ä¸æ–­å˜åŒ–çš„ for (int i = 0; i &lt; size; i++) { TreeNode* node = que.front(); que.pop(); vec.push_back(node-&gt;val); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); } result.push_back(vec); } return result; } }; DFSæ·±åº¦ä¼˜å…ˆæœç´¢ æ·±åº¦ä¼˜å…ˆæœç´¢ï¼Œé¡¾åæ€ä¹‰å°±æ˜¯ä¸€æ¡é“è·¯èµ°åˆ°åº•ï¼›ç±»æ¯”ä¸€æ£µæ ‘çš„è¯ï¼Œå°±æ˜¯ä»ä¸Šåˆ°ä¸‹å…ˆåºéå†ä¸€æ£µæ ‘ã€‚æ·±åº¦ä¼˜å…ˆï¼Œå¾—åˆ°çš„ä¸€å®šå…ˆæ˜¯æ ‘çš„æ·±åº¦ï¼ˆé«˜åº¦ï¼‰ã€‚å› ä¸ºå…¶é€šå¸¸å’Œå›æº¯ç®—æ³•ç›¸ç»“åˆä½¿ç”¨ï¼Œæ‰€ä»¥å…¶é‡è¦æ€§ä¸å¯ä¼°é‡ã€‚å­¦ä¼šDFSå°±æ˜¯å­¦ä¼šä½¿ç”¨å…¶æš´åŠ›æœç´¢çš„åŠŸèƒ½ï¼Œå­¦ä¼šèªæ˜çš„ç©·ä¸¾ã€‚é¿å…é«˜å¼ºåº¦çš„å¤šå¾ªç¯åµŒå¥—forå¾ªç¯ï¼Œæ—¢æµªè´¹æ—¶é—´åˆæµªè´¹ç©ºé—´ï¼›é‚£ä¸ºä»€ä¹ˆæš´åŠ›æœç´¢ä¹Ÿéœ€è¦èŠ±è´¹å¤§é‡æ—¶é—´ä½†æ˜¯è¿˜æœ‰å®ƒå­˜åœ¨çš„é“ç†å‘¢ï¼Ÿæˆ‘è®¤ä¸ºï¼Œå­˜åœ¨å³åˆç†ï¼Œå¾ˆå¤šæ—¶å€™DFSç®—æ³•å­˜åœ¨ç¡®å®æ˜¯æœ‰ä»–çš„ä¼˜åŠ¿çš„ã€‚æœ€èµ·ç ï¼ŒDFSå°±æ˜¯åˆ©ç”¨é€’å½’æ€ç»´å»ä¹¦å†™ç¨‹åºçš„ä¸€ä¸ªå¥½æ¨¡æ¿ã€‚è™½ç„¶æœ¬è´¨ä¸Šå’Œforå¾ªç¯å·®åˆ«ä¸å¤§ï¼Œä½†æ˜¯ï¼Œä¸€æ—¦é—®é¢˜è§„æ¨¡å˜å¤§ï¼Œforå¾ªç¯æ‰¿æ‹…ä¸äº†å¤§å·¥ç¨‹æ—¶ï¼Œå¤šå±‚å¾ªç¯å¾ˆå®¹æ˜“æŠŠäººç»•æ‡µè€Œä¸”æ—¶é—´å¤æ‚åº¦æ˜¯å‘ˆç°næ–¹é‡çº§å¢åŠ ã€‚è¿™æ—¶ï¼ŒDFSçš„é€’å½’éå†å°±èŠ‚çœäº†å¾ˆå¤§çš„ç©ºé—´å¤æ‚åº¦ï¼ˆæ—¶é—´å¤æ‚åº¦è™½ç„¶ä¸æ•¢ä¿è¯ï¼‰ï¼Œé¿å…äº†é«˜å¼ºåº¦çš„å¾ªç¯åµŒå¥—ï¼Œä½¿å¾—ç¨‹åºå¾—ä»¥è¿è¡Œå‡ºç»“æœã€‚åŒæ ·ï¼Œç©·ä¸¾ä¸æš´åŠ›æ˜¯ç¨‹åºè®¾è®¡æœ€æœ¬æºçš„æ€è·¯ï¼Œè®¡ç®—æœºè§£å†³é—®é¢˜æœ€å¼€å§‹çš„æ–¹æ³•å°±æ˜¯ç©·ä¸¾ï¼Œäººä»¬åªæ˜¯æŒæ¡äº†æ–¹æ³•ï¼Œè®©è®¡ç®—æœºå­¦ä¼šå»èªæ˜çš„ç©·ä¸¾ã€‚ç»¼ä¸Šï¼Œè¿™æ˜¯æˆ‘ç†è§£çš„DFSå­˜åœ¨çš„ç°å®æ„ä¹‰ä¸å…¶é‡è¦æ€§ã€‚ DPSç®—æ³•çš„è®¾è®¡åˆ†æ åœ¨å­¦ä¹ ä¹¦å†™DFSå‰ä¸€å®šè¦å­¦ä¼šä¹¦å†™æ ‘çš„éå†ï¼ˆé€’å½’éå†ï¼‰ res.append(root.val) preorder(root.left) preorder(root.right) ç†è§£äº†æ ‘çš„é€’å½’éå†ä¹‹åï¼Œæ‰èƒ½ä¹¦å†™å‡ºDFSé€’å½’çš„é€»è¾‘ã€‚æœ€æœ¬è´¨çš„è¿˜æ˜¯è¦ç†è§£é€’å½’çš„é€»è¾‘~ DFSä¹¦å†™å¥—è·¯ï¼š 1.å®šä¹‰å­˜æ”¾ç»“æœå˜é‡ vector&lt;vector&lt;int&gt;&gt; res;//å­˜æ”¾æœ€ç»ˆç»“æœ vector&lt;int&gt; path;//å­˜æ”¾è·¯å¾„ 2.å›æº¯å‡½æ•°çš„æ¡†æ¶ä¹¦å†™ä¸å‚æ•°çš„ç¡®å®š void backtrack(å‚æ•°......) 3.é€’å½’è¿‡ç¨‹ä¸­æœç´¢çš„é€»è¾‘ DFSç®—æ³•ä¸å›æº¯ç®—æ³•çš„å…³ç³» DFSç®—æ³•ä¹¦å†™çš„æ¨¡æ¿å¥—è·¯ DFSçš„ç®—æ³•å¥—è·¯ä¹¦å†™å…³é”®åœ¨äºæ­£ç¡®ç†è§£é€’å½’å‡½æ•°çš„å‚æ•°è°ƒç”¨ä¸ç»ˆæ­¢æ¡ä»¶çš„ç¡®ç«‹ã€‚ å›æº¯ç®—æ³• å›æº¯é“ºå«:äºŒå‰æ ‘çš„æ‰€æœ‰è·¯å¾„ ** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private: void traversal(TreeNode* cur,vector&lt;int&gt; &amp;path,vector&lt;string&gt; &amp;res){ path.push_back(cur-&gt;val); //åˆ°è¾¾å¶å­ç»“ç‚¹ if(cur-&gt;left == NULL &amp;&amp; cur-&gt;right == NULL){ string spath; for(int i = 0;i &lt; path.size() - 1;i++){ spath += to_string(path[i]); spath += &quot;-&gt;&quot;; } spath += to_string(path[path.size() - 1]); res.push_back(spath); return; } if(cur-&gt;left){ traversal(cur-&gt;left,path,res); path.pop_back();//å›æº¯ } if(cur-&gt;right){ traversal(cur-&gt;right,path,res); path.pop_back();//å›æº¯ } } public: vector&lt;string&gt; binaryTreePaths(TreeNode* root) { vector&lt;string&gt; res; vector&lt;int&gt; path; if(root == NULL) return res; traversal(root,path,res); return res; } }; å›æº¯ç®—æ³•å’Œæˆ‘ä»¬å¸¸è¯´çš„ DFS ç®—æ³•éå¸¸ç±»ä¼¼ï¼Œæœ¬è´¨ä¸Šå°±æ˜¯ä¸€ç§æš´åŠ›ç©·ä¸¾ç®—æ³•ã€‚å›æº¯ç®—æ³•å’Œ DFS ç®—æ³•çš„ç»†å¾®å·®åˆ«æ˜¯ï¼šå›æº¯ç®—æ³•æ˜¯åœ¨éå†ã€Œæ ‘æã€ï¼ŒDFS ç®—æ³•æ˜¯åœ¨éå†ã€ŒèŠ‚ç‚¹ã€ã€‚ å›æº¯ç®—æ³•è§£å†³ä»ä¸Šåˆ°ä¸‹ä¸€æ¬¡éå†æ•´é¢—æ ‘ï¼Œåœ¨å…¶æ¨¡æ¿ä¸­ï¼Œè¿ç”¨forå¾ªç¯å»æ¨ªå‘éå†â€”â€”åšé€‰æ‹©ï¼›åˆ©ç”¨é€’å½’ï¼ˆå›æº¯å‡½æ•°ï¼‰å»çºµå‘éå†â€”â€”è·¯å¾„ã€‚ è·¯å¾„ã€é€‰æ‹©ã€ç»ˆæ­¢æ¡ä»¶ #ä¸œå“¥æ¨¡æ¿ result = [] def backtrack(è·¯å¾„, é€‰æ‹©åˆ—è¡¨): if æ»¡è¶³ç»“æŸæ¡ä»¶: result.add(è·¯å¾„) return for é€‰æ‹© in é€‰æ‹©åˆ—è¡¨: åšé€‰æ‹© backtrack(è·¯å¾„, é€‰æ‹©åˆ—è¡¨) æ’¤é”€é€‰æ‹© //å¡å“¥æ¨¡æ¿ void backtrack(å‚æ•°){ if(ç»ˆæ­¢æ¡ä»¶){ å­˜æ”¾ç»“æœ; return; } for(é€‰æ‹©:æœ¬å±‚é›†åˆä¸­çš„å…ƒç´ ){ å¤„ç†èŠ‚ç‚¹; backtrack(è·¯å¾„ï¼Œé€‰æ‹©); å›æº¯,æ’¤é”€ç»“æœ; } } å›æº¯ç®—æ³•å°±æ˜¯ä¸ªå¤šå‰æ ‘çš„éå†é—®é¢˜ï¼Œå…³é”®å°±æ˜¯åœ¨å‰åºéå†å’Œååºéå†çš„ä½ç½®åšä¸€äº›æ“ä½œ: def backtrack(...): for é€‰æ‹© in é€‰æ‹©åˆ—è¡¨: åšé€‰æ‹© backtrack(...) æ’¤é”€é€‰æ‹© å†™ backtrack å‡½æ•°æ—¶ï¼Œéœ€è¦ç»´æŠ¤èµ°è¿‡çš„ã€Œè·¯å¾„ã€å’Œå½“å‰å¯ä»¥åšçš„ã€Œé€‰æ‹©åˆ—è¡¨ã€ï¼Œå½“è§¦å‘ã€Œç»“æŸæ¡ä»¶ã€æ—¶ï¼Œå°†ã€Œè·¯å¾„ã€è®°å…¥ç»“æœé›†ã€‚ å›æº¯æ³•ä¸­çš„å‚æ•°ä¸æ˜¯ä¸€æ¬¡æ€§å°±å¯ä»¥å®Œå…¨ç¡®å®šä¸‹æ¥ï¼Œä¸€èˆ¬å…ˆå†™é€»è¾‘ï¼Œéœ€è¦ä»€ä¹ˆå‚æ•°å°±å¯ä»¥å¡«å†™ä»€ä¹ˆå‚æ•°ã€‚ æ— è®ºæ˜¯æ’åˆ—ã€ç»„åˆè¿˜æ˜¯å­é›†é—®é¢˜ï¼Œç®€å•è¯´æ— éå°±æ˜¯è®©ä½ ä»åºåˆ— nums ä¸­ä»¥ç»™å®šè§„åˆ™å–è‹¥å¹²å…ƒç´ ï¼Œä¸»è¦æœ‰ä»¥ä¸‹å‡ ç§å˜ä½“ï¼š å½¢å¼ä¸€ã€å…ƒç´ æ— é‡ä¸å¯å¤é€‰ï¼Œå³ nums ä¸­çš„å…ƒç´ éƒ½æ˜¯å”¯ä¸€çš„ï¼Œæ¯ä¸ªå…ƒç´ æœ€å¤šåªèƒ½è¢«ä½¿ç”¨ä¸€æ¬¡ï¼Œè¿™ä¹Ÿæ˜¯æœ€åŸºæœ¬çš„å½¢å¼ã€‚ ä»¥ç»„åˆä¸ºä¾‹ï¼Œå¦‚æœè¾“å…¥ nums = [2,3,6,7]ï¼Œå’Œä¸º 7 çš„ç»„åˆåº”è¯¥åªæœ‰ [7]ã€‚ /* ç»„åˆ/å­é›†é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶ */ void backtrack(int[] nums, int start) { // å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶ for (int i = start; i &lt; nums.length; i++) { // åšé€‰æ‹© track.addLast(nums[i]); // æ³¨æ„å‚æ•° backtrack(nums, i + 1); // æ’¤é”€é€‰æ‹© track.removeLast(); } } /* æ’åˆ—é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶ */ void backtrack(int[] nums) { for (int i = 0; i &lt; nums.length; i++) { // å‰ªæé€»è¾‘ if (used[i]) { continue; } // åšé€‰æ‹© used[i] = true; track.addLast(nums[i]); backtrack(nums); // æ’¤é”€é€‰æ‹© track.removeLast(); used[i] = false; } } å½¢å¼äºŒã€å…ƒç´ å¯é‡ä¸å¯å¤é€‰ï¼Œå³ nums ä¸­çš„å…ƒç´ å¯ä»¥å­˜åœ¨é‡å¤ï¼Œæ¯ä¸ªå…ƒç´ æœ€å¤šåªèƒ½è¢«ä½¿ç”¨ä¸€æ¬¡ã€‚ ä»¥ç»„åˆä¸ºä¾‹ï¼Œå¦‚æœè¾“å…¥ nums = [2,5,2,1,2]ï¼Œå’Œä¸º 7 çš„ç»„åˆåº”è¯¥æœ‰ä¸¤ç§ [2,2,2,1] å’Œ [5,2]ã€‚ Arrays.sort(nums); /* ç»„åˆ/å­é›†é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶ */ void backtrack(int[] nums, int start) { // å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶ for (int i = start; i &lt; nums.length; i++) { // å‰ªæé€»è¾‘ï¼Œè·³è¿‡å€¼ç›¸åŒçš„ç›¸é‚»æ ‘æ if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) { continue; } // åšé€‰æ‹© track.addLast(nums[i]); // æ³¨æ„å‚æ•° backtrack(nums, i + 1); // æ’¤é”€é€‰æ‹© track.removeLast(); } } Arrays.sort(nums); /* æ’åˆ—é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶ */ void backtrack(int[] nums) { for (int i = 0; i &lt; nums.length; i++) { // å‰ªæé€»è¾‘ if (used[i]) { continue; } // å‰ªæé€»è¾‘ï¼Œå›ºå®šç›¸åŒçš„å…ƒç´ åœ¨æ’åˆ—ä¸­çš„ç›¸å¯¹ä½ç½® if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) { continue; } // åšé€‰æ‹© used[i] = true; track.addLast(nums[i]); backtrack(nums); // æ’¤é”€é€‰æ‹© track.removeLast(); used[i] = false; } } å½¢å¼ä¸‰ã€å…ƒç´ æ— é‡å¯å¤é€‰ï¼Œå³ nums ä¸­çš„å…ƒç´ éƒ½æ˜¯å”¯ä¸€çš„ï¼Œæ¯ä¸ªå…ƒç´ å¯ä»¥è¢«ä½¿ç”¨è‹¥å¹²æ¬¡ã€‚ ä¸Šé¢ç”¨ç»„åˆé—®é¢˜ä¸¾çš„ä¾‹å­ï¼Œä½†æ’åˆ—ã€ç»„åˆã€å­é›†é—®é¢˜éƒ½å¯ä»¥æœ‰è¿™ä¸‰ç§åŸºæœ¬å½¢å¼ï¼Œæ‰€ä»¥å…±æœ‰ 9 ç§å˜åŒ–ã€‚ é™¤æ­¤ä¹‹å¤–ï¼Œé¢˜ç›®ä¹Ÿå¯ä»¥å†æ·»åŠ å„ç§é™åˆ¶æ¡ä»¶ï¼Œæ¯”å¦‚è®©ä½ æ±‚å’Œä¸º target ä¸”å…ƒç´ ä¸ªæ•°ä¸º k çš„ç»„åˆï¼Œé‚£è¿™ä¹ˆä¸€æ¥åˆå¯ä»¥è¡ç”Ÿå‡ºä¸€å †å˜ä½“ï¼Œæ€ªä¸å¾—é¢è¯•ç¬”è¯•ä¸­ç»å¸¸è€ƒåˆ°æ’åˆ—ç»„åˆè¿™ç§åŸºæœ¬é¢˜å‹ã€‚ /* ç»„åˆ/å­é›†é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶ */ void backtrack(int[] nums, int start) { // å›æº¯ç®—æ³•æ ‡å‡†æ¡†æ¶ for (int i = start; i &lt; nums.length; i++) { // åšé€‰æ‹© track.addLast(nums[i]); // æ³¨æ„å‚æ•° backtrack(nums, i); // æ’¤é”€é€‰æ‹© track.removeLast(); } } /* æ’åˆ—é—®é¢˜å›æº¯ç®—æ³•æ¡†æ¶ */ void backtrack(int[] nums) { for (int i = 0; i &lt; nums.length; i++) { // åšé€‰æ‹© track.addLast(nums[i]); backtrack(nums); // æ’¤é”€é€‰æ‹© track.removeLast(); } } ä½†æ— è®ºå½¢å¼æ€ä¹ˆå˜åŒ–ï¼Œå…¶æœ¬è´¨å°±æ˜¯ç©·ä¸¾æ‰€æœ‰è§£ï¼Œè€Œè¿™äº›è§£å‘ˆç°æ ‘å½¢ç»“æ„ï¼Œæ‰€ä»¥åˆç†ä½¿ç”¨å›æº¯ç®—æ³•æ¡†æ¶ï¼Œç¨æ”¹ä»£ç æ¡†æ¶å³å¯æŠŠè¿™äº›é—®é¢˜ä¸€ç½‘æ‰“å°½ã€‚ æ’åˆ—é—®é¢˜ ç»™å®šä¸€ä¸ªä¸å«é‡å¤æ•°å­—çš„æ•°ç»„ nums ï¼Œè¿”å›å…¶ æ‰€æœ‰å¯èƒ½çš„å…¨æ’åˆ— ã€‚ä½ å¯ä»¥ æŒ‰ä»»æ„é¡ºåº è¿”å›ç­”æ¡ˆã€‚ class Solution { public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; void backtrack(vector&lt;int&gt;&amp; nums,vector&lt;bool&gt;&amp; used){ //æ­¤æ—¶æ‰¾åˆ°è¯´æ˜æ‰¾åˆ°äº†ä¸€ç»„ if(path.size() == nums.size()){ res.push_back(path); return; } for(int i = 0;i &lt; nums.size();i++){ if(used[i] == true) continue;//è¯´æ˜pathä¸­å·²ç»æ”¶é›†åˆ°äº†è¯¥å…ƒç´  used[i] = true; path.push_back(nums[i]); backtrack(nums,used); path.pop_back(); used[i] = false; } } vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { res.clear(); path.clear(); vector&lt;bool&gt; used(nums.size(),false); backtrack(nums,used); return res; } }; 216.ç»„åˆæ€»æ•°|| æ‰¾å‡ºæ‰€æœ‰ç›¸åŠ ä¹‹å’Œä¸º n çš„ k ä¸ªæ•°çš„ç»„åˆï¼Œä¸”æ»¡è¶³ä¸‹åˆ—æ¡ä»¶ï¼š åªä½¿ç”¨æ•°å­—1åˆ°9ï¼Œæ¯ä¸ªæ•°å­— æœ€å¤šä½¿ç”¨ä¸€æ¬¡ è¿”å› æ‰€æœ‰å¯èƒ½çš„æœ‰æ•ˆç»„åˆçš„åˆ—è¡¨ ã€‚è¯¥åˆ—è¡¨ä¸èƒ½åŒ…å«ç›¸åŒçš„ç»„åˆä¸¤æ¬¡ï¼Œç»„åˆå¯ä»¥ä»¥ä»»ä½•é¡ºåºè¿”å›ã€‚ class Solution { private: //è®¾ç½®äºŒç»´ç»“æœæ•°ç»„ä¸è·¯åŠ²æ•°ç»„ vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; void backtrack(int tarSum,int k,int sum,int startIndex){ //æ­¤æ—¶æ‰¾åˆ°äº†ä¸€ç»„ if(path.size() == k){ if(sum == tarSum) res.push_back(path); return; } //å•å±‚é€’å½’çš„é€»è¾‘ for(int i = startIndex;i &lt;= 9;i++){ sum += i; path.push_back(i); //æ³¨æ„å‚æ•°çš„å–å€¼æ˜¯i+1ï¼Œè°ƒæ•´ä¸‹ä¸€å±‚é€’å½’çš„startIndex backtrack(tarSum,k,sum,i + 1); sum -= i;//å›æº¯ path.pop_back();//å›æº¯ } } public: vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) { res.clear(); path.clear(); backtrack(n,k,0,1); return res; } }; ç»„åˆæ€»å’Œ 39ï¼š ç»™ä½ ä¸€ä¸ª æ— é‡å¤å…ƒç´  çš„æ•´æ•°æ•°ç»„ candidates å’Œä¸€ä¸ªç›®æ ‡æ•´æ•° target ï¼Œæ‰¾å‡º candidates ä¸­å¯ä»¥ä½¿æ•°å­—å’Œä¸ºç›®æ ‡æ•° target çš„ æ‰€æœ‰ ä¸åŒç»„åˆ ï¼Œå¹¶ä»¥åˆ—è¡¨å½¢å¼è¿”å›ã€‚ä½ å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›è¿™äº›ç»„åˆã€‚ candidates ä¸­çš„ åŒä¸€ä¸ª æ•°å­—å¯ä»¥ æ— é™åˆ¶é‡å¤è¢«é€‰å– ã€‚å¦‚æœè‡³å°‘ä¸€ä¸ªæ•°å­—çš„è¢«é€‰æ•°é‡ä¸åŒï¼Œåˆ™ä¸¤ç§ç»„åˆæ˜¯ä¸åŒçš„ã€‚ å¯¹äºç»™å®šçš„è¾“å…¥ï¼Œä¿è¯å’Œä¸º target çš„ä¸åŒç»„åˆæ•°å°‘äº 150ä¸ªã€‚ class Solution { private: //å®šä¹‰å…¨å±€å˜é‡å­˜æ”¾ç»“æœ vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; void backtrack(vector&lt;int&gt;&amp; candidates,int target,int sum,int startIndex){ if(sum &gt; target){ return; } if(sum == target){ res.push_back(path); return; } for(int i = startIndex;i &lt;candidates.size();i++){ sum += candidates[i]; path.push_back(candidates[i]); //ä¸éœ€è¦i+1ï¼Œè¡¨ç¤ºå¯ä»¥ä»è‡ªèº«å¼€å§‹å– backtrack(candidates,target,sum,i); sum -= candidates[i]; path.pop_back(); } } public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { path.clear(); res.clear(); backtrack(candidates,target,0,0); return res; } }; 40ï¼š ç»™å®šä¸€ä¸ªå€™é€‰äººç¼–å·çš„é›†åˆ candidates å’Œä¸€ä¸ªç›®æ ‡æ•° target ï¼Œæ‰¾å‡º candidates ä¸­æ‰€æœ‰å¯ä»¥ä½¿æ•°å­—å’Œä¸º target çš„ç»„åˆã€‚ candidates ä¸­çš„æ¯ä¸ªæ•°å­—åœ¨æ¯ä¸ªç»„åˆä¸­åªèƒ½ä½¿ç”¨ ä¸€æ¬¡ ã€‚ æ³¨æ„ï¼šè§£é›†ä¸èƒ½åŒ…å«é‡å¤çš„ç»„åˆã€‚ æ³¨æ„æœ¬é¢˜ä¸å‰ä¸€é¢˜çš„ä¸»è¦åŒºåˆ«åœ¨äºï¼Œæœ¬é¢˜ä¸­çš„candidatesä¸­å­˜åœ¨é‡å¤çš„å…ƒç´ ï¼Œåœ¨å›æº¯è¿‡ç¨‹ä¸­ï¼ŒåŒä¸€å±‚çš„éå†è¦æ³¨æ„é¿å…é‡å¤å…ƒç´ çš„ä½¿ç”¨ã€‚ å¢åŠ äº†usedæ•°ç»„æ¥åˆ¤æ–­é‡å¤å…ƒç´ çš„ä½¿ç”¨æ¬¡æ•°ï¼Œä»è€Œé¿å…é‡å¤å…ƒç´ çš„ä½¿ç”¨æƒ…å†µã€‚ class Solution { private: //å®šä¹‰å…¨å±€å˜é‡ //æœ¬é¢˜çš„åŒºåˆ«åœ¨äºï¼Œcandidatesä¸­å­˜åœ¨é‡å¤å…ƒç´ ï¼Œè¦æƒ³åŠæ³•è¿›è¡Œå»é‡ vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; void backtrack(vector&lt;int&gt;&amp; candidates, int target,int sum,int startIndex,vector&lt;bool&gt;&amp; used){ if(sum &gt; target){ return; } if(sum == target){ res.push_back(path); return; } for(int i = startIndex;i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target;i++){ if(i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; used[i - 1] == false){ continue; } sum += candidates[i]; path.push_back(candidates[i]); used[i] = true; backtrack(candidates,target,sum,i + 1,used); used[i] = false; sum -= candidates[i]; path.pop_back(); } } public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) { vector&lt;bool&gt; used(candidates.size(),false); path.clear(); res.clear(); sort(candidates.begin(),candidates.end()); backtrack(candidates,target,0,0,used); return res; } }; å­é›†é—®é¢˜ ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œæ•°ç»„ä¸­çš„å…ƒç´  äº’ä¸ç›¸åŒ ã€‚è¿”å›è¯¥æ•°ç»„æ‰€æœ‰å¯èƒ½çš„å­é›†ï¼ˆå¹‚é›†ï¼‰ã€‚ è§£é›† ä¸èƒ½ åŒ…å«é‡å¤çš„å­é›†ã€‚ä½ å¯ä»¥æŒ‰ ä»»æ„é¡ºåº è¿”å›è§£é›†ã€‚ class Solution { private: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; void backtrack(vector&lt;int&gt;&amp; nums,int startIndex){ res.push_back(path);//æ”¶é›†å­é›†è¦æ”¾åœ¨ç»ˆæ­¢æ¡ä»¶ä¸Šé¢å¦åˆ™ä¼šæ¼æ‰ if(startIndex &gt;= nums.size()){ return; } for(int i = startIndex;i &lt; nums.size();i++){ path.push_back(nums[i]); backtrack(nums,i + 1); path.pop_back(); } } public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { path.clear(); res.clear(); backtrack(nums,0); return res; } }; numä¸­å­˜åœ¨å¯é‡å¤å…ƒç´ æ—¶çš„æƒ…å†µæ—¶åŒæ ·é‡‡ç”¨usedæ•°ç»„è¿›è¡Œé‡å¤é¿å…ã€‚ æ¢å¥è¯è¯´ï¼Œæˆ‘ä»¬é€šè¿‡ä¿è¯å…ƒç´ ä¹‹é—´çš„ç›¸å¯¹é¡ºåºä¸å˜æ¥é˜²æ­¢å‡ºç°é‡å¤çš„å­é›†ã€‚ å«æœ‰é‡å¤å…ƒç´ æ—¶ä¸€å®šè¦æ³¨æ„åœ¨æœ€åä¸»å‡½æ•°ä¸­å…ˆå¯¹é¢˜ç»™é›†åˆå…ˆè¿›è¡Œæ’åºã€‚ class Solution { private: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; void backtrack(vector&lt;int&gt;&amp; nums,int startIndex,vector&lt;bool&gt;&amp; used){ res.push_back(path); if(startIndex &gt;= nums.size()){ return; } for(int i = startIndex;i &lt; nums.size();i++){ if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == false){ continue; } path.push_back(nums[i]); used[i] = true; backtrack(nums,i + 1,used); used[i] = false; path.pop_back(); } } public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) { vector&lt;bool&gt; used(nums.size(),false); res.clear(); path.clear(); //å»é‡è¦æ’åº sort(nums.begin(),nums.end()); backtrack(nums, 0, used); return res; } }; Nçš‡å æŒ‰ç…§å›½é™…è±¡æ£‹çš„è§„åˆ™ï¼Œçš‡åå¯ä»¥æ”»å‡»ä¸ä¹‹å¤„åœ¨åŒä¸€è¡Œæˆ–åŒä¸€åˆ—æˆ–åŒä¸€æ–œçº¿ä¸Šçš„æ£‹å­ã€‚ n çš‡åé—®é¢˜ ç ”ç©¶çš„æ˜¯å¦‚ä½•å°† n ä¸ªçš‡åæ”¾ç½®åœ¨ nÃ—n çš„æ£‹ç›˜ä¸Šï¼Œå¹¶ä¸”ä½¿çš‡åå½¼æ­¤ä¹‹é—´ä¸èƒ½ç›¸äº’æ”»å‡»ã€‚ ç»™ä½ ä¸€ä¸ªæ•´æ•° n ï¼Œè¿”å›æ‰€æœ‰ä¸åŒçš„ n çš‡åé—®é¢˜ çš„è§£å†³æ–¹æ¡ˆã€‚ æ¯ä¸€ç§è§£æ³•åŒ…å«ä¸€ä¸ªä¸åŒçš„ n çš‡åé—®é¢˜ çš„æ£‹å­æ”¾ç½®æ–¹æ¡ˆï¼Œè¯¥æ–¹æ¡ˆä¸­ 'Q' å’Œ '.' åˆ†åˆ«ä»£è¡¨äº†çš‡åå’Œç©ºä½ã€‚ è´ªå¿ƒç®—æ³• åŠ¨æ€è§„åˆ’ åŠ¨æ€è§„åˆ’çš„æ ¸å¿ƒè®¾è®¡æ€æƒ³æ˜¯æ•°å­¦å½’çº³æ³•ï¼Œç›¸ä¿¡å¤§å®¶å¯¹æ•°å­¦å½’çº³æ³•éƒ½ä¸é™Œç”Ÿï¼Œé«˜ä¸­å°±å­¦è¿‡ï¼Œè€Œä¸”æ€è·¯å¾ˆç®€å•ã€‚æ¯”å¦‚æˆ‘ä»¬æƒ³è¯æ˜ä¸€ä¸ªæ•°å­¦ç»“è®ºï¼Œé‚£ä¹ˆæˆ‘ä»¬å…ˆå‡è®¾è¿™ä¸ªç»“è®ºåœ¨ k &lt; n æ—¶æˆç«‹ï¼Œç„¶åæ ¹æ®è¿™ä¸ªå‡è®¾ï¼Œæƒ³åŠæ³•æ¨å¯¼è¯æ˜å‡º k = n çš„æ—¶å€™æ­¤ç»“è®ºä¹Ÿæˆç«‹ã€‚å¦‚æœèƒ½å¤Ÿè¯æ˜å‡ºæ¥ï¼Œé‚£ä¹ˆå°±è¯´æ˜è¿™ä¸ªç»“è®ºå¯¹äº k ç­‰äºä»»ä½•æ•°éƒ½æˆç«‹ã€‚ ç±»ä¼¼çš„ï¼Œæˆ‘ä»¬è®¾è®¡åŠ¨æ€è§„åˆ’ç®—æ³•ï¼Œä¸æ˜¯éœ€è¦ä¸€ä¸ª dp æ•°ç»„å—ï¼Ÿæˆ‘ä»¬å¯ä»¥å‡è®¾ dp[0...i-1] éƒ½å·²ç»è¢«ç®—å‡ºæ¥äº†ï¼Œç„¶åé—®è‡ªå·±ï¼šæ€ä¹ˆé€šè¿‡è¿™äº›ç»“æœç®—å‡º dp[i]ï¼Ÿè¿™ä¹Ÿæ˜¯æ ‡å‡†çš„åŠ¨æ€è§„åˆ’ä¸­çš„é€†åºè§£æ³•ã€‚ é¦–å…ˆè¦å®šä¹‰æ¸…æ¥š dp æ•°ç»„çš„å«ä¹‰ï¼Œå³ dp[i] çš„å€¼åˆ°åº•ä»£è¡¨ç€ä»€ä¹ˆï¼Ÿ åŠ¨æ€è§„åˆ’åŸºç¡€ -&gt;åˆ©ç”¨å­é—®é¢˜çš„æœ€ä¼˜è§£å»æ±‚è§£å…¨å±€æœ€ä¼˜è§£;å–„äºåˆ©ç”¨äºŒä½è¡¨å¯»æ‰¾æ€è·¯ã€‚ åŠ¨æ€è§„åˆ’é—®é¢˜çš„ä¸€èˆ¬å½¢å¼å°±æ˜¯æ±‚æœ€å€¼ï¼ŒåŠ¨æ€è§„åˆ’å…¶å®æ˜¯è¿ç­¹å­¦çš„ä¸€ç§æœ€ä¼˜åŒ–æ–¹æ³•ï¼Œåªä¸è¿‡åœ¨è®¡ç®—æœºé—®é¢˜ä¸Šåº”ç”¨æ¯”è¾ƒå¤šã€‚æ—¢ç„¶æ˜¯è¦æ±‚æœ€å€¼ï¼Œæ ¸å¿ƒé—®é¢˜æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿæ±‚è§£åŠ¨æ€è§„åˆ’çš„æ ¸å¿ƒé—®é¢˜æ˜¯ç©·ä¸¾ã€‚å› ä¸ºè¦æ±‚æœ€å€¼ï¼Œè‚¯å®šè¦æŠŠæ‰€æœ‰å¯è¡Œçš„ç­”æ¡ˆç©·ä¸¾å‡ºæ¥ï¼Œç„¶ååœ¨å…¶ä¸­æ‰¾æœ€å€¼å‘—ã€‚ä½†æ˜¯ï¼Œç©·ä¸¾æ‰€æœ‰å¯è¡Œè§£å…¶å®å¹¶ä¸æ˜¯ä¸€ä»¶å®¹æ˜“çš„äº‹ï¼Œéœ€è¦ä½ ç†Ÿç»ƒæŒæ¡é€’å½’æ€ç»´ï¼Œåªæœ‰åˆ—å‡ºæ­£ç¡®çš„ã€ŒçŠ¶æ€è½¬ç§»æ–¹ç¨‹ã€ï¼Œæ‰èƒ½æ­£ç¡®åœ°ç©·ä¸¾ã€‚å› æ­¤ï¼Œå†™å‡ºçŠ¶æ€è½¬ç§»æ–¹ç¨‹çš„ä¸€èˆ¬æ€è·¯æ˜¯ï¼š æ˜ç¡® base case -&gt; æ˜ç¡®ã€ŒçŠ¶æ€ã€-&gt; æ˜ç¡®ã€Œé€‰æ‹©ã€ -&gt; å®šä¹‰ dp æ•°ç»„/å‡½æ•°çš„å«ä¹‰ã€‚ åœ¨**æ˜ç¡®ã€Œé€‰æ‹©ã€çš„æ€è€ƒæ˜¯å°±ä½“ç°å‡ºæ¥â€œæ ‘â€**çš„å½±å­ï¼Œå¯ä»¥ç”»å‡ºæ ‘å½¢ç»“æ„æ¥è¾…åŠ©æ€è€ƒæœ€ä¼˜è§£çš„è·¯å¾„ é’ˆå¯¹æ¯é“é¢˜åº”è¯¥æœ‰çš„æ€è€ƒï¼š ç¡®å®šdpæ•°ç»„ä»¥åŠä¸‹æ ‡çš„å«ä¹‰ dp[i]çš„å®šä¹‰ä¸ºï¼šç¬¬iä¸ªæ•°çš„æ–æ³¢é‚£å¥‘æ•°å€¼æ˜¯dp[i] ç¡®å®šé€’æ¨å…¬å¼ ä¸ºä»€ä¹ˆè¿™æ˜¯â¼€é“â¾®å¸¸ç®€å•çš„â¼Šâ»”é¢˜â½¬å‘¢ï¼Ÿ å› ä¸ºé¢˜â½¬å·²ç»æŠŠé€’æ¨å…¬å¼ç›´æ¥ç»™æˆ‘ä»¬äº†ï¼šçŠ¶æ€è½¬ç§»â½…ç¨‹ dp[i] = dp[i - 1] + dp[i - 2]; dpæ•°ç»„å¦‚ä½•åˆå§‹åŒ– å¯¹äºå‰ææ‰€éœ€å…ƒç´ å¦‚ä½•è¿›è¡Œèµ‹å€¼ï¼›ä¾‹å¦‚çˆ¬æ¥¼æ¢¯ä¸æ–æ³¢é‚£å¥‘æ•°åˆ—ä¸­dp[0]ä¸dp[1]çš„èµ‹å€¼ ç¡®å®šéå†é¡ºåº ä»é€’å½’å…¬å¼dp[i] = dp[i - 1] + dp[i - 2];ä¸­å¯ä»¥çœ‹å‡ºï¼Œdp[i]æ˜¯ä¾èµ– dp[i - 1] å’Œ dp[i - 2]ï¼Œé‚£ä¹ˆéå†çš„é¡ºåº â¼€å®šæ˜¯ä»å‰åˆ°åéå†çš„ ä¸¾ä¾‹æ¨å¯¼dpæ•°ç»„ åŠ¨æ€è§„åˆ’ä¹¦å†™æ¡†æ¶ 1.ç¡®å®šbase case 2.ç©·ä¸¾æ‰€æœ‰ç»“æœ 3.çŠ¶æ€è½¬ç§» æ‘†è„±ç¼–ç¨‹çš„é»‘ç›’çŠ¶æ€ï¼šé¢˜ç›®åœ¨äºç²¾ï¼›éœ€è¦æ³¨æ„ï¼šæ¯é“é¢˜ä¸­dp[]æ•°ç»„åŠå…¶ä¸‹æ ‡çš„å«ä¹‰ã€é€’æ¨å…¬å¼ã€dpæ•°ç»„å¦‚ä½•åˆå§‹åŒ–ã€éå†é¡ºåºã€æ‰“å°dpæ•°ç»„ã€‚ åŠ¨æ€è§„åˆ’çš„éš¾ç‚¹æœ¬æ¥å°±åœ¨äºå¯»æ‰¾æ­£ç¡®çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼Œè®¾è®¡åŠ¨æ€è§„åˆ’çš„é€šç”¨æŠ€å·§ï¼šæ•°å­¦å½’çº³æ€æƒ³ã€‚ # è‡ªé¡¶å‘ä¸‹é€’å½’çš„åŠ¨æ€è§„åˆ’ def dp(çŠ¶æ€1, çŠ¶æ€2, ...): for é€‰æ‹© in æ‰€æœ‰å¯èƒ½çš„é€‰æ‹©: # æ­¤æ—¶çš„çŠ¶æ€å·²ç»å› ä¸ºåšäº†é€‰æ‹©è€Œæ”¹å˜ result = æ±‚æœ€å€¼(result, dp(çŠ¶æ€1, çŠ¶æ€2, ...)) return result # è‡ªåº•å‘ä¸Šè¿­ä»£çš„åŠ¨æ€è§„åˆ’ # åˆå§‹åŒ– base case dp[0][0][...] = base case # è¿›è¡ŒçŠ¶æ€è½¬ç§» for çŠ¶æ€1 in çŠ¶æ€1çš„æ‰€æœ‰å–å€¼ï¼š for çŠ¶æ€2 in çŠ¶æ€2çš„æ‰€æœ‰å–å€¼ï¼š for ... dp[çŠ¶æ€1][çŠ¶æ€2][...] = æ±‚æœ€å€¼(é€‰æ‹©1ï¼Œé€‰æ‹©2...) æ–æ³¢é‚£å¥‘æ•°åˆ— æ–æ³¢é‚£å¥‘æ•°åˆ—è¿™é“é¢˜â½¬æ˜¯â¾®å¸¸åŸºç¡€çš„é¢˜â½¬ï¼Œé€šå¸¸â½¤ F(n) è¡¨ç¤ºï¼Œå½¢æˆçš„åºåˆ—ç§°ä¸º æ–æ³¢é‚£å¥‘æ•°åˆ— ã€‚è¯¥æ•°åˆ—ç”± 0 å’Œ 1 å¼€å§‹ï¼Œåâ¾¯çš„æ¯â¼€é¡¹ æ•°å­—éƒ½æ˜¯å‰â¾¯ä¸¤é¡¹æ•°å­—çš„å’Œã€‚ class Solution { public: int fib(int N) { if (N &lt;= 1) return N; vector&lt;int&gt; dp(N + 1); dp[0] = 0; dp[1] = 1; for (int i = 2; i &lt;= N; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[N]; } }; -&gt;æ—¶é—´å¤æ‚åº¦ï¼šO(n) -&gt;ç©ºé—´å¤æ‚åº¦ï¼šO(n) æ”¹è¿›ï¼š class Solution { public: int fib(int N) { if (N &lt;= 1) return N; int dp[2]; dp[0] = 0; dp[1] = 1; for (int i = 2; i &lt;= N; i++) { int sum = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = sum; } return dp[1]; } }; -&gt;æ—¶é—´å¤æ‚åº¦ï¼šO(n) -&gt;ç©ºé—´å¤æ‚åº¦ï¼šO(1) çˆ¬æ¥¼æ¢¯ å‡è®¾ä½ æ­£åœ¨çˆ¬æ¥¼æ¢¯ã€‚éœ€è¦ n é˜¶ä½ æ‰èƒ½åˆ°è¾¾æ¥¼é¡¶ã€‚ æ¯æ¬¡ä½ å¯ä»¥çˆ¬ 1 æˆ– 2 ä¸ªå°é˜¶ã€‚ä½ æœ‰å¤šå°‘ç§ä¸åŒçš„æ–¹æ³•å¯ä»¥çˆ¬åˆ°æ¥¼é¡¶å‘¢ï¼Ÿ ç¡®å®šdpæ•°ç»„ä»¥åŠä¸‹æ ‡çš„å«ä¹‰ dp[i]ï¼š çˆ¬åˆ°ç¬¬iå±‚æ¥¼æ¢¯ï¼Œæœ‰dp[i]ç§æ–¹æ³• 2.ç¡®å®šé€’æ¨å…¬å¼ å¦‚æœå¯ä»¥æ¨å‡ºdp[i]å‘¢ï¼Ÿ ä»dp[i]çš„å®šä¹‰å¯ä»¥çœ‹å‡ºï¼Œdp[i] å¯ä»¥æœ‰ä¸¤ä¸ªæ–¹å‘æ¨å‡ºæ¥ã€‚ é¦–å…ˆæ˜¯dp[i - 1]ï¼Œä¸Ši-1å±‚æ¥¼æ¢¯ï¼Œæœ‰dp[i - 1]ç§æ–¹æ³•ï¼Œé‚£ä¹ˆå†ä¸€æ­¥è·³ä¸€ä¸ªå°é˜¶ä¸å°±æ˜¯dp[i]äº†ä¹ˆã€‚ è¿˜æœ‰å°±æ˜¯dp[i - 2]ï¼Œä¸Ši-2å±‚æ¥¼æ¢¯ï¼Œæœ‰dp[i - 2]ç§æ–¹æ³•ï¼Œé‚£ä¹ˆå†ä¸€æ­¥è·³ä¸¤ä¸ªå°é˜¶ä¸å°±æ˜¯dp[i]äº†ä¹ˆã€‚ é‚£ä¹ˆdp[i]å°±æ˜¯ dp[i - 1]ä¸dp[i - 2]ä¹‹å’Œï¼ æ‰€ä»¥dp[i] = dp[i - 1] + dp[i - 2] ã€‚ åœ¨æ¨å¯¼dp[i]çš„æ—¶å€™ï¼Œä¸€å®šè¦æ—¶åˆ»æƒ³ç€dp[i]çš„å®šä¹‰ï¼Œå¦åˆ™å®¹æ˜“è·‘åã€‚ è¿™ä½“ç°å‡ºç¡®å®šdpæ•°ç»„ä»¥åŠä¸‹æ ‡çš„å«ä¹‰çš„é‡è¦æ€§ï¼ 3.dpæ•°ç»„å¦‚ä½•åˆå§‹åŒ– åœ¨å›é¡¾ä¸€ä¸‹dp[i]çš„å®šä¹‰ï¼šçˆ¬åˆ°ç¬¬iå±‚æ¥¼æ¢¯ï¼Œæœ‰dp[i]ä¸­æ–¹æ³•ã€‚ é‚£ä¹ˆiä¸º0ï¼Œdp[i]åº”è¯¥æ˜¯å¤šå°‘å‘¢ï¼Œè¿™ä¸ªå¯ä»¥æœ‰å¾ˆå¤šè§£é‡Šï¼Œä½†éƒ½åŸºæœ¬æ˜¯ç›´æ¥å¥”ç€ç­”æ¡ˆå»è§£é‡Šçš„ã€‚ ä¾‹å¦‚å¼ºè¡Œå®‰æ…°è‡ªå·±çˆ¬åˆ°ç¬¬0å±‚ï¼Œä¹Ÿæœ‰ä¸€ç§æ–¹æ³•ï¼Œä»€ä¹ˆéƒ½ä¸åšä¹Ÿå°±æ˜¯ä¸€ç§æ–¹æ³•å³ï¼šdp[0] = 1ï¼Œç›¸å½“äºç›´æ¥ç«™åœ¨æ¥¼é¡¶ã€‚ ä½†æ€»æœ‰ç‚¹ç‰µå¼ºçš„æˆåˆ†ã€‚ é‚£è¿˜è¿™ä¹ˆç†è§£å‘¢ï¼šæˆ‘å°±è®¤ä¸ºè·‘åˆ°ç¬¬0å±‚ï¼Œæ–¹æ³•å°±æ˜¯0å•Šï¼Œä¸€æ­¥åªèƒ½èµ°ä¸€ä¸ªå°é˜¶æˆ–è€…ä¸¤ä¸ªå°é˜¶ï¼Œç„¶è€Œæ¥¼å±‚æ˜¯0ï¼Œç›´æ¥ç«™æ¥¼é¡¶ä¸Šäº†ï¼Œå°±æ˜¯ä¸ç”¨æ–¹æ³•ï¼Œdp[0]å°±åº”è¯¥æ˜¯0. å…¶å®è¿™ä¹ˆäº‰è®ºä¸‹å»æ²¡æœ‰æ„ä¹‰ï¼Œå¤§éƒ¨åˆ†è§£é‡Šè¯´dp[0]åº”è¯¥ä¸º1çš„ç†ç”±å…¶å®æ˜¯å› ä¸ºdp[0]=1çš„è¯åœ¨é€’æ¨çš„è¿‡ç¨‹ä¸­iä»2å¼€å§‹éå†æœ¬é¢˜å°±èƒ½è¿‡ï¼Œç„¶åå°±å¾€ç»“æœä¸Šé å»è§£é‡Šdp[0] = 1ã€‚ ä»dpæ•°ç»„å®šä¹‰çš„è§’åº¦ä¸Šæ¥è¯´ï¼Œdp[0] = 0 ä¹Ÿèƒ½è¯´å¾—é€šã€‚ éœ€è¦æ³¨æ„çš„æ˜¯ï¼šé¢˜ç›®ä¸­è¯´äº†næ˜¯ä¸€ä¸ªæ­£æ•´æ•°ï¼Œé¢˜ç›®æ ¹æœ¬å°±æ²¡è¯´næœ‰ä¸º0çš„æƒ…å†µã€‚ æ‰€ä»¥æœ¬é¢˜å…¶å®å°±ä¸åº”è¯¥è®¨è®ºdp[0]çš„åˆå§‹åŒ–ï¼ æˆ‘ç›¸ä¿¡dp[1] = 1ï¼Œdp[2] = 2ï¼Œè¿™ä¸ªåˆå§‹åŒ–å¤§å®¶åº”è¯¥éƒ½æ²¡æœ‰äº‰è®®çš„ã€‚ æ‰€ä»¥æˆ‘çš„åŸåˆ™æ˜¯ï¼šä¸è€ƒè™‘dp[0]å¦‚æœåˆå§‹åŒ–ï¼Œåªåˆå§‹åŒ–dp[1] = 1ï¼Œdp[2] = 2ï¼Œç„¶åä»i = 3å¼€å§‹é€’æ¨ï¼Œè¿™æ ·æ‰ç¬¦åˆdp[i]çš„å®šä¹‰ã€‚ 4.ç¡®å®šéå†é¡ºåº ä»é€’æ¨å…¬å¼dp[i] = dp[i - 1] + dp[i - 2];ä¸­å¯ä»¥çœ‹å‡ºï¼Œéå†é¡ºåºä¸€å®šæ˜¯ä»å‰å‘åéå†çš„ 5.ä¸¾ä¾‹æ¨å¯¼dpæ•°ç»„ class Solution { public: int climbStairs(int n) { //1.dp[i]å«ä¹‰ï¼šè¾¾åˆ°ç¬¬ié˜¶å°é˜¶çš„æ–¹æ³•æ•°é‡ä¸ºdp[i] //2.ç¡®å®šé€’æ¨å…¬å¼dp[i] = dp[i-1] + dp[i-2] //3.åˆå§‹åŒ–:dp[0] = 1/0;dp[1] = 1,dp[2] = 2 if(n &lt;= 1) return n; //vector&lt;int&gt; dp(n + 1); int dp[n + 1]; dp[1] = 1; dp[2] = 2; for(int i = 3;i &lt;= n;i++){ dp[i] = dp[i-1] + dp[i-2]; } return dp[n]; } }; ç©ºé—´å¤æ‚åº¦ä¼˜åŒ– class Solution { public: int climbStairs(int n) { if (n &lt;= 1) return n; int dp[3]; dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; i++) { int sum = dp[1] + dp[2]; dp[1] = dp[2]; dp[2] = sum; } return dp[2]; } }; ä½¿ç”¨æœ€å°èŠ±è´¹çˆ¬æ¥¼æ¢¯ æ•°ç»„çš„æ¯ä¸ªä¸‹æ ‡ä½œä¸ºä¸€ä¸ªé˜¶æ¢¯ï¼Œç¬¬ i ä¸ªé˜¶æ¢¯å¯¹åº”ç€ä¸€ä¸ªéè´Ÿæ•°çš„ä½“åŠ›èŠ±è´¹å€¼ cost[i]ï¼ˆä¸‹æ ‡ä» 0 å¼€å§‹ï¼‰ã€‚ æ¯å½“ä½ çˆ¬ä¸Šä¸€ä¸ªé˜¶æ¢¯ä½ éƒ½è¦èŠ±è´¹å¯¹åº”çš„ä½“åŠ›å€¼ï¼Œä¸€æ—¦æ”¯ä»˜äº†ç›¸åº”çš„ä½“åŠ›å€¼ï¼Œä½ å°±å¯ä»¥é€‰æ‹©å‘ä¸Šçˆ¬ä¸€ä¸ªé˜¶æ¢¯æˆ–è€…çˆ¬ä¸¤ä¸ªé˜¶æ¢¯ã€‚ è¯·ä½ æ‰¾å‡ºè¾¾åˆ°æ¥¼å±‚é¡¶éƒ¨çš„æœ€ä½èŠ±è´¹ã€‚åœ¨å¼€å§‹æ—¶ï¼Œä½ å¯ä»¥é€‰æ‹©ä»ä¸‹æ ‡ä¸º 0 æˆ– 1 çš„å…ƒç´ ä½œä¸ºåˆå§‹é˜¶æ¢¯ã€‚ æ¯å½“ä½ çˆ¬ä¸Šä¸€ä¸ªé˜¶æ¢¯ä½ éƒ½è¦èŠ±è´¹å¯¹åº”çš„ä½“åŠ›å€¼ï¼Œä¸€æ—¦æ”¯ä»˜äº†ç›¸åº”çš„ä½“åŠ›å€¼ï¼Œä½ å°±å¯ä»¥é€‰æ‹©å‘ä¸Šçˆ¬ä¸€ä¸ªé˜¶æ¢¯æˆ–è€…çˆ¬ä¸¤ä¸ªé˜¶æ¢¯. dp[i]çš„å®šä¹‰ï¼šåˆ°è¾¾ç¬¬iä¸ªå°é˜¶æ‰€èŠ±è´¹çš„æœ€å°‘ä½“åŠ›ä¸ºdp[i]ã€‚dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];æ³¨æ„è¿™é‡Œä¸ºä»€ä¹ˆæ˜¯åŠ cost[i]ï¼Œè€Œä¸æ˜¯cost[i-1],cost[i-2]ä¹‹ç±»çš„ï¼Œå› ä¸ºé¢˜ç›®ä¸­è¯´äº†ï¼šæ¯å½“ä½ çˆ¬ä¸Šä¸€ä¸ªé˜¶æ¢¯ä½ éƒ½è¦èŠ±è´¹å¯¹åº”çš„ä½“åŠ›å€¼. class Solution { public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) { vector&lt;int&gt; dp(cost.size()); dp[0] = cost[0]; dp[1] = cost[1]; for (int i = 2; i &lt; cost.size(); i++) { dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]; } // æ³¨æ„æœ€åä¸€æ­¥å¯ä»¥ç†è§£ä¸ºä¸ç”¨èŠ±è´¹ï¼Œæ‰€ä»¥å–å€’æ•°ç¬¬ä¸€æ­¥ï¼Œç¬¬äºŒæ­¥çš„æœ€å°‘å€¼ return min(dp[cost.size() - 1], dp[cost.size() - 2]); } }; ä¼˜åŒ–ç©ºé—´å¤æ‚åº¦ class Solution { public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) { int dp0 = cost[0]; int dp1 = cost[1]; for (int i = 2; i &lt; cost.size(); i++) { int dpi = min(dp0, dp1) + cost[i]; dp0 = dp1; // è®°å½•ä¸€ä¸‹å‰ä¸¤ä½ dp1 = dpi; } return min(dp0, dp1); } }; ä¸¤ç§æ€è·¯ ç¬¬ä¸€ç§æ€è·¯æ¨¡æ¿æ˜¯ä¸€ä¸ªä¸€ç»´çš„ dp æ•°ç»„ int n = array.length; int[] dp = new int[n]; for (int i = 1; i &lt; n; i++) { for (int j = 0; j &lt; i; j++) { dp[i] = æœ€å€¼(dp[i], dp[j] + ...) } } æ¯”å¦‚æˆ‘ä»¬å†™è¿‡çš„ æœ€é•¿é€’å¢å­åºåˆ— å’Œ æœ€å¤§å­æ•°ç»„å’Œ éƒ½æ˜¯è¿™ä¸ªæ€è·¯ã€‚ åœ¨è¿™ä¸ªæ€è·¯ä¸­ dp æ•°ç»„çš„å®šä¹‰æ˜¯ï¼š åœ¨å­æ•°ç»„ arr[0..i] ä¸­ï¼Œæˆ‘ä»¬è¦æ±‚çš„å­åºåˆ—ï¼ˆæœ€é•¿é€’å¢å­åºåˆ—ï¼‰çš„é•¿åº¦æ˜¯ dp[i]ã€‚ class Solution { public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { //å®šä¹‰dpæ•°ç»„å¹¶åˆå§‹åŒ– vector&lt;int&gt; dp(nums.size(),1); //ä»¥nums[i]ç»“å°¾çš„å­åºåˆ—é•¿åº¦ for(int i = 0;i &lt; nums.size();i++){ for(int j = 0;j &lt; i;j++){ if(nums[i] &gt; nums[j]){ dp[i] = max(dp[i],dp[j]+1); } } } //å¯»æ‰¾dpæ•°ç»„ä¸­çš„æœ€å¤§å€¼ int res = 0; for(int j = 0;j &lt; dp.size();j++){ res = max(res,dp[j]); } return res; } }; ç¬¬äºŒç§æ€è·¯æ¨¡æ¿æ˜¯ä¸€ä¸ªäºŒç»´çš„ dp æ•°ç»„ int n = arr.length; int[][] dp = new dp[n][n]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (arr[i] == arr[j]) dp[i][j] = dp[i][j] + ... else dp[i][j] = æœ€å€¼(...) } } -&gt;æ¶‰åŠä¸¤ä¸ªå­—ç¬¦ä¸²/æ•°ç»„çš„åœºæ™¯ï¼Œdp æ•°ç»„çš„å®šä¹‰å¦‚ä¸‹ï¼š åœ¨å­æ•°ç»„ arr1[0..i] å’Œå­æ•°ç»„ arr2[0..j] ä¸­ï¼Œæˆ‘ä»¬è¦æ±‚çš„å­åºåˆ—é•¿åº¦ä¸º dp[i][j]ã€‚ -&gt;åªæ¶‰åŠä¸€ä¸ªå­—ç¬¦ä¸²/æ•°ç»„çš„åœºæ™¯ï¼Œdp æ•°ç»„çš„å®šä¹‰å¦‚ä¸‹ï¼š åœ¨å­æ•°ç»„ array[i..j] ä¸­ï¼Œæˆ‘ä»¬è¦æ±‚çš„å­åºåˆ—çš„é•¿åº¦ä¸º dp[i][j]ã€‚ æœªå®Œå¾…ç»­...... ","link":"https://Mungeryang.github.io/post/shu-ju-jie-gou/"},{"title":"ä»»æ­£éæ–‡é›†|æˆ‘çš„çˆ¶äº²æ¯äº²","content":" é€è€…å·²ç»é€å»ï¼Œæ´»ç€çš„è¿˜è¦å‰è¡Œ è¿™æ˜¯æˆ‘ä¸€ç”Ÿä¸­æœ€å¤§çš„æ†¾äº‹â€”â€”å¦‚æœ8æ—¥ä¸Šåˆæˆ‘çœŸç»™æ¯äº²æ‰“äº†ç”µè¯ï¼Œæ‹–å»¶å¥¹ä¸€ä¸¤åˆ†é’Ÿå‡ºé—¨ï¼Œä¹Ÿè®¸å¥¹å°±èº²è¿‡äº†è¿™åœºç¾éš¾â€¦â€¦ ä¸Šä¸–çºªæœ«æœ€åä¸€å¤©ï¼Œæˆ‘æ€»ç®—è‰¯å¿ƒå‘ç°ï¼Œåœ¨å…¬åŠ¡ç»“æŸä¹‹åï¼Œä¹°äº†ä¸€å¼ ä»åŒ—äº¬å»æ˜†æ˜çš„æœºç¥¨ï¼Œå»çœ‹çœ‹å¦ˆå¦ˆã€‚ä¹°å¥½æœºç¥¨åï¼Œæˆ‘æ²¡æœ‰ç»™å¥¹ç”µè¯ï¼Œæˆ‘çŸ¥é“ä¸€æ‰“ç”µè¯å¥¹ä¸€ä¸‹åˆéƒ½ä¼šå¿™ç¢Œï¼Œä¸ç®¡å¤šæ™šåˆ°è¾¾ï¼Œéƒ½ä¼šç»™æˆ‘åšä¸€äº›æˆ‘å°æ—¶å€™å–œæ¬¢åƒçš„ä¸œè¥¿ã€‚ç›´åˆ°é£æœºèµ·é£ï¼Œæˆ‘æ‰å‘Šè¯‰å¥¹ï¼Œè®©å¥¹ä¸è¦å‘Šè¯‰åˆ«äººï¼Œä¸è¦è½¦æ¥æ¥ï¼Œæˆ‘è‡ªå·±åå‡ºç§Ÿè½¦å›å®¶ï¼Œç›®çš„å°±æ˜¯å¥½å¥½é™ªé™ªå¥¹ã€‚å‰å‡ å¹´æˆ‘æ¯å¹´ä¹Ÿå»çœ‹çœ‹å¦ˆå¦ˆï¼Œä½†ä¸€ä¸‹é£æœºå°±ç»™åŠäº‹å¤„æ¥èµ°äº†ï¼Œè¯´è¿™ä¸ªå®¢æˆ·å¾ˆé‡è¦ï¼Œè¦æ‹œè§ä¸€ä¸‹ï¼Œé‚£ä¸ªå®¢æˆ·å¾ˆé‡è¦ï¼Œè¦é™ªä»–ä»¬åƒé¡¿é¥­ï¼Œå¿™æ¥å¿™å»ï¼Œå¿™åˆ°ä¸Šé£æœºæ—¶å›å®¶å–è¡Œæï¼Œä¸çˆ¶æ¯åŒ†åŒ†ä¸€åˆ«ã€‚å¦ˆå¦ˆç›¼æ˜Ÿæ˜Ÿã€ç›¼æœˆäº®ï¼Œç›¼ç›¼å” å” å®¶å¸¸ï¼Œä¸€æ¬¡åˆä¸€æ¬¡çš„è½ç©ºã€‚ä»–ä»¬æ€»æ˜¯è¯´ä½ å·¥ä½œé‡è¦ï¼Œå…ˆå·¥ä½œï¼Œå…ˆå·¥ä½œã€‚ ç”±äºæˆ‘3æ—¥è¦èµ¶å›åŒ—äº¬ï¼Œéšèƒ¡é”¦æ¶›å‰¯ä¸»å¸­è®¿é—®ä¼Šæœ—ï¼Œåœ¨æ˜†æ˜æˆ‘åªèƒ½å‘†ä¸€å¤©ã€‚è¿™æ¬¡åœ¨æ˜†æ˜ç»™å¦ˆå¦ˆè¯´äº†å»å¹´11æœˆä»½æˆ‘éšå´é‚¦å›½å‰¯æ€»ç†è®¿é—®éæ´²æ—¶ï¼Œå´é‚¦å›½å‰¯æ€»ç†åœ¨ç§‘å¨ç‰¹ä¸æˆ‘è°ˆäº†åŠå°æ—¶è¯çš„å†…å®¹ã€‚é¦–é•¿è¯´äº†è¿™æ¬¡æˆ‘éšè®¿æ˜¯ä»–äº²è‡ªç‚¹çš„åï¼Œç›®çš„æœ‰ä¸‰ä¸ªï¼š1ã€é¼“åŠ±å’Œè‚¯å®šåä¸ºï¼Œå¹¶è®©éšè¡Œçš„å„éƒ¨éƒ¨é•¿ä¹Ÿæ­£é¢åœ°è®¤è¯†å’Œäº†è§£åä¸ºï¼›2ã€äº†è§£ä¸€ä¸‹æˆ‘ä»¬å…¬å¸çš„è¿è¡Œä¸ç®¡ç†æœºåˆ¶ï¼Œçœ‹çœ‹å¯¹åˆ«çš„ä¼ä¸šæœ‰æ— å¸®åŠ©ï¼›3ã€çœ‹çœ‹æ”¿åºœå¯¹åä¸ºå¼€æ‹“å›½é™…å¸‚åœºæ˜¯å¦èƒ½ç»™äºˆä¸€äº›å¸®åŠ©ã€‚å¦ˆå¦ˆå¬äº†ååˆ†é«˜å…´ï¼Œè¯´â€œæ”¿åºœä¿¡ä»»å°±å¥½ï¼Œåªè¦ä¼ä¸šå¹²å¾—å¥½ï¼Œå…¶ä»–éƒ½ä¼šéšæ—¶é—´çš„è¯å®è€Œè¿‡å»çš„ã€‚â€ æœ€è¿‘è¿™ä¸¤å¹´ï¼Œç½‘ä¸Šã€åª’ä½“ä¸­å¯¹åä¸ºæœ‰ä¸€äº›å†…å®¹ï¼Œä¹Ÿæ˜¯æ¯èª‰å‚åŠï¼Œå¦ˆå¦ˆæ˜¯ç»è¿‡â€œæ–‡é©â€ç—›è‹¦ç…ç†¬è¿‡çš„ï¼Œå¯¹è£èª‰ä¸æ„Ÿå…´è¶£ï¼Œå¯¹ä¸€äº›ä¸äº†è§£æˆ‘ä»¬çœŸå®æƒ…å†µçš„æ–‡ç« å´ååˆ†å¿§å¿ƒã€‚æˆ‘è¯´äº†ï¼Œæˆ‘ä»¬ä¸æ˜¯ä¸Šå¸‚å…¬å¸ï¼Œä¸éœ€è¦å…¬ç¤ºç¤¾ä¼šï¼Œä¸»è¦æ˜¯å¯¹æ”¿åºœè´Ÿè´£ï¼Œå¯¹ä¼ä¸šçš„æœ‰æ•ˆè¿è¡Œè´Ÿè´£ã€‚æˆ‘ä»¬å»å¹´äº¤ç¨20äº¿å¤šï¼Œ2001å¹´è¦äº¤40å¤šäº¿çš„ç¨ã€‚å„çº§æ”¿åºœå¯¹æˆ‘ä»¬éƒ½ä¿¡ä»»ã€‚æˆ‘ä»¬ä¸èƒ½åœ¨åª’ä½“ä¸Šå»è¾©è®ºï¼Œè¿™æ ·ä¼šå¼•èµ·äº‰è®ºï¼Œå›½å®¶çº¸å¤ªè´µï¼Œä¸ºæˆ‘ä»¬è¿™æ ·ä¸€ä¸ªå°å…¬å¸äº‰è®ºå¤ªæµªè´¹ã€‚ä¸ºæˆ‘ä»¬è¿™æ ·ä¸€ä¸ªå°å…¬å¸ï¼Œå»å¹²æ‰°å›½å®¶çš„å®£ä¼ é‡ç‚¹ï¼Œæˆ‘ä»¬ä¹Ÿæ‰¿æ‹…ä¸äº†è¿™ä¹ˆå¤§è´£ä»»ã€‚ä»–ä»¬ä¸»è¦æ˜¯ä¸äº†è§£ï¼Œæˆ‘ä»¬ä¹Ÿæ²¡æœ‰ä»‹ç»ï¼Œäº†è§£å°±å¥½äº†ã€‚å¦ˆå¦ˆèˆ’äº†ä¸€å£æ°”ï¼Œç†è§£äº†æˆ‘çš„æ²‰é»˜ã€‚è¿™æ¬¡æˆ‘è¿˜ä¸æ¯äº²çº¦å¥½ï¼Œä»Šå¹´æ˜¥èŠ‚æˆ‘ä¸å·¥ä½œï¼Œå“ªå„¿ä¹Ÿä¸å»ï¼Œä¸å‡ ä¸ªå¼Ÿå¦¹é™ªå¥¹åˆ°æµ·å—è¿‡æ˜¥èŠ‚ï¼Œå¥½å¥½èŠä¸€èŠï¼Œç—›ç—›å¿«å¿«èŠä¸€èŠã€‚ä»¥å‰ï¼Œæˆ‘èŠ‚å‡æ—¥å¤šä¸ºå‡ºå›½ï¼Œå› ä¸­å›½è¿‡èŠ‚ï¼Œå¤–å›½è¿™æ—¶ä¸è¿‡èŠ‚ï¼Œæ­£å¥½å¤šä¸€äº›æ—¶é—´å·¥ä½œï¼Œè¿™æ¬¡æˆ‘æ˜¯å½»åº•æƒ³æ˜ç™½äº†ï¼Œè¦é™ªé™ªå¦ˆå¦ˆï¼Œæˆ‘è¿™ä¸€ç”Ÿè¿˜æ²¡æœ‰å¥½å¥½é™ªè¿‡å¥¹ã€‚æ²¡æƒ³åˆ°ç»ˆæˆæ³¡å½±ã€‚ 8å·é‚£å¤©ï¼Œåœ†æ»¡ç»“æŸå¯¹ä¼Šæœ—çš„è®¿é—®ï¼Œæˆ‘ä»¬åˆšæŠŠèƒ¡å‰¯ä¸»å¸­é€ä¸Šé£æœºï¼Œå°±æ¥åˆ°çºªå¹³çš„ç”µè¯ï¼Œè¯´æˆ‘æ¯äº²ä¸Šåˆ10æ—¶å·¦å³ï¼Œä»èœå¸‚åœºå‡ºæ¥ï¼Œæç€ä¸¤å°åŒ…èœï¼Œè¢«æ±½è½¦æ’æˆé‡ä¼¤ï¼Œå­™æ€»å·²å‰å¾€æ˜†æ˜ç»„ç»‡æŠ¢æ•‘ã€‚ç”±äºç›¸éš”åƒä¸‡é‡Œï¼Œä¼Šæœ—çš„é€šä¿¡å¤ªå·®ï¼ŒçœŸä½¿äººå¿ƒæ€¥ç«ç‡ã€‚é£æœºè¦å¤šæ¬¡ä¸­è½¬æ‰èƒ½å›æ¥ï¼Œåœ¨å·´æ—è½¬æœºè¦å‘†6.5ä¸ªå°æ—¶ï¼ŒçœŸæ˜¯å¿ƒå¦‚ç…ç†¬ï¼Œåˆé‡å·´æ—é›·é›¨ï¼Œé£æœºåˆå»¶è¯¯ä¸¤ä¸ªå°æ—¶ï¼Œåˆ°æ›¼è°·æ—¶åˆå†æ™šäº†ååˆ†é’Ÿï¼Œæ²¡æœ‰åŠæ—¶èµ¶ä¸Šå›æ˜†æ˜çš„é£æœºï¼Œç›´åˆ°æ·±å¤œæ‰èµ¶åˆ°æ˜†æ˜ã€‚ å›åˆ°æ˜†æ˜ï¼Œå°±çŸ¥é“å¦ˆå¦ˆä¸è¡Œäº†ï¼Œå¥¹çš„å¤´éƒ¨å…¨éƒ¨ç»™æ’åäº†ï¼Œå½“æ—¶çš„å¿ƒè·³ã€å‘¼å¸å…¨æ˜¯é è¯ç‰©å’Œæœºå™¨ç»´æŒï¼Œä¹‹æ‰€ä»¥åœ¨ç”µè¯ä¸Šä¸å‘Šè¯‰æˆ‘ï¼Œæ˜¯æ€•æˆ‘åœ¨æ—…é€”ä¸­å‡ºäº‹ã€‚æˆ‘çœ‹è§å¦ˆå¦ˆä¸€å£°ä¸å“åœ°å®‰è¯¦åœ°èººåœ¨ç—…åºŠä¸Šï¼Œä¸ç”¨æ“åŠ³ã€çƒ¦å¿ƒï¼Œå¥½åƒå¥¹ä¸€ç”Ÿä¹Ÿæ²¡æœ‰è¿™ä¹ˆä¼‘æ¯è¿‡ã€‚ æˆ‘çœŸåæ‚”æ²¡æœ‰åœ¨ä¼Šæœ—ç»™æ¯äº²ä¸€ä¸ªç”µè¯ã€‚7æ—¥èƒ¡å‰¯ä¸»å¸­æ¥è§æˆ‘ä»¬8ä¸ªéšè¡Œçš„ä¼ä¸šè´Ÿè´£äººï¼Œæˆ‘æ±‡æŠ¥äº†ä¸¤ã€ä¸‰åˆ†é’Ÿï¼Œè¯´åˆ°æˆ‘æ˜¯åä¸ºå…¬å¸çš„æ—¶å€™ï¼Œèƒ¡å‰¯ä¸»å¸­ä¼¸å‡º4ä¸ªæŒ‡å¤´ï¼Œè¯´å››ä¸ªå…¬å¸ä¹‹ä¸€ã€‚æˆ‘æœ¬æƒ³æŠŠè¿™ä¸ªå¥½æ¶ˆæ¯å‘Šè¯‰å¦ˆå¦ˆï¼Œè¯´ä¸­å¤®é¦–é•¿è¿˜çŸ¥é“æˆ‘ä»¬åä¸ºã€‚ä½†æˆ‘æ²¡æ‰“ï¼Œå› ä¸ºä»¥å‰ä¸ç®¡æˆ‘åœ¨å›½å†…ã€å›½å¤–ç»™æˆ‘æ¯äº²æ‰“ç”µè¯æ—¶ï¼Œå¥¹éƒ½å” å¨ï¼šâ€œä½ åˆå‡ºå·®äº†â€ï¼Œâ€œééä½ çš„èº«ä½“è¿˜ä¸å¦‚æˆ‘å¥½å‘¢â€ï¼Œâ€œééä½ çš„çš±çº¹æ¯”å¦ˆå¦ˆè¿˜å¤šå‘¢â€ï¼Œâ€œééä½ èµ°è·¯è¿˜ä¸å¦‚æˆ‘å‘¢ï¼Œä½ è¿™ä¹ˆå¹´çºªè½»è½»å°±è¿™ä¹ˆå¤šç—…â€ï¼Œâ€œééï¼Œç³–å°¿ç—…å‚åŠ å®´ä¼šå¤šäº†ï¼Œåå¾—æ›´å¿«å‘¢ï¼Œä½ çš„å¿ƒè„åˆä¸å¥½â€ã€‚æˆ‘æƒ³ä¼Šæœ—æ¡ä»¶è¿™ä¹ˆå·®ï¼Œæˆ‘ä¸€æ‰“ç”µè¯ï¼Œå¦ˆå¦ˆåˆå” å¨ï¼Œåæ­£è¿‡ä¸äº†å‡ å¤©å°±è§é¢äº†ï¼Œå°±æ²¡æœ‰æ‰“ã€‚è€Œè¿™æ˜¯æˆ‘ä¸€ç”Ÿä¸­æœ€å¤§çš„æ†¾äº‹ã€‚ç”±äºæ—¶å·®ï¼Œæˆ‘åªèƒ½åœ¨ä¸­å›½æ—¶é—´8æ—¥ä¸Šåˆä¸€æ—©æ‰“ï¼Œå‘Šè¯‰å¥¹è¿™ä¸ªå–œè®¯ï¼Œå¦‚æœæˆ‘çœŸæ‰“äº†,æ‹–å»¶å¥¹ä¸€ã€ä¸¤åˆ†é’Ÿå‡ºé—¨ï¼Œä¹Ÿè®¸å¦ˆå¦ˆå°±èº²è¿‡äº†è¿™åœºç¾éš¾ã€‚è¿™ç§æ‚”æ¨çš„å¿ƒæƒ…ï¼ŒçœŸæ˜¯éš¾ä»¥å½¢å®¹ã€‚ æˆ‘çœ‹äº†å¦ˆå¦ˆæœ€åä¸€çœ¼åï¼Œå¦ˆå¦ˆæº˜ç„¶å»ä¸–ã€‚1995å¹´æˆ‘çˆ¶äº²ä¹Ÿæ˜¯å› ä¸ºåœ¨æ˜†æ˜è¡—å¤´çš„å°æ‘Šä¸Šï¼Œä¹°äº†ä¸€ç“¶å¡‘æ–™åŒ…è£…çš„è½¯é¥®æ–™å–åï¼Œæ‹‰è‚šå­ï¼Œä¸€ç›´åˆ°å…¨èº«è¡°ç«­å»ä¸–ã€‚ çˆ¸çˆ¸ä»»æ‘©é€Šï¼Œå°½èŒå°½è´£ä¸€ç”Ÿï¼Œå……å…¶é‡å¯ä»¥è¯´æ˜¯ä¸€ä¸ªä¹¡æ‘æ•™è‚²å®¶ã€‚å¦ˆå¦ˆç¨‹è¿œæ˜­ï¼Œæ˜¯ä¸€ä¸ªé™ªä¼´çˆ¶äº²åœ¨è´«å›°å±±åŒºä¸ç©·å­©å­å®æ··äº†ä¸€ç”Ÿçš„ä¸€ä¸ªæ™®é€šå¾—ä¸èƒ½å†æ™®é€šçš„å›­ä¸ã€‚ çˆ¸çˆ¸æ˜¯ç©¿ç€åœŸæ”¹å·¥ä½œé˜Ÿçš„æ£‰è¡£ï¼Œéšè§£æ”¾å†›å‰¿åŒªéƒ¨é˜Ÿä¸€åŒè¿›å…¥è´µå·å°‘æ•°æ°‘æ—å±±åŒºå»ç­¹å»ºä¸€æ‰€æ°‘æ—ä¸­å­¦ã€‚ä¸€å¤´æ‰è¿›å»å°±æ˜¯å‡ åå¹´ï¼Œä»–åŸ¹å…»çš„å­¦ç”Ÿä¸å°‘æˆä¸ºå…šå’Œå›½å®¶çš„é«˜çº§å¹²éƒ¨ï¼Œæœ‰äº›è¿˜æ˜¯ä¸­å¤®é™¢æ ¡çš„æ ¡çº§é¢†å¯¼ï¼Œè€Œçˆ¶äº²è¿˜æ˜¯é‚£ä¹ˆä½å‘è¨€å¾®ã€‚ çˆ·çˆ·æ˜¯æµ™æ±Ÿæµ¦æ±Ÿå¿çš„ä¸€ä¸ªåšç«è…¿çš„å¤§å¸ˆå‚…ï¼Œçˆ¸çˆ¸çš„å…„å¼Ÿå§Šå¦¹éƒ½æ²¡æœ‰è¯»è¿‡ä¹¦ã€‚ç”±äºçˆ·çˆ·çš„è‰¯å¿ƒå‘ç°ï¼Œä¹Ÿç”±äºçˆ¸çˆ¸çš„æ‰§ç€è¦æ±‚ï¼Œçˆ¸çˆ¸æ‰è¯»äº†ä¹¦ã€‚çˆ¸çˆ¸åœ¨åŒ—äº¬ä¸Šå¤§å­¦æœŸé—´ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªçƒ­è¡€é’å¹´ï¼Œå‚åŠ å­¦ç”Ÿè¿åŠ¨ï¼Œè¿›è¡ŒæŠ—æ—¥æ¼”è®²ï¼Œåå¯¹ä¾µåçš„ç”°ä¸­å¥ç« ï¼Œè¿˜å‚åŠ è¿‡å…±é’å›¢ã€‚ç”±äºçˆ·çˆ·ã€å¥¶å¥¶ç›¸ç»§ç—…é€ï¼Œçˆ¸çˆ¸å·®ä¸€å¹´æ²¡æœ‰è¯»å®Œå¤§å­¦ï¼Œè¾å­¦å›å®¶ã€‚æ—¶æ—¥ï¼Œæ­£å€¼å›½å…±åˆä½œå¼€å§‹ï¼Œå…¨å›½æ€èµ·æŠ—æ—¥é«˜æ½®ï¼Œçˆ¶äº²åœ¨åŒä¹¡ä¼šçš„ä»‹ç»ä¸‹ï¼Œåˆ°å¹¿å·ä¸€ä¸ªåŒä¹¡å½“å‚é•¿çš„å›½æ°‘å…šå†›å·¥å‚åšä¼šè®¡å‘˜ã€‚ç”±äºæˆ˜äº‰çš„é€¼è¿‘ï¼Œå·¥å‚åˆè¿åˆ°å¹¿è¥¿èæ°´ï¼Œååˆè¿åˆ°è´µå·æ¡æ¢“ã€‚åœ¨å¹¿è¥¿èæ°´æœŸé—´ï¼Œçˆ¸çˆ¸ä¸å‡ ä¸ªæœ‹å‹åœ¨ä¸šä½™æ—¶é—´ï¼Œå¼€äº†ä¸€ä¸ªç”Ÿæ´»ä¹¦åº—ï¼Œå–é©å‘½ä¹¦ç±ï¼Œåˆç»„ç»‡ä¸€ä¸ªâ€œä¸ƒÂ·ä¸ƒâ€è¯»ä¹¦ä¼šï¼Œåæ¥è¿™ä¸ªè¯»ä¹¦ä¼šä¸­æœ‰å‡ åäººèµ°ä¸Šäº†é©å‘½å‰çº¿ï¼Œæœ‰ç›¸å½“å¤šçš„äººè§£æ”¾åæˆä¸ºå…šå’Œå›½å®¶çš„é«˜çº§å¹²éƒ¨ã€‚ç²‰ç¢â€œå››äººå¸®â€åï¼Œèæ°´é‡å†™å…šå²æ—¶ï¼Œè¿˜æŠŠçˆ¸çˆ¸é‚€è¯·è¿‡å»ã€‚ çˆ¸çˆ¸è¿™æ®µå†å²ï¼Œæ˜¯æ–‡é©ä¸­å—ç£¨éš¾æœ€å¤§çš„ä¸€ä»¶äº‹æƒ…ã€‚èº«åœ¨å›½æ°‘å…šçš„å…µå·¥å‚ï¼Œè€Œåˆç§¯æå®£ä¼ æŠ—æ—¥ï¼ŒåŒæ„å…±äº§å…šçš„è§‚ç‚¹ï¼Œè€Œåˆæ²¡æœ‰ä¸å…±äº§å…šåœ°ä¸‹ç»„ç»‡è”ç³»ã€‚ä½ ä¸ºä»€ä¹ˆï¼Ÿè¿™å°±æˆäº†ä¸€éƒ¨åˆ†äººçš„ç–‘ç‚¹ã€‚åœ¨æ–‡é©æ—¶æœŸï¼Œå¦‚ä½•è§£é‡Šå¾—æ¸…æ¥šã€‚ä»–ä»¬æ€»æƒ³æŒ–å‡ºä¸€æ¡éšè—å¾—å¾ˆæ·±çš„å¤§é±¼ï¼Œçˆ¸çˆ¸å—å°½äº†ç™¾èˆ¬çš„æŠ˜ç£¨ã€‚ å¦ˆå¦ˆå…¶å®åªæœ‰é«˜ä¸­æ–‡åŒ–ç¨‹åº¦ï¼Œå¥¹è¦é™ªä¼´çˆ¶äº²ï¼Œå¿å—å„ç§å±ˆè¾±ï¼Œæˆä¸ºçˆ¶äº²çš„æŒ¡é£å¢™,åˆè¦ç…§é¡¾æˆ‘ä»¬å…„å¦¹ä¸ƒäººï¼Œæ”¾ä¸‹ç²‰ç¬”å°±è¦å’Œç…¤çƒä¸ºä¼ï¼Œä¹°èœã€åšé¥­ã€æ´—è¡£â€¦â€¦åˆè¦è‡ªä¿®æ–‡åŒ–ï¼Œå®Œæˆè‡ªå·±çš„æ•™å­¦ä»»åŠ¡ï¼Œå¥¹æœ€åè¢«è¯„ä¸ºä¸­å­¦çš„é«˜çº§æ•™å¸ˆã€‚å¥¹çš„å­¦ç”Ÿä¸­ï¼Œä¸å°‘æ˜¯çœã€åœ°çº§å¹²éƒ¨åŠä¼˜ç§€çš„æŠ€æœ¯ä¸“å®¶ï¼Œä»–ä»¬éƒ½å¯¹æ¯äº²çš„æ•™å­¦è´£ä»»å¿ƒå°è±¡æ·±åˆ»ã€‚å¦ˆå¦ˆè¿™ä¹ˆä½çš„æ–‡åŒ–æ°´å¹³ï¼Œè‡ªå­¦æˆæ‰ï¼Œå„ç§è‰°è¾›ï¼Œåªæœ‰å¥¹è‡ªå·±çŸ¥é“ã€‚ çˆ¶æ¯è™½ç„¶è¾ƒæ—©å‚åŠ é©å‘½ï¼Œä½†ä»–ä»¬çš„éæ— äº§é˜¶çº§è¡€ç»Ÿï¼Œè¦èå…¥æ— äº§é˜¶çº§çš„é©å‘½é˜Ÿä¼ï¼Œå–å¾—ä¿¡ä»»ï¼Œå¹¶ä¸æ˜¯ä¸€ä»¶å®¹æ˜“çš„äº‹æƒ…ã€‚ä»–ä»¬ä¸å¯èƒ½åƒæ™®é€šå†œæ°‘ã€å·¥äººé‚£æ ·æ”¿æ²»çº¯æ´ã€‚ä»–ä»¬æ˜¯ç”Ÿæ´»åœ¨ä¸€ä¸ªå¤æ‚çš„ç¤¾ä¼šä¸­ï¼Œè¿™ä¸ªç¤¾ä¼šåˆæ˜¯å¤šå…ƒåŒ–ç»„æˆçš„ï¼Œä¸å¯èƒ½åªæœ‰ä¸€ç§çº¯æ´çš„ç‰©è´¨ã€‚å†æ¬¡æ”¿æ²»è¿åŠ¨ä¸­ï¼Œä»–ä»¬éƒ½å‘å…šäº¤å¿ƒï¼Œä»–ä»¬æ€æƒ³æ”¹é€ çš„å›°éš¾ç¨‹åº¦è¦æ¯”åˆ«äººå¤§å¾—å¤šï¼Œæ‰€å—çš„å†…å¿ƒç…ç†¬ä¹Ÿéä»–äººæ‰€èƒ½ç†è§£ã€‚ä»–ä»¬æŠŠä¸€ç”Ÿä»»ä½•ä¸€ä¸ªç»†èŠ‚éƒ½å†™å¾—æå…¶è¯¦å°½ï¼Œå¸Œæœ›ç»„ç»‡å®¡æŸ¥ã€‚ä»–ä»¬å»ä¸–åï¼Œæˆ‘è¯·åŒå­¦å»å¸®åŠ©å¤å°çˆ¶æ¯çš„æ¡£æ¡ˆï¼ŒåŒå­¦ä»¬çœ‹äº†çˆ¶æ¯å‘å…šäº¤å¿ƒçš„ææ–™ï¼Œéƒ½è¢«ä»–ä»¬çš„çœŸæƒ…æ„ŸåŠ¨å¾—æ³ªæµæ»¡é¢ã€‚ç»ˆå…¶ä¸€ç”Ÿï¼Œä»–ä»¬éƒ½æ˜¯è¿½éšé©å‘½çš„ï¼Œä¸ä¸€å®šç®—å¾—ä¸Šä¸­åšåˆ†å­ï¼Œä½†æ— æ„§äºå…šå’Œäººæ°‘ã€‚çˆ¶äº²ç»ˆåœ¨1958å¹´å›½å®¶å¸æ”¶ä¸€æ‰¹é«˜çº§çŸ¥è¯†åˆ†å­å…¥å…šæ—¶ï¼Œå…¥äº†å…šã€‚å½“æ—¶å‘å…šäº¤å¿ƒï¼Œä¸åƒä»Šå¤©è¿™æ ·ä¿¡æ¯å‘è¾¾ï¼Œé‚£æ—¶ï¼Œåå¯¹ä¸ªåˆ«å…šå‘˜ï¼Œæœ‰å¯èƒ½è¢«è¯´æˆåå…šã€‚æˆ‘ä»¬äº²çœ¼çœ‹åˆ°çˆ¶æ¯çš„è°¨å°æ…å¾®ã€å¿˜æˆ‘åœ°æ‹¼å…¶å…¨åŠ›å·¥ä½œï¼Œæ— æš‡é¡¾åŠæˆ‘ä»¬ï¼Œå°±å¦‚æˆ‘æ‹¼æ­»å·¥ä½œï¼Œæ— æš‡å­æ•¬ä»–ä»¬ä¸€æ ·ã€‚ä»–ä»¬å¯¹å…šå’Œå›½å®¶ã€å¯¹äº‹ä¸šçš„å¿ è¯šï¼Œå·²ç»å†å²å¯é‰´ã€‚æˆ‘ä»Šå¤©è¦å¿æ‚”çš„ï¼Œæ˜¯æˆ‘æ²¡æœ‰æŠ½æ—¶é—´é™ªé™ªä»–ä»¬ï¼Œé€é€ä»–ä»¬ã€‚ å›æƒ³èµ·æ¥ï¼Œé©å‘½çš„ä¸­åšåˆ†å­åœ¨ä¸€ä¸ªç¤¾ä¼šä¸­æ˜¯å°‘çš„ï¼Œä»–ä»¬èƒ½ä»¥é©å‘½çš„åä¹‰ï¼Œæ— ç§æ— ç•åœ°å·¥ä½œï¼Œä»–ä»¬æ˜¯å›½å®¶ä¸ç¤¾ä¼šçš„æ ‹æ¢ã€‚ä¸ºäº†é€‰æ‹”è¿™äº›äººï¼Œå¤šå¢åŠ ä¸€äº›å®¡æŸ¥æˆæœ¬æ˜¯å€¼å¾—çš„ã€‚è€Œåƒçˆ¶æ¯è¿™æ ·è¿½éšé©å‘½ï¼Œæˆ–æ‹¥æŠ¤é©å‘½ï¼Œæˆ–ä¸åå¯¹é©å‘½çš„äººæ˜¯å¤šçš„ï¼Œä»–ä»¬æ¯”ä¸é©å‘½å¥½ï¼Œç¤¾ä¼šåº”è®¤åŒä»–ä»¬ï¼Œç»™ä»¥æœºä¼šã€‚ä¸å¿…è¦æ±‚ä»–ä»¬é‚£ä¹ˆçº¯æ´ï¼ŒèŠ±ä¸Šè¿™ä¹ˆå¤šç²¾åŠ›å»å®¡æŸ¥ä»–ä»¬ï¼Œé«˜æ ‡å‡†è¦æ±‚ä»–ä»¬ï¼Œä»–ä»¬è¾¾ä¸åˆ°ä¹Ÿç—›è‹¦,è€Œæ˜¯è¦ç²¾ç¥æ–‡æ˜ä¸ç‰©è´¨æ–‡æ˜ä¸€åŒæ¥æ”¯æ’‘ï¼Œä»¥ç‰©è´¨æ–‡æ˜æ¥å·©å›ºç²¾ç¥æ–‡æ˜ï¼Œä»¥ä¸€ç§æœºåˆ¶æ¥ä¿ƒä½¿ä»–ä»¬ä¸»è§‚ä¸Šä¸ºæé«˜ç”Ÿå­˜è´¨é‡ï¼Œå®¢è§‚ä¸Šæ˜¯ä¿ƒè¿›é©å‘½ï¼Œå……åˆ†å‘æŒ¥ä»–ä»¬è´¡çŒ®çš„ç§¯ææ€§ã€‚æˆ‘ä¸»æŒåä¸ºå·¥ä½œåï¼Œæˆ‘ä»¬å¯¹å¾…å‘˜å·¥ï¼ŒåŒ…æ‹¬è¾èŒçš„å‘˜å·¥éƒ½æ˜¯å®½æ¾çš„ï¼Œæˆ‘ä»¬åªé€‰æ‹”æœ‰æ•¬ä¸šç²¾ç¥ã€çŒ®èº«ç²¾ç¥ã€æœ‰è´£ä»»å¿ƒã€ä½¿å‘½æ„Ÿçš„å‘˜å·¥è¿›å…¥å¹²éƒ¨é˜Ÿä¼ï¼Œåªå¯¹é«˜çº§å¹²éƒ¨ä¸¥æ ¼è¦æ±‚ã€‚è¿™ä¹Ÿæ˜¯äº²å†äº²è§äº†çˆ¶æ¯çš„æ€æƒ³æ”¹é€ çš„è¿‡ç¨‹ï¼Œè€Œå½¢æˆäº†æˆ‘å®½å®¹çš„å“æ ¼ã€‚ æˆ‘ä¸çˆ¶æ¯ç›¸å¤„çš„é’å°‘å¹´æ—¶ä»£ï¼Œå°è±¡æœ€æ·±çš„å°±æ˜¯æ¸¡è¿‡ä¸‰å¹´è‡ªç„¶ç¾å®³çš„å›°éš¾æ—¶æœŸã€‚ä»Šå¤©æƒ³æ¥è¿˜å†å†åœ¨ç›®ã€‚ æˆ‘ä»¬å…„å¦¹ä¸ƒä¸ªï¼ŒåŠ ä¸Šçˆ¶æ¯å…±ä¹äººã€‚å…¨é çˆ¶æ¯å¾®è–„çš„å·¥èµ„æ¥ç”Ÿæ´»ï¼Œæ¯«æ— å…¶ä»–æ¥æºã€‚æœ¬æ¥ç”Ÿæ´»å°±ååˆ†å›°éš¾ï¼Œå„¿å¥³ä¸€å¤©å¤©åœ¨é•¿å¤§ï¼Œè¡£æœä¸€å¤©å¤©åœ¨å˜çŸ­ï¼Œè€Œä¸”éƒ½è¦è¯»ä¹¦ï¼Œå¼€æ”¯å¾ˆå¤§ï¼Œæ¯ä¸ªå­¦æœŸæ¯äººäº¤2-3å…ƒçš„å­¦è´¹ï¼Œåˆ°äº¤è´¹æ—¶ï¼Œå¦ˆå¦ˆæ¯æ¬¡éƒ½å‘æ„ã€‚ä¸å‹‰å¼ºå¯ä»¥ç”¨å·¥èµ„æ¥è§£å†³åŸºæœ¬ç”Ÿæ´»çš„å®¶åº­ç›¸æ¯”ï¼Œæˆ‘å®¶çš„å›°éš¾å°±æ›´å¤§ã€‚æˆ‘ç»å¸¸çœ‹åˆ°å¦ˆå¦ˆæœˆåº•å°±åˆ°å¤„å‘äººå€Ÿ3-5å…ƒé’±åº¦é¥¥è’ï¼Œè€Œä¸”å¸¸å¸¸èµ°äº†å‡ å®¶éƒ½æœªå¿…å€Ÿåˆ°ã€‚ç›´åˆ°é«˜ä¸­æ¯•ä¸šæˆ‘æ²¡æœ‰ç©¿è¿‡è¡¬è¡£ã€‚æœ‰åŒå­¦çœ‹åˆ°å¾ˆçƒ­çš„å¤©ï¼Œæˆ‘ç©¿ç€åšåšçš„å¤–è¡£ï¼Œè¯´è®©æˆ‘å‘å¦ˆå¦ˆè¦ä¸€ä»¶è¡¬è¡£ï¼Œæˆ‘ä¸æ•¢ï¼Œå› ä¸ºæˆ‘çŸ¥é“åšä¸åˆ°ã€‚æˆ‘ä¸Šå¤§å­¦æ—¶å¦ˆå¦ˆä¸€æ¬¡é€æˆ‘ä¸¤ä»¶è¡¬è¡£ï¼Œæˆ‘çœŸæƒ³å“­ï¼Œå› ä¸ºï¼Œæˆ‘æœ‰äº†ï¼Œå¼Ÿå¦¹ä»¬å°±ä¼šæ›´éš¾äº†ã€‚æˆ‘å®¶å½“æ—¶æ˜¯2-3äººåˆç”¨ä¸€æ¡è¢«ç›–ï¼Œè€Œä¸”ç ´æ—§çš„è¢«å•ä¸‹é¢é“ºçš„æ˜¯ç¨»è‰ã€‚â€œæ–‡é©â€é€ åæ´¾æŠ„å®¶æ—¶ï¼Œä»¥ä¸ºä¸€ä¸ªé«˜çº§çŸ¥è¯†åˆ†å­ã€ä¸“ç§‘å­¦æ ¡çš„æ ¡é•¿å®¶ï¼Œä¸çŸ¥æœ‰å¤šå¯Œï¼Œç»“æœéƒ½æƒŠä½äº†ã€‚ä¸Šå¤§å­¦æˆ‘è¦æ‹¿èµ°ä¸€æ¡è¢«å­ï¼Œå°±æ›´å›°éš¾äº†ï¼Œå› ä¸ºé‚£æ—¶è¿˜å®è¡Œå¸ƒç¥¨ã€æ£‰èŠ±ç¥¨ç®¡åˆ¶ï¼Œæœ€å°‘çš„ä¸€å¹´ï¼Œæ¯äººåªå‘0.5ç±³å¸ƒç¥¨ã€‚æ²¡æœ‰è¢«å•ï¼Œå¦ˆå¦ˆæ¡äº†æ¯•ä¸šå­¦ç”Ÿä¸¢å¼ƒçš„å‡ åºŠç ´è¢«å•ç¼ç¼è¡¥è¡¥ï¼Œæ´—å¹²å‡€ï¼Œè¿™æ¡è¢«å•å°±åœ¨é‡åº†é™ªæˆ‘æ¸¡è¿‡äº†äº”å¹´çš„å¤§å­¦ç”Ÿæ´»ã€‚ çˆ¶æ¯çš„ä¸è‡ªç§ï¼Œé‚£æ—¶çš„å¤„å¢ƒå¯ä»¥æ˜é‰´ã€‚æˆ‘é‚£æ—¶14-15å²ï¼Œæ˜¯è€å¤§ï¼Œå…¶ä»–ä¸€ä¸ªæ¯”ä¸€ä¸ªå°ï¼Œè€Œä¸”ä¸æ‡‚äº‹ã€‚ä»–ä»¬å®Œå…¨å¯ä»¥å·å·åœ°å¤šåƒä¸€å£ç²®é£Ÿï¼Œå¯ä»–ä»¬è°ä¹Ÿæ²¡æœ‰è¿™ä¹ˆåšã€‚çˆ¸çˆ¸æœ‰æ—¶è¿˜æœ‰æœºä¼šå‚åŠ ä¼šè®®ï¼Œé€‚å½“æ”¹å–„ä¸€ä¸‹ç”Ÿæ´»ã€‚è€Œå¦ˆå¦ˆé‚£ä¹ˆå‘å¾®ï¼Œä¸ä»…è¦åŒåˆ«çš„äººä¸€æ ·å·¥ä½œï¼Œè€Œä¸”è¿˜è¦è´Ÿæ‹…ä¸ƒä¸ªå­©å­çš„åŸ¹å…»ã€ç”Ÿæ´»ã€‚ç…®é¥­ã€æ´—è¡£ã€ä¿®ç…¤ç¶â€¦â€¦ä»€ä¹ˆéƒ½å¹²ï¼Œæ¶ˆè€—è¿™ä¹ˆå¤§ï¼Œè‡ªå·±å´ä»ä¸å¤šåƒä¸€å£ã€‚æˆ‘ä»¬å®¶å½“æ—¶æ˜¯æ¯é¤å®è¡Œä¸¥æ ¼åˆ†é¥­åˆ¶ï¼Œæ§åˆ¶æ‰€æœ‰äººæ¬²æœ›çš„é…ç»™åˆ¶ï¼Œä¿è¯äººäººéƒ½èƒ½æ´»ä¸‹æ¥ã€‚ä¸æ˜¯è¿™æ ·ï¼Œæ€»ä¼šæœ‰ä¸€ä¸ªã€ä¸¤ä¸ªå¼Ÿå¦¹æ´»ä¸åˆ°ä»Šå¤©ã€‚æˆ‘çœŸæ­£èƒ½ç†è§£æ´»ä¸‹å»è¿™å¥è¯çš„å«ä¹‰ã€‚ æˆ‘é«˜ä¸‰å¿«é«˜è€ƒæ—¶ï¼Œæœ‰æ—¶åœ¨å®¶å¤ä¹ åŠŸè¯¾ï¼Œå®åœ¨é¥¿å¾—å—ä¸äº†äº†ï¼Œç”¨ç±³ç³ å’Œèœåˆä¸€ä¸‹ï¼Œçƒ™ç€åƒï¼Œè¢«çˆ¸çˆ¸ç¢°ä¸Šå‡ æ¬¡ï¼Œä»–å¿ƒç–¼äº†ã€‚å…¶å®é‚£æ—¶æˆ‘å®¶ç©·å¾—è¿ä¸€ä¸ªå¯ä¸Šé”çš„æŸœå­éƒ½æ²¡æœ‰ï¼Œç²®é£Ÿæ˜¯ç”¨ç“¦ç¼¸è£…ç€ï¼Œæˆ‘ä¹Ÿä¸æ•¢å»éšä¾¿æŠ“ä¸€æŠŠï¼Œå¦åˆ™ä¹Ÿæœ‰ä¸€ã€ä¸¤ä¸ªå¼Ÿå¦¹æ´»ä¸åˆ°ä»Šå¤©ã€‚ï¼ˆæˆ‘çš„ä¸è‡ªç§ä¹Ÿæ˜¯ä»çˆ¶æ¯èº«ä¸Šå­¦åˆ°çš„ï¼Œåä¸ºä»Šå¤©è¿™ä¹ˆæˆåŠŸï¼Œä¸æˆ‘ä¸è‡ªç§æœ‰ä¸€ç‚¹å…³ç³»ã€‚ï¼‰åä¸‰ä¸ªæœˆï¼Œå¦ˆå¦ˆç»å¸¸æ—©ä¸Šå¡ç»™æˆ‘ä¸€ä¸ªå°å°çš„ç‰ç±³é¥¼ï¼Œè¦æˆ‘å®‰å¿ƒå¤ä¹ åŠŸè¯¾ï¼Œæˆ‘èƒ½è€ƒä¸Šå¤§å­¦ï¼Œå°ç‰ç±³é¥¼åŠŸåŠ³å·¨å¤§ã€‚å¦‚æœä¸æ˜¯è¿™æ ·ï¼Œä¹Ÿè®¸æˆ‘ä¹Ÿè¿›ä¸äº†åä¸ºè¿™æ ·çš„å…¬å¸ï¼Œç¤¾ä¼šä¸Šå¤šäº†ä¸€åå…»çŒªèƒ½æ‰‹ï¼Œæˆ–è¡—è¾¹å¤šäº†ä¸€åèƒ½å·¥å·§åŒ è€Œå·²ã€‚è¿™ä¸ªå°å°çš„ç‰ç±³é¥¼ï¼Œæ˜¯ä»çˆ¶æ¯ä¸å¼Ÿå¦¹çš„å£ä¸­æŠ å‡ºæ¥çš„ï¼Œæˆ‘æ— ä»¥æŠ¥ç­”ä»–ä»¬ã€‚ 1997å¹´æˆ‘å›½çš„é«˜ç­‰æ•™è‚²åˆ¶åº¦æ”¹é©ï¼Œå¼€å§‹å‘å­¦ç”Ÿæ”¶è´¹ï¼Œè€Œé…å¥—çš„åŠ©å­¦è´·æ¬¾åˆæ²¡è·Ÿä¸Šï¼Œåä¸ºé›†å›¢å‘æ•™è‚²éƒ¨æçŒ®äº†2500ä¸‡å…ƒå¯’é—¨å­¦å­åŸºé‡‘ã€‚ çˆ¶äº²ä¸€ç”Ÿè°¨å°æ…å¾®ï¼Œè‡ªçŸ¥åœ°ä½ä¸é«˜ï¼Œä»ä¸ä¹±å‘è¨€è€ŒåŸ‹å¤´åœ¨å­¦é—®ä¸­ï¼Œå¯åœ¨â€œæ–‡é©â€æ¨ªæ‰«ä¸€åˆ‡ç‰›é¬¼è›‡ç¥çš„è¿åŠ¨ä¸­ï¼Œä»–è¿˜æ˜¯è¢«æªå‡ºæ¥ï¼ŒååŠ¨å­¦æœ¯æƒå¨ã€èµ°èµ„æ´¾ã€å†å²æœ‰é—®é¢˜çš„äººâ€¦â€¦ä¸‡åŠ«éš¾é€ƒã€‚ä»–æœ€æ—©è¢«å…³è¿›ç‰›æ£šã€‚ 1967å¹´é‡åº†æ­¦æ–—æ¿€çƒˆæ—¶ï¼Œæˆ‘æ‰’ç«è½¦å›å®¶ã€‚å› ä¸ºæ²¡æœ‰ç¥¨ï¼Œè¿˜åœ¨ç«è½¦ä¸ŠæŒ¨è¿‡ä¸Šæµ·é€ åé˜Ÿçš„æ‰“ï¼Œæˆ‘è¯´æˆ‘è¡¥ç¥¨ä¹Ÿä¸è¡Œï¼Œç¡¬æŠŠæˆ‘æ¨ä¸‹ç«è½¦ã€‚ä¹ŸæŒ¨è¿‡è½¦ç«™äººå‘˜çš„æ‰“ï¼Œå›å®¶è¿˜ä¸æ•¢ç›´æ¥åœ¨çˆ¶æ¯å·¥ä½œçš„åŸå¸‚ä¸‹è½¦ï¼Œè€Œåœ¨å‰ä¸€ç«™é’å¤ªå¡ä¸‹è½¦ï¼Œæ­¥è¡Œåå‡ é‡Œå›å»ã€‚åŠå¤œå›åˆ°å®¶ï¼Œçˆ¶æ¯è§æˆ‘å›æ¥äº†ï¼Œæ¥ä¸åŠå¿ƒç–¼ï¼Œè®©æˆ‘æ˜æ—©ä¸€æ—©å°±èµ°ï¼Œæ€•äººçŸ¥é“ï¼Œå—ç‰µè¿ï¼Œå½±å“æˆ‘çš„å‰é€”ã€‚çˆ¸çˆ¸è„±ä¸‹ä»–çš„ä¸€åŒæ—§çš®é‹ç»™æˆ‘ï¼Œç¬¬äºŒå¤©ä¸€æ—©æˆ‘å°±èµ°äº†ï¼Œä¸´èµ°ï¼Œçˆ¶äº²è¯´äº†å‡ å¥è¯ï¼šâ€œè®°ä½çŸ¥è¯†å°±æ˜¯åŠ›é‡ï¼Œåˆ«äººä¸å­¦ï¼Œä½ è¦å­¦ï¼Œä¸è¦éšå¤§æµã€‚â€â€œä»¥åæœ‰èƒ½åŠ›è¦å¸®åŠ©å¼Ÿå¦¹ã€‚â€èƒŒè´Ÿç€è¿™ç§é‡æ‰˜ï¼Œæˆ‘åœ¨é‡åº†æªæ—å¼¹é›¨çš„ç¯å¢ƒä¸‹ï¼Œå°†æ¨Šæ˜ å·çš„é«˜ç­‰æ•°å­¦ä¹ é¢˜é›†ä»å¤´åˆ°å°¾åšäº†ä¸¤éï¼Œå­¦ä¹ äº†è®¸å¤šé€»è¾‘ã€å“²å­¦ã€‚è¿˜è‡ªå­¦äº†ä¸‰é—¨å¤–è¯­ï¼Œå½“æ—¶å·²åˆ°å¯ä»¥é˜…è¯»å¤§å­¦è¯¾æœ¬çš„ç¨‹åº¦ï¼Œç»ˆå› æˆ‘ä¸æ˜¯è¯­è¨€å¤©æ‰ï¼ŒåŠ ä¹‹åœ¨å†›é˜ŸæœåŠ¡æ—¶ç”¨ä¸ä¸Šï¼Œ20å¤šå¹´è’åºŸï¼Œå®Œå…¨å¿˜å…‰äº†ã€‚æˆ‘å½“å¹´ç©¿èµ°çˆ¸çˆ¸çš„çš®é‹ï¼Œæ²¡å¿µåŠçˆ¸çˆ¸é‚£æ—¶æ˜¯åšè‹¦å·¥çš„ï¼Œæ³¥é‡Œæ°´é‡Œï¼Œå†°å†·æ½®æ¹¿ï¼Œä»–æ›´éœ€è¦é‹å­ã€‚ç°åœ¨å›å¿†èµ·æ¥ï¼Œæ„Ÿè§‰è‡ªå·±å¤ªè‡ªç§äº†ã€‚ â€œæ–‡é©â€ä¸­ï¼Œæˆ‘å®¶çš„ç»æµçŠ¶å†µï¼Œé™·å…¥äº†æ¯”è‡ªç„¶ç¾å®³æ—¶æœŸè¿˜å›°éš¾çš„å¢ƒåœ°ã€‚ä¸­å¤®æ–‡é©ä¸ºäº†ä»ç»æµä¸Šæ‰“å®èµ°èµ„æ´¾ï¼Œä¸‹æ–‡æ§åˆ¶ä»–ä»¬çš„äººå‡æ ‡å‡†ç”Ÿæ´»è´¹ä¸å¾—é«˜äº15å…ƒã€‚è€Œä¸”å„çº§é€ åæ´¾å±‚å±‚åŠ ç ï¼ŒçœŸæ­£åˆ°æ‰‹çš„å¹³å‡10å…ƒå·¦å³ã€‚æˆ‘æœ‰åŒå­¦åœ¨è¡—é“åŠäº‹å¤„å·¥ä½œï¼Œä»‹ç»å¼Ÿå¦¹ä»¬åˆ°æ²³é‡ŒæŒ–ç ‚å­ï¼Œä¿®é“è·¯æŠ¬åœŸæ–¹â€¦â€¦ï¼Œå¼Ÿå¦¹ä»¬åœ¨æˆ‘ç»“å©šæ—¶ï¼Œå¤§å®¶é›†åœ¨ä¸€èµ·ï¼Œé€äº†æˆ‘100å…ƒã€‚è¿™éƒ½æ˜¯ä»–ä»¬åœ¨å†°å†·çš„æ²³æ°´ä¸­ç­›ç ‚ï¼Œä¿®é“è·¯æ—¶å†’ç€åœ¨åœŸæ–¹å¡Œæ–¹ä¸­è¢«æ©åŸ‹çš„å±é™©â€¦â€¦æŒ£æ¥çš„ã€‚é‚£æ—¶çš„ç”Ÿæ´»è‰°è‹¦è¿˜èƒ½å¿å—ï¼Œå¿ƒç—›æ¯”èº«ç—›è¦ä¸¥é‡å¾—å¤šï¼Œç”±äºçˆ¶äº²å—å®¡æŸ¥çš„èƒŒæ™¯å½±å“ï¼Œå¼Ÿå¦¹ä»¬ä¸€æ¬¡åˆä¸€æ¬¡çš„å…¥å­¦å½•å–è¢«å¦å®šï¼Œé‚£ä¸ªå¹´ä»£å¯¹ä»–ä»¬çš„æŸå¤±å°±æ˜¯æ²¡æœ‰æœºä¼šæ¥å—é«˜ç­‰æ•™è‚²ã€‚é™¤äº†æˆ‘å¤§å­¦è¯»äº†ä¸‰å¹´å°±å¼€å§‹æ–‡åŒ–å¤§é©å‘½å¤–ï¼Œå…¶ä»–å¼Ÿå¦¹æœ‰äº›é«˜ä¸­ã€åˆä¸­ã€é«˜å°ã€åˆå°éƒ½æ²¡è¯»å®Œï¼Œä»–ä»¬åæ¥é€‚åº”äººç”Ÿçš„æŠ€èƒ½ï¼Œéƒ½æ˜¯è‡ªå­¦æ¥çš„ã€‚ä»ç°åœ¨çš„å›é¡¾æ¥çœ‹ï¼Œç‰©è´¨çš„è‰°è‹¦ç”Ÿæ´»ä»¥åŠå¿ƒçµçš„ç£¨éš¾æ˜¯æˆ‘ä»¬åæ¥äººç”Ÿçš„ä¸€ç§æˆç†Ÿçš„å®è´µè´¢å¯Œã€‚ â€œæ–‡é©â€å¯¹å›½å®¶æ˜¯ä¸€åœºç¾éš¾ï¼Œä½†å¯¹æˆ‘ä»¬æ˜¯ä¸€æ¬¡äººç”Ÿçš„æ´—ç¤¼ï¼Œä½¿æˆ‘æ”¿æ²»ä¸Šæˆç†Ÿèµ·æ¥ï¼Œä¸å†æ˜¯å•çº¯çš„ä¸€ä¸ªä¹¦å‘†å­ã€‚æˆ‘è™½ç„¶ä¹Ÿå‚åŠ äº†è½°è½°çƒˆçƒˆçš„çº¢å«å…µè¿åŠ¨ï¼Œä½†æˆ‘å§‹ç»ˆä¸æ˜¯çº¢å«å…µï¼Œè¿™ä¹Ÿæ˜¯ä¸€ä¸ªå¥‡è§‚ã€‚å› ä¸ºçˆ¶äº²å—å®¡çš„å½±å“ï¼Œå“ªä¸€æ´¾ä¹Ÿä¸æ‰¹å‡†æˆ‘å‚åŠ çº¢å«å…µã€‚åæ¥æˆ‘å…¥ä¼åï¼Œä¹Ÿæ˜¯å› ä¸ºçˆ¶äº²é—®é¢˜ï¼Œä¸€ç›´æ²¡æœ‰é€šè¿‡å…¥å…šç”³è¯·ï¼Œç›´åˆ°ç²‰ç¢â€œå››äººå¸®â€ä»¥åã€‚ 1976å¹´10æœˆï¼Œä¸­å¤®ä¸€ä¸¾ç²‰ç¢äº†â€œå››äººå¸®â€ï¼Œä½¿æˆ‘ä»¬å¾—åˆ°äº†ç¿»èº«è§£æ”¾ã€‚æˆ‘ä¸€ä¸‹å­æˆäº†å¥–åŠ±â€œæš´å‘æˆ·â€ã€‚â€œæ–‡é©â€ä¸­ï¼Œæ— è®ºæˆ‘å¦‚ä½•åŠªåŠ›ï¼Œä¸€åˆ‡ç«‹åŠŸã€å—å¥–çš„æœºä¼šå‡ä¸æˆ‘æ— ç¼˜ã€‚åœ¨æˆ‘é¢†å¯¼çš„é›†ä½“ä¸­ï¼Œæˆ˜å£«ä»¬ç«‹ä¸‰ç­‰åŠŸã€äºŒç­‰åŠŸã€é›†ä½“äºŒç­‰åŠŸï¼Œå‡ ä¹æ¯å¹´éƒ½å¤§æ‰¹æ¶Œå‡ºï¼Œè€Œå”¯æˆ‘è¿™ä¸ªé¢†å¯¼è€…ï¼Œä»æœªå—è¿‡å˜‰å¥–ã€‚æˆ‘å·²ä¹ æƒ¯äº†æˆ‘ä¸åº”å¾—å¥–çš„å¹³é™ç”Ÿæ´»ï¼Œè¿™ä¹Ÿæ˜¯æˆ‘ä»Šå¤©ä¸äº‰è£èª‰çš„å¿ƒç†ç´ è´¨åŸ¹å…»ã€‚ç²‰ç¢â€œå››äººå¸®â€ä»¥åï¼Œç”Ÿæ´»ç¿»äº†ä¸ªä¸ªå„¿ï¼Œå› ä¸ºæˆ‘ä¸¤æ¬¡å¡«è¡¥è¿‡å›½å®¶ç©ºç™½ï¼Œåˆæœ‰æŠ€æœ¯å‘æ˜åˆ›é€ ï¼Œåˆä¹é‚£æ—¶çš„æ—¶ä»£éœ€è¦ï¼Œçªç„¶ä¸€ä¸‹å­â€œæ ‡å…µã€åŠŸè‡£â€¦â€¦â€éƒ¨é˜Ÿä¸åœ°æ–¹çš„å¥–åŠ±æ’å±±å€’æµ·å¼åœ°å‹è¿‡æ¥ã€‚æˆ‘è¿™äººä¹Ÿçƒ­ä¸èµ·æ¥ï¼Œè®¸å¤šå¥–å“éƒ½æ˜¯åˆ«äººå»ä»£é¢†å›æ¥çš„ï¼Œæˆ‘åˆåˆ†ç»™äº†å¤§å®¶ã€‚ 1978å¹´3æœˆæˆ‘å‡ºå¸­äº†å…¨å›½ç§‘å­¦å¤§ä¼šï¼Œ6000äººçš„ä»£è¡¨ä¸­ï¼Œä»…æœ‰150å¤šäººåœ¨35å²ä»¥ä¸‹ï¼Œæˆ‘33 å²ã€‚æˆ‘ä¹Ÿæ˜¯å†›é˜Ÿä»£è¡¨ä¸­å°‘æœ‰çš„éå…šäººå£«ã€‚åœ¨å…µç§å…šå§”çš„ç›´æ¥å…³æ€€ä¸‹ï¼Œéƒ¨é˜Ÿæœªç­‰æˆ‘çˆ¶äº²å¹³åï¼Œå°±ç›´æ¥å»ä¸ºæŸ¥æ¸…æˆ‘çˆ¶äº²çš„å†å²è¿›è¡Œå¤–è°ƒï¼Œå¦å®šäº†ä¸€äº›ä¸å®ä¹‹è¯ï¼Œå¹¶æŠŠä»–ä»¬çš„è°ƒæŸ¥ç»“è®ºï¼Œå¯„ç»™æˆ‘çˆ¶äº²æ‰€åœ¨çš„åœ°æ–¹ç»„ç»‡ã€‚æˆ‘ç»ˆäºå…¥äº†å…šã€‚åæ¥åˆå‡ºå¸­äº†å…šçš„ç¬¬åäºŒæ¬¡å…¨å›½ä»£è¡¨å¤§ä¼šã€‚çˆ¶äº²æŠŠæˆ‘ä¸å…šä¸­å¤®é¢†å¯¼åˆå½±çš„ç…§ç‰‡ï¼Œåšäº†ä¸€ä¸ªå¤§å¤§çš„é•œæ¡†ï¼ŒæŒ‚åœ¨å¢™ä¸Šï¼Œå…¨å®¶éƒ½å¼•ä»¥è‡ªè±ªã€‚ æˆ‘çˆ¶äº²ä¹Ÿåœ¨ç²‰ç¢â€œå››äººå¸®â€åä¸ä¹…å¹³åã€‚ç”±äºé‚£æ—¶ç™¾åºŸå¾…å…´ï¼Œå…šç»„ç»‡éœ€è¦å°½å¿«æ¢å¤ä¸€äº›é‡ç‚¹ä¸­å­¦ï¼Œæé«˜é«˜è€ƒçš„å‡å­¦ç‡ï¼Œè®©ä»–å»åšæ ¡é•¿ã€‚â€œæ–‡é©â€å‰ä»–æ˜¯ä¸€ä¸ªä¸“ç§‘å­¦æ ¡çš„æ ¡é•¿ã€‚ä»–ä¸è®¡è¾ƒå‡é™ï¼Œä¸è®¡è¾ƒå¾—å¤±ï¼Œåªè®¤ä¸ºæœ‰äº†ä¸€ç§å·¥ä½œæœºä¼šï¼Œå…¨èº«å¿ƒåœ°æŠ•è¿›å»äº†ï¼Œå¾ˆå¿«å°±æŠŠæ•™å­¦è´¨é‡æŠ“èµ·æ¥äº†ï¼Œå‡å­¦ç‡è¾¾åˆ°äº†90%å¤šï¼Œæˆä¸ºè¿œè¿‘é—»åçš„å­¦æ ¡ã€‚ä»–ç›´åˆ°1984å¹´75å²æ‰é€€ä¼‘ã€‚ä»–è¯´ï¼Œä»–æ€»ç®—èµ¶ä¸Šäº†ä¸€ä¸ªå°¾å·´ï¼Œå¹²äº†ä¸€ç‚¹äº‹ã€‚ä»–å¸Œæœ›æˆ‘ä»¬çæƒœæ—¶å…‰ï¼Œå¥½å¥½å¹²ã€‚è‡³æ­¤ï¼Œæˆ‘ä»¬å°±å„å¿™å„çš„ï¼Œäº’ç›¸å…³å¿ƒä¸äº†äº†ã€‚æˆ‘ä¸ºè€ä¸€è¾ˆçš„æ”¿æ²»å“è¡Œè‡ªè±ªï¼Œä»–ä»¬ä»ç‰›æ£šä¸­æ”¾å‡ºæ¥ï¼Œä¸€æ¢å¤ç»„ç»‡ç”Ÿæ´»ï¼Œéƒ½æ‹¼å‘½åœ°å·¥ä½œã€‚ä»–ä»¬ä¸ä»¥ç‰©å–œï¼Œä¸ä»¥å·±æ‚²ï¼Œä¸è®¡è£è¾±ï¼Œçˆ±å›½çˆ±å…šï¼Œå¿ äºäº‹ä¸šçš„ç²¾ç¥å€¼å¾—æˆ‘ä»¬è¿™ä¸€ä»£äººã€ä¸‹ä¸€ä»£äººã€ä¸‹ä¸‹ä¸€ä»£äººå­¦ä¹ ã€‚ç”Ÿæ´»ä¸­ä¸å¯èƒ½æ²¡æœ‰æŒ«æŠ˜ï¼Œä½†ä¸€ä¸ªäººä¸ºäººæ°‘å¥‹æ–—çš„æ„å¿—ä¸èƒ½åŠ¨æ‘‡ã€‚ æˆ‘æœ‰å¹¸åœ¨ç½—ç‘å¿åŒå¿—é€ä¸–å‰ä¸‰ä¸ªæœˆï¼Œæœ‰æœºä¼šè†å¬äº†ä»–ä¸ºå…¨å›½ç§‘å­¦å¤§ä¼šå†›é˜Ÿä»£è¡¨çš„è®²è¯ï¼Œè¯´æœªæ¥åå‡ å¹´æ˜¯ä¸€ä¸ªéš¾å¾—çš„å’Œå¹³æ—¶æœŸï¼Œæˆ‘ä»¬è¦æŠ“ç´§å…¨åŠ›æŠ•å…¥ç»æµå»ºè®¾ã€‚æˆ‘é‚£æ—¶å¹´è½»ï¼Œç¼ºå°‘æ”¿æ²»å¤´è„‘ï¼Œå¹¶ä¸æ˜ç™½å…¶å«æ„ã€‚è¿‡äº†ä¸¤ã€ä¸‰å¹´å¤§è£å†›ï¼Œæˆ‘ä»¬æ•´ä¸ªå…µç§å…¨éƒ¨è¢«è£æ‰ï¼Œæˆ‘æ‰ç†è§£äº†ä»€ä¹ˆå«é¢„è§æ€§çš„é¢†å¯¼ã€‚ è½¬å…¥åœ°æ–¹åï¼Œä¸é€‚åº”å•†å“ç»æµï¼Œä¹Ÿæ— é©¾é©­å®ƒçš„èƒ½åŠ›ï¼Œä¸€å¼€å§‹æˆ‘åœ¨ä¸€ä¸ªç”µå­å…¬å¸å½“ç»ç†ä¹Ÿæ ½è¿‡è·Ÿæ–—ï¼Œè¢«äººéª—è¿‡ã€‚åæ¥ä¹Ÿæ˜¯æ— å¤„å¯ä»¥å°±ä¸šï¼Œæ‰è¢«è¿«åˆ›å»ºåä¸ºçš„ã€‚åä¸ºçš„å‰å‡ å¹´æ˜¯åœ¨ååˆ†è‰°éš¾å›°è‹¦çš„æ¡ä»¶ä¸‹èµ·æ­¥çš„ã€‚è¿™æ—¶çˆ¶æ¯ã€ä¾„å­ä¸æˆ‘ä½åœ¨ä¸€é—´åå‡ å¹³æ–¹ç±³çš„å°æˆ¿é‡Œï¼Œåœ¨é˜³å°ä¸Šåšé¥­ã€‚ä»–ä»¬å¤„å¤„ä¸ºæˆ‘æ‹…å¿ƒï¼Œç”Ÿæ´»ä¹Ÿååˆ†èŠ‚çœã€‚æ”’ä¸€äº›é’±è¯´æ˜¯ä¸ºäº†å°†æ¥æ•‘æˆ‘ã€‚ï¼ˆå¬å¦¹å¦¹è¯´ï¼Œæ¯äº²å»ä¸–å‰ä¸¤ä¸ªæœˆï¼Œè¿˜ä¸å¦¹å¦¹è¯´ï¼Œå¥¹å­˜æœ‰å‡ ä¸‡å…ƒï¼Œä»¥åç•™ç€æ•‘å“¥å“¥ï¼Œä»–æ€»ä¸ä¼šæ°¸è¿œéƒ½å¥½ã€‚æ¯äº²åœ¨è¢«è½¦æ’æ—¶ï¼Œå¥¹èº«ä¸Šåªè£…äº†å‡ åå…ƒé’±ï¼Œåˆæœªå¸¦ä»»ä½•è¯ä»¶ï¼Œæ˜¯ä½œä¸ºæ— åæ°è¢«110æŠ¢æ•‘çš„ã€‚ä¸­åˆåƒé¥­æ—¶ï¼Œå¦¹å¦¹ã€å¦¹å¤«æ‰å‘ç°å¥¹æœªå›æ¥ï¼Œå››å¤„å¯»æ‰¾ï¼Œæ‰çŸ¥é“é‡è½¦ç¥¸ã€‚å¯æ€œå¤©ä¸‹çˆ¶æ¯å¿ƒï¼Œä¸€ä¸ªæ¯äº²çš„å¿ƒæœ‰å¤šçº¯ã€‚ï¼‰å½“æ—¶åœ¨å¹¿ä¸œå–é±¼è™¾ï¼Œä¸€æ­»å°±ååˆ†ä¾¿å®œï¼Œçˆ¶æ¯ä»–ä»¬ä¸“é—¨ä¹°æ­»é±¼ã€æ­»è™¾åƒï¼Œè¯´è¿™æ¯”å†…åœ°è¿˜æ–°é²œå‘¢ï¼æ™šä¸Šå‡ºå»ä¹°èœä¸è¥¿ç“œï¼Œå› ä¸ºå–ä¸æ‰çš„èœï¼Œä¾¿å®œä¸€äº›ã€‚æˆ‘ä¹Ÿæ— æš‡é¡¾åŠä»–ä»¬çš„ç”Ÿæ´»ï¼Œä»¥è‡´æ¯äº²ç³–å°¿ç—…ä¸¥é‡æˆ‘è¿˜ä¸çŸ¥é“ï¼Œæ˜¯é‚»å±…å‘Šè¯‰æˆ‘çš„ã€‚åä¸ºæœ‰äº†è§„æ¨¡å‘å±•åï¼Œç®¡ç†è½¬æ¢çš„å‹åŠ›ååˆ†å·¨å¤§ï¼Œæˆ‘ä¸ä»…ç…§é¡¾ä¸äº†çˆ¶æ¯ï¼Œè€Œä¸”è¿è‡ªå·±ä¹Ÿç…§é¡¾ä¸äº†ï¼Œæˆ‘çš„èº«ä½“ä¹Ÿæ˜¯é‚£ä¸€æ®µæ—¶é—´ç´¯å®çš„ã€‚æˆ‘çˆ¶æ¯è¿™æ—¶æ‰è½¬å»æ˜†æ˜æˆ‘å¦¹å¦¹å¤„å®šå±…ã€‚æˆ‘ä¹Ÿå› æ­¤ç†è§£äº†è¦å¥‹æ–—å°±ä¼šæœ‰ç‰ºç‰²ï¼Œåä¸ºçš„æˆåŠŸï¼Œä½¿æˆ‘å¤±å»äº†å­æ•¬çˆ¶æ¯çš„æœºä¼šä¸è´£ä»»ï¼Œä¹Ÿæ¶ˆèš€äº†è‡ªå·±çš„å¥åº·ã€‚ å›é¡¾æˆ‘è‡ªå·±å·²èµ°è¿‡çš„å†å²ï¼Œæ‰ªå¿ƒè‡ªé—®ï¼Œæˆ‘ä¸€ç”Ÿæ— æ„§äºç¥–å›½ã€æ— æ„§äºäººæ°‘ï¼Œæ— æ„§äºäº‹ä¸šä¸å‘˜å·¥ï¼Œæ— æ„§äºæœ‹å‹ï¼Œå”¯ä¸€æœ‰æ„§çš„æ˜¯å¯¹ä¸èµ·çˆ¶æ¯ï¼Œæ²¡æ¡ä»¶æ—¶æ²¡æœ‰ç…§é¡¾ä»–ä»¬ï¼Œæœ‰æ¡ä»¶æ—¶ä¹Ÿæ²¡æœ‰ç…§é¡¾ä»–ä»¬ã€‚ çˆ¸çˆ¸å¦ˆå¦ˆï¼Œåƒå£°ä¸‡å£°å‘¼å”¤æ‚¨ä»¬ï¼Œåƒå£°ä¸‡å£°å”¤ä¸å›ã€‚ é€è€…å·²ç»é€å»ï¼Œæ´»ç€çš„è¿˜è¦å‰è¡Œã€‚ æ­¤ç¯‡æ–‡ç« æ˜¯ä»»æ­£éå…ˆç”Ÿæ€€å¿µçˆ¶æ¯çš„çœŸæƒ…æµéœ²ã€‚åæ˜ äº†ä¸€ä¸ªæ™®é€šé’å¹´ï¼Œåœ¨å›½å†…å¤§ç¯å¢ƒã€å¤§å˜é©ä¸‹çš„è¿›å–ä¹‹è·¯ã€‚æ²¡æœ‰ä¼¤ç—•ç´¯ç´¯ï¼Œä½•æ¥çš®ç³™è‚‰åšï¼Œè‡ªå¤è‹±é›„å¤šç£¨éš¾ï¼ ","link":"https://Mungeryang.github.io/post/ren-zheng-fei-wen-ji-one/"},{"title":" C/C++  FOR EVERYONE  ","content":" åŠ å·å¤§å­¦åœ£å…‹é²å…¹åˆ†æ ¡;æ¨æ¡‚æ·¼&copy; å¿ƒæ°´æ€»ç»“&trade; ä½ æ¥çš„å¤ªæ™šäº†ï¼Œä½†æˆ‘è½¬å¿µä¸€æƒ³ï¼Œä½ æ¥çš„åˆå¤ªåŠæ—¶äº†ã€‚â€”â€”â€”è‘£å®‡è¾‰ è¿ç®—ç¬¦ä¼˜å…ˆçº§ ä¼˜å…ˆçº§ è¿ç®—ç¬¦ åç§°æˆ–å«ä¹‰ ä½¿ç”¨å½¢å¼ ç»“åˆæ–¹å‘ è¯´æ˜ 1 [ ] æ•°ç»„ä¸‹æ ‡ æ•°ç»„å[å¸¸é‡è¡¨è¾¾å¼] å·¦åˆ°å³ â€“ () åœ†æ‹¬å· (è¡¨è¾¾å¼ï¼‰/å‡½æ•°å(å½¢å‚è¡¨) â€“ . æˆå‘˜é€‰æ‹©ï¼ˆå¯¹è±¡ï¼‰ å¯¹è±¡.æˆå‘˜å â€“ -&gt; æˆå‘˜é€‰æ‹©ï¼ˆæŒ‡é’ˆï¼‰ å¯¹è±¡æŒ‡é’ˆ-&gt;æˆå‘˜å â€“ 2 - è´Ÿå·è¿ç®—ç¬¦ -è¡¨è¾¾å¼ å³åˆ°å·¦ å•ç›®è¿ç®—ç¬¦ ~ æŒ‰ä½å–åè¿ç®—ç¬¦ ~è¡¨è¾¾å¼ ++ è‡ªå¢è¿ç®—ç¬¦ ++å˜é‡å/å˜é‡å++ â€“ è‡ªå‡è¿ç®—ç¬¦ â€“å˜é‡å/å˜é‡åâ€“ ***** å–å€¼è¿ç®—ç¬¦ *æŒ‡é’ˆå˜é‡ &amp; å–åœ°å€è¿ç®—ç¬¦ &amp;å˜é‡å ! é€»è¾‘éè¿ç®—ç¬¦ !è¡¨è¾¾å¼ (ç±»å‹) å¼ºåˆ¶ç±»å‹è½¬æ¢ (æ•°æ®ç±»å‹)è¡¨è¾¾å¼ â€“ sizeof é•¿åº¦è¿ç®—ç¬¦ sizeof(è¡¨è¾¾å¼) â€“ 3 / é™¤ è¡¨è¾¾å¼/è¡¨è¾¾å¼ å·¦åˆ°å³ åŒç›®è¿ç®—ç¬¦ ***** ä¹˜ è¡¨è¾¾å¼*è¡¨è¾¾å¼ % ä½™æ•°ï¼ˆå–æ¨¡ï¼‰ æ•´å‹è¡¨è¾¾å¼%æ•´å‹è¡¨è¾¾å¼ 4 + åŠ  è¡¨è¾¾å¼+è¡¨è¾¾å¼ å·¦åˆ°å³ åŒç›®è¿ç®—ç¬¦ - å‡ è¡¨è¾¾å¼-è¡¨è¾¾å¼ 5 &lt;&lt; å·¦ç§» å˜é‡&lt;&lt;è¡¨è¾¾å¼ å·¦åˆ°å³ åŒç›®è¿ç®—ç¬¦ &gt;&gt; å³ç§» å˜é‡&gt;&gt;è¡¨è¾¾å¼ 6 &gt; å¤§äº è¡¨è¾¾å¼&gt;è¡¨è¾¾å¼ å·¦åˆ°å³ åŒç›®è¿ç®—ç¬¦ &gt;= å¤§äºç­‰äº è¡¨è¾¾å¼&gt;=è¡¨è¾¾å¼ &lt; å°äº è¡¨è¾¾å¼&lt;è¡¨è¾¾å¼ &lt;= å°äºç­‰äº è¡¨è¾¾å¼&lt;=è¡¨è¾¾å¼ 7 == ç­‰äº è¡¨è¾¾å¼==è¡¨è¾¾å¼ å·¦åˆ°å³ åŒç›®è¿ç®—ç¬¦ ï¼= ä¸ç­‰äº è¡¨è¾¾å¼!= è¡¨è¾¾å¼ 8 &amp; æŒ‰ä½ä¸ è¡¨è¾¾å¼&amp;è¡¨è¾¾å¼ å·¦åˆ°å³ åŒç›®è¿ç®—ç¬¦ 9 ^ æŒ‰ä½å¼‚æˆ– è¡¨è¾¾å¼^è¡¨è¾¾å¼ å·¦åˆ°å³ åŒç›®è¿ç®—ç¬¦ 10 | æŒ‰ä½æˆ– è¡¨è¾¾å¼|è¡¨è¾¾å¼ å·¦åˆ°å³ åŒç›®è¿ç®—ç¬¦ 11 &amp;&amp; é€»è¾‘ä¸ è¡¨è¾¾å¼&amp;&amp;è¡¨è¾¾å¼ å·¦åˆ°å³ åŒç›®è¿ç®—ç¬¦ 12 || é€»è¾‘æˆ– è¡¨è¾¾å¼||è¡¨è¾¾å¼ å·¦åˆ°å³ åŒç›®è¿ç®—ç¬¦ 13 ? : æ¡ä»¶è¿ç®—ç¬¦ è¡¨è¾¾å¼1?è¡¨è¾¾å¼2: è¡¨è¾¾å¼3 å³åˆ°å·¦ ä¸‰ç›®è¿ç®—ç¬¦ 14 = èµ‹å€¼è¿ç®—ç¬¦ å˜é‡=è¡¨è¾¾å¼ å³åˆ°å·¦ â€“ /= é™¤åèµ‹å€¼ å˜é‡/=è¡¨è¾¾å¼ â€“ *= ä¹˜åèµ‹å€¼ å˜é‡*=è¡¨è¾¾å¼ â€“ %= å–æ¨¡åèµ‹å€¼ å˜é‡%=è¡¨è¾¾å¼ â€“ += åŠ åèµ‹å€¼ å˜é‡+=è¡¨è¾¾å¼ â€“ -= å‡åèµ‹å€¼ å˜é‡-=è¡¨è¾¾å¼ â€“ &lt;&lt;= å·¦ç§»åèµ‹å€¼ å˜é‡&lt;&lt;=è¡¨è¾¾å¼ â€“ &gt;&gt;= å³ç§»åèµ‹å€¼ å˜é‡&gt;&gt;=è¡¨è¾¾å¼ â€“ &amp;= æŒ‰ä½ä¸åèµ‹å€¼ å˜é‡&amp;=è¡¨è¾¾å¼ â€“ ^= æŒ‰ä½å¼‚æˆ–åèµ‹å€¼ å˜é‡^=è¡¨è¾¾å¼ â€“ |= æŒ‰ä½æˆ–åèµ‹å€¼ å˜é‡|=è¡¨è¾¾å¼ â€“ 15 ï¼Œ é€—å·è¿ç®—ç¬¦ è¡¨è¾¾å¼,è¡¨è¾¾å¼,â€¦ å·¦åˆ°å³ â€“ æ‰€ä»¥åœ¨å®šä¹‰å¹¶ä½¿ç”¨ç»“æ„ä½“æŒ‡é’ˆçš„æ—¶å€™ï¼Œä¸åƒè°ƒç”¨æ™®é€šçš„ç»“æ„ä½“é‚£æ ·struct.attribute,è€Œæ˜¯struct-&gt;attributeï¼›å°±æ˜¯å› ä¸ºè¿ç®—ç¬¦çš„ä¼˜å…ˆçº§ä¸åŒã€‚ Different from stdio.h and standard.io Standard I/O. The pre-process command brings in both printf and now scanf. Scanf is a basic routine for doing input. By default, most cases we will come from our keyboard. PI.C In our case, standard input is defaulted to the computer keyboard. Here we see another directive. It's called a defined directive. The define directive does an interesting thing. In our case, standard input is defaulted to the computer keyboard. Here we see another directive. It's called a defined directive. The define directive does an interesting thing.we want this to be documentation.we introduce a program, which is main. We begin with what's called the open brace for a compound statement. The first statement is a declaration statement. #include&lt;stdio.h&gt; //defineåé¢ä¸åŠ åˆ†å· #define PI 3.1415926 int main(void){ double area = 0.0,radius = 0.0; printf(&quot;please input the radiuse:\\n&quot;); scanf(&quot;%lf&quot;, &amp;radius); area = PI * radius * radius; printf(&quot;area = %f&quot;,area); return 0; } Introduction Output is a very important component of programming. stdio.h we see stdio.h, and the .h is an extension that intent that means a header file, and that means that in this file which will be included automatically with our program. So it's called pre-processor because it happens before the C code is compiled. So extra code gets added, and that code is the code that we're going to need for doing printf. Without it the printf would be undeclared. Code process int is a keyword meaning that the program returns an integer Void is a keyword that would if it's used as a data type means it's an undefined data type, or in this case it means that the argument list is empty. scanf if you don't fully understand it, the scanf, which gets us input.In this case, we want to look for the address of that variable, and addresses location in memory. Then here we do the computation. scanf() is found in &lt;stdio.h&gt;;The &amp; sign means â€œstore at the location of variable&quot;. So it's very important, in your expressions, to know what domain you're in. By domain, I mean things like integer and double, because that's going to tell you what the arithmetic is being done in, and that arithmetic can affect the meaning of an operator, like divide. Divide can be an integer divide, if everything is integer, or it can be a floating point divided, if one of the arguments is floating point. åœ¨å­¦ä¹ Cè¯­è¨€æ—¶ï¼Œå¸¸å¸¸ä¼šå‘ç°æœ‰çš„scanf()é‡Œéœ€è¦&amp;ï¼Œè€Œæœ‰çš„ä¸éœ€è¦ã€‚ å½“scanfå‡½æ•°åé¢æ¥æ”¶çš„æ˜¯ä¸€ä¸ªåœ°å€çš„æ—¶å€™ï¼Œæ­¤æ—¶ä¸éœ€è¦åŠ â€œ&amp;â€-&gt;ä¾‹å¦‚ä¼ å…¥æ•°ç»„ å½“sacnfå‡½æ•°åé¢æ¥æ”¶çš„ä¸æ˜¯ä¸€ä¸ªåœ°å€ã€è€Œæ˜¯å®é™…å˜é‡çš„æ—¶å€™ï¼Œæ­¤æ—¶éœ€è¦åŠ â€œ&amp;â€-&gt;ä¾‹å¦‚ä¼ å…¥å•ä¸€å˜é‡ printfè¾“å‡ºæ ¼å¼æ§åˆ¶ï¼šprintf(â€œ%([flags ] [width ] [.prec ] [hIL ])typeâ€,var); å¯¹äºæ ¼å¼å­—ç¬¦ä¸²ï¼šä»¥ %å·å¼€å¤´ï¼Œç”¨äºå®šä¹‰æ¯ä¸ªæ•°æ®çš„è¾“å‡ºæ ¼å¼ï¼š d ä»¥åè¿›åˆ¶å½¢å¼è¾“å‡º å¸¦ ç¬¦å·æ•´æ•°ï¼ˆæ­£æ•°ä¸è¾“å‡ºç¬¦å·ï¼‰ ld è¾“å‡ºé•¿æ•´å‹æ•° o ä»¥å…«è¿›åˆ¶å½¢å¼è¾“å‡º æ—  ç¬¦å·æ•´æ•°ï¼ˆä¸è¾“å‡ºå‰ç¼€0ï¼‰ x,X ä»¥åå…­è¿›åˆ¶å½¢å¼è¾“å‡º æ—  ç¬¦å·æ•´æ•°ï¼ˆä¸è¾“å‡ºå‰ç¼€0xï¼‰ u ä»¥åè¿›åˆ¶å½¢å¼è¾“å‡º æ—  ç¬¦å·æ•´æ•° f ä»¥å°æ•°å½¢å¼è¾“å‡ºå•ã€åŒç²¾åº¦å®æ•° lf æŒ‰long doubleç±»å‹è¾“å‡º e,E ä»¥æŒ‡æ•°å½¢å¼è¾“å‡ºå•ã€åŒç²¾åº¦å®æ•° g,G æŒ‰æ•°æ®ç²¾åº¦ä»¥%fæˆ–%eä¸­è¾ƒçŸ­çš„è¾“å‡ºå®½åº¦è¾“å‡ºå•ã€åŒç²¾åº¦å®æ•° c è¾“å‡ºå•ä¸ªå­—ç¬¦ s è¾“å‡ºå­—ç¬¦ä¸² % [å¯¹é½æ–¹å¼] [è¾“å‡ºæœ€å°å®½åº¦] æ•´æ•°ç±»å‹ã€‚å¯¹é½æ–¹å¼ç”¨é»˜è®¤ä¸ºå³å¯¹é½ï¼Œè‹¥ä¸º&quot;-&quot;è´Ÿå·ï¼Œåˆ™ä¸ºå·¦å¯¹é½ï¼›è¾“å‡ºæœ€å°å®½åº¦nï¼Œè‹¥å®é™…ä½æ•°å°äºnï¼Œåˆ™è¡¥ä»¥ç©ºæ ¼æˆ–0ã€‚ % [è¾“å‡ºæœ€å°å®½åº¦] [ . ç²¾åº¦] å®æ•°ç±»å‹ æœ€å°å®½åº¦nï¼ŒåŒ…æ‹¬æ•´æ•°ï¼Œå°æ•°ç‚¹åŠå°æ•°éƒ¨åˆ†çš„æ€»ä½æ•°ï¼Œé»˜è®¤å³å¯¹é½ï¼Œå‰åŠ è´Ÿå·ä¸ºå·¦å¯¹é½ï¼›ç²¾åº¦mï¼Œè‹¥å®é™…ä½æ•°å¤§äºmï¼Œåˆ™å››èˆäº”å…¥æˆªå»è¶…è¿‡éƒ¨åˆ†ï¼Œä¸€èˆ¬å®æ•°é»˜è®¤è¾“å‡º6ä½ã€‚ ç‰ˆæƒå£°æ˜ï¼šæœ¬æ–‡ä¸ºCSDNåšä¸»ã€Œäº²äº²Friendsã€çš„åŸåˆ›æ–‡ç« ï¼Œéµå¾ªCC 4.0 BY-SAç‰ˆæƒåè®®ï¼Œè½¬è½½è¯·é™„ä¸ŠåŸæ–‡å‡ºå¤„é“¾æ¥åŠæœ¬å£°æ˜ã€‚ åŸæ–‡é“¾æ¥ï¼šhttps://blog.csdn.net/u014261408/article/details/90139849 ç‰ˆæƒå£°æ˜ï¼šæœ¬æ–‡ä¸ºCSDNåšä¸»ã€Œäº²äº²Friendsã€çš„åŸåˆ›æ–‡ç« ï¼Œéµå¾ªCC 4.0 BY-SAç‰ˆæƒåè®®ï¼Œè½¬è½½è¯·é™„ä¸ŠåŸæ–‡å‡ºå¤„é“¾æ¥åŠæœ¬å£°æ˜ã€‚ Lexical Elements and Data Types Character sets and tokens A token can be an identifier main is a legal identifier A token can be punctuation such as ; A token can be an operator such as + or / Comments It's important for documentation and readability. In order to be able to maintain or modify the program and understand its use, we want the program to be literate. So we could let say, add some more comments if we want, let me add some other comments here. keywords The table below lists all keywords reserved by the C language. When the current programming language is C or C++, these keywords cannot be abbreviated, used as variable names, or used as any other type of identifiers. auto else long switch break enum register typedef case extern return union char float short unsigned const for signed void continue goto sizeof volatile default if static while do int struct _Packed double keywords identifiers 23 my_dna is not an identifier because the first character of that sequence is a digit, so that's not allowed. So digit is not allowed anywhere but in the first character. Underscores and alphabet are allowed anywhere including the first characters. when you want something that's for counting, you can use i, j, and k. Also you frequently can use n as another underscored integer, those would all be good choices. expression -&gt;è‡ªå¢è‡ªå‡çš„è¿ç®—é€»è¾‘ a = 5 b = 7 ++a + b++ = 13 short, long, and unsigned. Short it means use less data. Long means you use more, a bigger range. So short can mean a smaller range typically, you're using fewer bytes. If it was 2.0 divided by 3 or 2.0 divided by 3.0 or 2 divided by 3.0 where one of the arguments or both the arguments are double then indeed it would be in the floating point type. You would have a type of floater doubles and your result would be 0.666. So this mistake gets made often when you are thinking you want to do something like average over some integer data and you forget that dividing can be either an integer operation or a floating point operation, you can get a mistake. List of Escape Sequences in C Escape Sequence Meaning \\a Alarm or Beep \\b Backspace \\f Form Feed \\n New Line \\r Carriage Return \\t Tab (Horizontal) \\v Vertical Tab \\ Backslash ' Single Quote &quot; Double Quote ? Question Mark \\nnn octal number \\xhh hexadecimal number \\0 Null int types On your typical modern machine, an int is stored in 32-bits. That's 32 zeros and ones and to see even worthwhile especially if you're going to go into computer science to learn how to work in binary. Now, when you're working with an end stored in 32-bits. Then what you can represent is limited and it's limited to plus or minus two billion, and I've written it out here explicitly. You can go positively up to 2,147, 436, 647 and your smallest number, your largest negative number, another way to put it is a 2,147,483,648. It's not symmetric because of the fancy way people represent integers on the machine. It's called a two's complement representation. Typically, the first bit is in fact the bit that affects how you interpret the sign. Short it means use less data. Long means you use more, a bigger range. So short can mean a smaller range typically, you're using fewer bytes. You'll see in a second when I write an example that from my machine short is two bytes, ordinary, int is four bytes as we've already said, and then long will be eight bytes. We can also use u or U and l or L to specify the type of an integer constant as an unsigned long int. 89ul - is of type unsigned long int. Unsigned Integers (often called &quot;uints&quot;) are just like integers (whole numbers) but have the property that they don't have a + or - sign associated with them. Thus they are always non-negative (zero or positive). We use uint's when we know the value we are counting will always be non-negative. For example, if we are counting the number of players in a game, we could use a uint because there will always be 0 or more players. The format specifiers are used in C for input and output purposes. Using this concept the compiler can understand that what type of data is in a variable during taking input using the scanf() function and printing using printf() function. Here is a list of format specifiers. Format Specifier Type %c Character %d Signed integer %e or %E Scientific notation of floats %f Float values %g or %G Similar as %e or %E %hi Signed integer (short) %hu Unsigned Integer (short) %i Unsigned integer %l or %ld or %li Long %lf Double %Lf Long double %lu Unsigned int or unsigned long %lli or %lld Long long %llu Unsigned long long %o Octal representation %p Pointer %s String %u Unsigned int %x or %X Hexadecimal representation %n Prints nothing %% Prints % character Flow of control and simple functions The conditional statement if and if-else åœ¨å¤„ç†0/1é€»è¾‘è¿ç®—æ—¶ï¼Œifä¸whileè¯­å¥çš„ç®€å†™ç­‰ä»·è¡¨è¾¾ï¼š if(a)ä¸if(a!=0)ç­‰ä»·ï¼›while(a)è¡¨ç¤ºå½“a!=0æ—¶æ‰§è¡Œå¾ªç¯ï¼Œå…¶ç­‰ä»·äºwhile(a!=0) if(!a)ä¸if(a==0)ç­‰ä»·ï¼›while(!a)è¡¨ç¤ºå½“a=0æ—¶æ‰§è¡Œå¾ªç¯ï¼Œå…¶ç­‰ä»·äºwhile(a==0) when the first argument evaluates false, we needn't evaluate the second argument. So we avoid evaluating the second argument. That's called short circuit evaluation. true table: T F T T F F F F You should get out of it how to use an if-else. By the way, a simpler kind of statement is just an if, and the if-statement, you have if expression and then you execute the statement if it's true. So if you have an expression that evaluates to zero, then you omit the statement. Indeed you could have turned that if-else into two if-statements, but that would be not as elegant and also somewhat inefficient because you would be evaluating the relation speed less than 65 twice. The iterative statement while What we do is recheck first to see if the expression is zero. If the expression is zero, the statement is not done. It's omitted and we just skip to whatever is next. We can think of that as false. Though really in C false is zero and true is non-zero. However, if the expression is non-zero, then we execute the statement that's sitting under the while. Then, we repeat. We go back and ask is the expression is zero we continue. That just keeps going until we see the expression is zero. å‡½æ•°åŸå‹ï¼šint getchar(void); è¿”å›ç±»å‹ä¸ºint,å‚æ•°ä¸ºvoid å¤´æ–‡ä»¶ï¼š#include&lt;stdio.h&gt; è¿”å›å€¼ï¼šgetcharè¿”å›çš„æ˜¯å­—ç¬¦çš„ASCIIç å€¼ï¼ˆæ•´æ•°ï¼‰ã€‚getcharåœ¨è¯»å–ç»“æŸæˆ–è€…å¤±è´¥çš„æ—¶å€™ï¼Œä¼šè¿”å›EOFã€‚(EOFæ„æ€æ˜¯end of file,æœ¬è´¨ä¸Šæ˜¯-1ï¼‰ è¯»å–æ–¹å¼ï¼šåªèƒ½è¾“å…¥å­—ç¬¦å‹,è¾“å…¥æ—¶é‡åˆ°å›è½¦é”®æ‰ä»ç¼“å†²åŒºä¾æ¬¡æå–å­—ç¬¦ã€‚ ç»“æŸè¾“å…¥çš„æ–¹å¼ï¼šä»¥Enterç»“æŸè¾“å…¥ï¼ˆç©ºæ ¼ä¸ç»“æŸï¼‰ï¼Œæ¥å—ç©ºæ ¼ç¬¦ã€‚ èˆå¼ƒå›è½¦ç¬¦çš„æ–¹æ³•ï¼šä»¥Enterç»“æŸè¾“å…¥æ—¶ï¼Œæ¥å—ç©ºæ ¼ï¼Œä¼šèˆå¼ƒæœ€åçš„å›è½¦ç¬¦ã€‚ -&gt;while ((ch=getchar()) != 'EOF') getcharå…ˆè¯»å–ä¸€ä¸ªå­—ç¬¦æ”¾åˆ°ché‡Œé¢å»ï¼Œå¦‚æœè¿™ä¸ªå­—ç¬¦ä¸ç­‰äºEOFï¼Œå°±è¿›å…¥å¾ªç¯ï¼Œæ‰“å°è¿™ä¸ªå­—ç¬¦ã€‚å½“getcharè¯»åˆ°æ–‡ä»¶æœ«å°¾æˆ–è€…ç»“æŸæ—¶ï¼Œå®ƒä¼šè¿”å›ä¸€ä¸ªEOFï¼Œæ­¤æ—¶ç»“æŸå¾ªç¯ã€‚ The while loop expression while((c = getchar()) != EOF) is used to read a char from the input until it sees the special value defined EOF. EOFï¼Œä¸ºEnd Of Fileçš„ç¼©å†™ï¼Œé€šå¸¸åœ¨æ–‡æœ¬çš„æœ€åå­˜åœ¨æ­¤å­—ç¬¦è¡¨ç¤ºèµ„æ–™ç»“æŸã€‚Cè¯­è¨€ä¸­ï¼ŒEOFå¸¸è¢«ä½œä¸ºæ–‡ä»¶ç»“æŸçš„æ ‡å¿—ã€‚è¿˜æœ‰å¾ˆå¤šæ–‡ä»¶å¤„ç†å‡½æ•°å¤„é”™è¯¯åçš„è¿”å›å€¼ä¹Ÿæ˜¯EOFï¼Œå› æ­¤å¸¸è¢«ç”¨æ¥åˆ¤æ–­è°ƒç”¨ä¸€ä¸ªå‡½æ•°æ˜¯å¦æˆåŠŸã€‚ The for statement and its while analog Keyword for expression 1; expression two ; and then expression 3. e1 is most typically used as an initializer, just like in our simple example. e2 is typically, well, that's always the terminating condition. So if it's going to work and it's going to be over a finite number of times, then this f determinate, that's where you can make some interesting mistakes, and get what's called an infinite loop. So this has to be tested. e3 is typically, again, this all typical, the typical use is either increment or decrement. So the terminating condition frequently involves mostly an integer, expression of variable and then incrementing that integer or decrementing it leads to a termination condition. think about i++ and ++i. #include &lt;stdio.h&gt; int main() { int i=5,j; j=i++; printf (&quot;\\nafter postfix increment i=%d j=%d&quot;, i,j); i=5; j=++i; printf (&quot;\\n after prefix increment i=%d j=%d&quot;,i,j); return 0; } the output is: after postfix increment i=6 j=5 after prefix increment i=6 j=6 oddball operators-conditional and comma äºŒç›®/ä¸‰ç›®è¿ç®—çš„é€»è¾‘ï¼š c = (a &lt; b)? a:b means: if a &lt; b: c = a else c = a -&gt;express? expr1:expre2 #include&lt;stdio.h&gt; int main(void){ int speed; printf(&quot;Enter a speed as a integer:&quot;); scanf(&quot;%d&quot;,&amp;speed); speed = (speed &lt;= 65) ? (65):(speed &lt;= 70) ? (70):(90); switch (speed) { case 65: //TODO printf(&quot;safe&quot;); break; case 70: //TODO printf(&quot;little dangerous&quot;); break; case 90: printf(&quot;very dangerous&quot;); break; default: //TODO printf(&quot;incorrect speed&quot;); break; } return 0; } Break and continue and switch breakä¸continueçš„çš„ç”¨æ³•ä»¥åŠåŒºåˆ«ï¼š å½“å®ƒä»¬ç”¨åœ¨å¾ªç¯è¯­å¥åšå¾ªç¯ä½“æ—¶ï¼Œbreakç”¨äºç«‹å³é€€å‡ºæœ¬å±‚å¾ªç¯ï¼Œè€Œcontinueä»…ä»…ç»“æŸæœ¬æ¬¡å¾ªç¯ï¼ˆæœ¬æ¬¡å¾ªç¯ä½“å†…ä¸æ‰§continueè¯­å¥åçš„å…¶å®ƒè¯­å¥ï¼Œä½†ä¸‹ä¸€æ¬¡å¾ªç¯è¿˜ä¼šç»§ç»­æ‰§è¡Œã€‚ å¦‚æœæœ‰å¤šå±‚å¾ªç¯æ—¶ï¼Œbreakåªä¼šè·³å‡ºæœ¬å±‚å¾ªç¯ï¼Œä¸ä¼šè·³å‡ºå…¶ä»–å±‚çš„å¾ªç¯ breakå¯ç”¨äºswitchè¯­å¥ï¼Œè¡¨ç¤ºè·³å‡ºæ•´ä¸ªswitchè¯­å¥å—ï¼Œè€Œcontinueåˆ™ä¸èƒ½å•ç‹¬çš„ç”¨äºswitchè¯­å¥ã€‚ä½†æ˜¯continueå¯ä»¥ç”¨äºå¾ªç¯å†…éƒ¨çš„switchè¯­å¥ In a switch statement, basically you switched on an integral expression. So simple one might be the integer i, and then you have a bunch of cases and those cases can,Be critical cases where you want to do different things depending on some small value of i. what you're looking at syntactically is switch an integral expression, it can't be floating point, it must be integral. But it could be something like a short or a long in, or ASCII value for character.If there is no default, then you just don't do anything and you leave. Switchå¤šè·¯é€‰æ‹©ç»“æ„ï¼Œå¸¸ç”¨è¯­ä¸‰ä¸ªåŠä»¥ä¸Šé—®é¢˜çš„å¤šé€‰æ–¹æ¡ˆã€‚ switch (speed) { case 65: //TODO printf(&quot;safe&quot;); break; case 70: //TODO printf(&quot;little dangerous&quot;); break; case 90: printf(&quot;very dangerous&quot;); break; default: //TODO printf(&quot;incorrect speed&quot;); break; } functions, recursion, arrays, and pointers types of functions Functions are important because they are crucial to the reuse of code.They're especially crucial if they exist in libraries. Libraries like standardio.h, standardlive.h, these are universally useful libraries, and we don't have to rewrite them. So we have to understand how to use them. Our syntax for a function. We have a types such as int or void. We have a function name, and the function name is a form of documentation like printf, or rand, or main. Then we have a parameter list. Then you have the body of the function, which is typically this bracing close what we call block. The block starts with a bunch of declarations if needed, and then a bunch of executable statements. void The function does not need any return statement int The function can return any value,the function exits at the end of its compound statement/block definition. return A return statement is a flow of control keyword return, and we've already seen it. At the end of a function in main, what it's meaning is that main returns of value zero, but where does return it to? Main is the program that you're executing, it returns it to the operating system, and it's used by the operating system sometimes to figure out whether if there was an error in the program. So return of zero means the program finished in an expected or orderly way, a normal exit. people generally when they're returning expression even if they don't need to, because of clarity stylistically they do use parenthesization. Storage class è¯¦è§£å››ç§å­˜å‚¨å˜é‡ auto:This is the default storage class for all the variables declared inside a function or a block. Hence, the keyword auto is rarely used while writing programs in C language. Auto variables can be only accessed within the block/function they have been declared and not outside them (which defines their scope). Of course, these can be accessed within nested blocks within the parent block/function in which the auto variable was declared. However, they can be accessed outside their scope as well using the concept of pointers given here by pointing to the very exact memory location where the variables reside. They are assigned a garbage value by default whenever they are declared. åœ¨å‡½æ•°ä½“ä¸­å£°æ˜åˆ™åªèƒ½åœ¨å½“å‰å‡½æ•°ä½“ä¸­ä½¿ç”¨,åœ¨mainå‡½æ•°ä»¥åŠå…¶ä»–å‡½æ•°å¤–å£°æ˜å³ä¸ºå…¨å±€å˜é‡ **extern:**Extern storage class simply tells us that the variable is defined elsewhere and not within the same block where it is used. Basically, the value is assigned to it in a different block and this can be overwritten/changed in a different block as well. So an extern variable is nothing but a global variable initialized with a legal value where it is declared in order to be used elsewhere. It can be accessed within any function/block. Also, a normal global variable can be made extern as well by placing the â€˜externâ€™ keyword before its declaration/definition in any function/block. This basically signifies that we are not initializing a new variable but instead we are using/accessing the global variable only. The main purpose of using extern variables is that they can be accessed between two different files which are part of a large program. For more information on how extern variables work, have a look at this link. å¦‚æœä¸€ä¸ªæ–‡ä»¶è°ƒç”¨å¦ä¸€ä¸ªæ–‡ä»¶ä¸­çš„å˜é‡ï¼Œåˆ™åœ¨è°ƒç”¨æ–‡ä»¶ä¸­éœ€è¦ä½¿ç”¨externå£°æ˜å˜é‡ static:This storage class is used to declare static variables which are popularly used while writing programs in C language. Static variables have the property of preserving their value even after they are out of their scope! Hence, static variables preserve the value of their last use in their scope. So we can say that they are initialized only once and exist till the termination of the program. Thus, no new memory is allocated because they are not re-declared. Their scope is local to the function to which they were defined. Global static variables can be accessed anywhere in the program. By default, they are assigned the value 0 by the compiler.é™æ€å˜é‡å¦‚æœæ²¡æœ‰è¢«åˆå§‹åŒ–ï¼Œåˆ™è‡ªåŠ¨åˆå§‹åŒ–ä¸º0ã€‚é™æ€å˜é‡åªèƒ½å¤Ÿåˆå§‹åŒ–ä¸€æ¬¡ **register:**This storage class declares register variables that have the same functionality as that of the auto variables. The only difference is that the compiler tries to store these variables in the register of the microprocessor if a free registration is available. This makes the use of register variables to be much faster than that of the variables stored in the memory during the runtime of the program. If a free registration is not available, these are then stored in the memory only. Usually few variables which are to be accessed very frequently in a program are declared with the register keyword which improves the running time of the program. An important and interesting point to be noted here is that we cannot obtain the address of a register variable using pointers. å£°æ˜ä¸ºregisterçš„å˜é‡åœ¨ç”±å†…å­˜è°ƒå…¥åˆ°CPUå¯„å­˜å™¨åï¼Œåˆ™å¸¸é©»åœ¨CPUçš„å¯„å­˜å™¨ä¸­ recursion-&gt;é€’å½’ In the recursive case, we have a test to see if we're what we're going to call the base case.So if we're at the base case, n equals zero and we're going to print blastoff. If we're not at the base case, then we have to do the recursion. Pointers and Arrays è®¤çœŸå­¦å¥½æŒ‡é’ˆï¼ array Int data square bracket, a hundred square bracket, semicolon. So as with normal declaration is a types this could be any of the standard types like double long char and identifier that should indicate what we're processing. //æ•°ç»„åˆ›å»ºï¼šintæ˜¯æ•°ç»„ç±»å‹ï¼›arræ˜¯åå­—ï¼›100æ˜¯æ•°ç»„é•¿åº¦ int arr[100]; //stringæ•°ç»„ char str[] = &quot;abc&quot;; Wi-Ki: Recursion (adjective: recursive) occurs when a thing is defined in terms of itself or of its type. Recursion is used in a variety of disciplines ranging from linguistics to logic. The most common application of recursion is in mathematics and computer science, where a function being defined is applied within its own definition. While this apparently defines an infinite number of instances (function values), it is often done in such a way that no infinite loop or infinite chain of references (&quot;crock recursion&quot;) can occur. #include&lt;stdio.h&gt; int main(void){ const int SIZE = 5; int grades[5] = {78, 57, 85, 99, 66}; double sum = 0.0; double ave = 0.0; printf(&quot;my scores are:\\n&quot;); for(int i = 0;i &lt; SIZE;i++){ sum += grades[i]; } printf(&quot;sum=%lf\\n&quot;,sum); ave = sum / SIZE; printf(&quot;ave=%lf\\n&quot;,ave); return 0; } pointers-ä¼ è¯´ä¸­çš„æŒ‡é’ˆ ç®€è€Œè¨€ä¹‹ï¼ŒæŒ‡é’ˆåªæœ‰ä¸¤å¤§é‡è¦ä½œç”¨ï¼šä¼ é€’å’Œåç§»ã€‚ Exactly how is an array stored in memory? What we have to understand is an array has a place where it's stored and it starts at what's called its base address. That's because we want a bunch of elements. ç†è§£æŒ‡é’ˆå°±è¦ç†è§£æ•°ç»„åœ¨è®¡ç®—æœºä¸­çš„å­˜å‚¨åŸç†å’Œåœ°å€çš„å«ä¹‰ we have to have a place to start, and then it runs contiguously through as much memory as is needed. That gets allocated automatically in this case by the compiler. The array has a very strong relationship with another data type called a pointer. A simple data type like an integer, when we say integer a inside a block, it means create a variable in memory. So when we think of a variable, we think of its name. That's how we use it in the code but we think it has a location and memory, and inside that location is some stored value interpreted as an integer. So an address calculation for an array in C, base address plus the offset, the index times the size required, the size in bytes required to store that individual datatype. But if you just want to be a simple programmer, it may be enough to just understand that indexing works for you. But really to get to the next level, you want to really understand the notion of address. If we tried to print the value of P, we would get some address. If we were to dereference it, star is a dereferencing. If we were to dereference P, the value there would be the integer valueã€‚ Very important that you get to understand pointer, variable, memory address. å‡½æ•° å€¼ä¼ é€’VSå¼•ç”¨ä¼ é€’ call--by-value æŒ‰å€¼è°ƒç”¨ call by reference å¼•ç”¨è°ƒç”¨ #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int SumArr(int A[]){ int i,sum = 0; int size = sizeof(A)/sizeof(A[0]); printf(&quot;Subfunc - size of A =%d,size of A[0] = %d\\n&quot;,sizeof(A),sizeof(A[0])); for(i = 0;i &lt; size;i++){ sum += A[i]; } } int main(void){ int A[] = {1,2,3,4,5}; int size = sizeof(A)/sizeof(A[0]); int total = SumArr(A); printf(&quot;the sum = %d\\n&quot;,total); printf(&quot;mian - size of A =%d,size of A[0] = %d\\n&quot;,sizeof(A),sizeof(A[0])); return 0; } åœ¨å­å‡½æ•°ä¸­ï¼Œåªæ˜¯æ‹·è´çš„ä¸»å‡½æ•°ä¸­æ•°ç»„çš„é¦–åœ°å€ï¼Œè€Œä¸æ˜¯æŠŠä¸»å‡½æ•°ä¸­æ‰€æœ‰çš„æ•°ç»„å…ƒç´ ä¼ å…¥åˆ°å­å‡½æ•°çš„æ•°ç»„ä¸­ã€‚æ— è®ºæ˜¯ä¼ å…¥æ™®é€šç±»å‹è¿˜æ˜¯æŒ‡é’ˆç±»å‹ã€‚ When using a reference declaration in a function header to simulate call-by-reference, it means the referenced variable in the calling environment can be changed. Keep in mind this is what scanf() does. Unlike many programming languages an array name in C is just a pointer to a base address and there is no way to know its size. äº†è§£ä¸€ä¸‹å˜é‡ç±»å‹åœ¨æ•°ç»„ä¸­æ‰€å æœ‰çš„å†…å­˜å¤§å°ï¼š types size int 4-bytes char 1-bytes float 4-bytes int main{ int a =5; int *p; p = &amp;a;//på°±æ˜¯açš„åœ°å€ printf(&quot;%p&quot;,p);//æŒ‡é’ˆå˜é‡ printf(&quot;%p&quot;,&amp;a);//açš„åœ°å€ printf(&quot;%p&quot;,&amp;p);//æŒ‡é’ˆpçš„åœ°å€-â€œåœ°å€çš„åœ°å€â€ printf(&quot;%d&quot;,*p);//æŒ‡é’ˆçš„è§£å¼•ç”¨-Dereference } æŒ‡é’ˆçš„åç§» int arr[] = {12,23,34}; int *p = arr; printf(&quot;%p\\n&quot;,&amp;arr[1]); printf(&quot;%p\\n&quot;,arr+1); printf(&quot;%p\\n&quot;,&amp;arr+1);//&amp;arr+1æ˜¯è·³è¿‡äº†æ•´ä¸ªæ•°ç»„å»å¯»å€¼ printf(&quot;%p\\n&quot;,p+1); printf(&quot;%d\\n&quot;,p[1]); printf(&quot;%d&quot;,*(p+2)); åŠ¨æ€å†…å­˜ç”³è¯· å¼•å…¥**#include&lt;stdlib.h&gt;ï¼Œå¤´æ–‡ä»¶ï¼›è°ƒç”¨malloc**ç”³è¯·å†…å­˜ã€‚ æ•°ç»„ä¸€å¼€å§‹å®šä¹‰å°±ç¡®å®šå¥½äº†ï¼Œæ•°ç»„æ˜¯æ”¾åœ¨æ ˆç©ºé—´ã€‚Cè¯­è¨€æ•°ç»„é•¿åº¦å›ºå®šæ˜¯å› ä¸ºå…¶å›ºå®šåœ¨æ•´å‹ã€æµ®ç‚¹å‹ã€å­—ç¬¦å‹ã€æ•°ç»„å˜é‡çš„æ ˆç©ºé—´ä¸­ï¼Œè€Œå ç©ºé—´çš„å¤§å°æ˜¯åœ¨ç¼–è¯‘æ—¶ç¡®å®šå¥½çš„ï¼Œå¦‚æœæ ˆç©ºé—´ä¸ç¡®å®šï¼Œé‚£å°±è¦å­˜æ”¾åœ¨å †ç©ºé—´ã€‚ æ ˆç©ºé—´-&gt;æ•™å®¤å¤§å°/é•¿åº¦å›ºå®š å †ç©ºé—´-&gt;é•¿åº¦ä¸å›ºå®š å¿…é¡»å…ˆç”³è¯·å†…å­˜åœ¨è¿›è¡Œæ“ä½œï¼ï¼ï¼ï¼ï¼ LinkList CreatList2(LinkList &amp;L){ //å¿…é¡»å…ˆç”³è¯·å†…å­˜åœ¨è¿›è¡Œæ“ä½œ int x; L = (LinkList)malloc(sizeof(LNode)); LNode *s; LNode *r = L;//ç­‰ä»·äºLinkList r=L; //L = (LinkList)malloc(sizeof(LNode)); scanf(&quot;%d&quot;,&amp;x); while(x != 9999){ s = (LinkList)malloc(sizeof(LNode)); s-&gt;data = x; r-&gt;next = s; r = s; scanf(&quot;%d&quot;,&amp;x); } r-&gt;next = NULL; return L; } æ‚¨æ¯”å¦‚è¯´è¿™ä¸ªå°¾æ’æ³•ï¼Œæˆ‘ä¸€å¼€å§‹æ˜¯è¿™ä¹ˆå†™çš„ï¼š int x; //L = (LinkList)malloc(sizeof(LNode)); LNode *s; LNode *r = L;//ç­‰ä»·äºLinkList r=L; L = (LinkList)malloc(sizeof(LNode)); ç¨‹åºçš„æ‰§è¡Œé¡ºåºæ˜¯ä»ä¸Šåˆ°ä¸‹çš„ï¼Œåˆ‡è®°ï¼›æ‰€ä»¥å†…å­˜åç”³è¯·æ€»æ˜¯çˆ†é”™ã€‚ ä¿®æ”¹é¡ºåºåï¼Œç«‹é©¬å°±å¯¹äº†ï¼š int x; L = (LinkList)malloc(sizeof(LNode)); LNode *s; LNode *r = L;//ç­‰ä»·äºLinkList r=L x.mallocå¿…é¡»å†™åœ¨å‰é¢ï¼Œè¡€çš„æ•™è®­å•Š!ğŸ˜¢ Cè¯­è¨€ä¸­C++çš„å¼•ç”¨ åœ¨ä¸¥è”šæ•è€å¸ˆçš„ã€Šæ•°æ®ç»“æ„ã€‹ä¸€ä¹¦ä¸­ï¼Œä¼ªä»£ç ç»™å‡ºçš„æ˜¯ä½¿ç”¨C++çš„æ–¹å¼ï¼Œæ‰€ä»¥åœ¨ç¼–è¯‘å™¨ä¸­åˆ›å»ºæ–‡ä»¶æ—¶ï¼Œä¸€å®šè¦æŠŠæ–‡ä»¶åç¼€æ”¹æˆ.cppæ–‡ä»¶è€Œä¸æ˜¯.cæ–‡ä»¶ã€‚ åœ¨å‚æ•°ä¼ é€’ä¸è°ƒç”¨çš„è¿‡ç¨‹ä¸­ï¼Œä½“ç°å‡ºæ¥äº†C++å¯¹äºå‚æ•°ä¼ é€’å’Œè°ƒç”¨çš„ä¾¿æ·æ€§ã€‚ void change(int &amp;a){ a = a + 1; } int main(){ int i = 10; change(i); printf(&quot;i = %d&quot;,i); return 0; } -&gt;ä¸ºä»€ä¹ˆæˆ‘ä»¬éœ€è¦åœ¨å½¢å‚çš„åœ°æ–¹ä½¿ç”¨C++çš„å¼•ç”¨ï¼Ÿ åœ¨å­å‡½æ•°ä¸­å»æ”¹å˜å¯¹åº”çš„å½¢å‚èµ‹å€¼åï¼Œå­å‡½æ•°ç»“æŸåï¼Œå¯¹åº”ä¸»å‡½æ•°çš„å®å‚å°±å‘ç”Ÿäº†å˜åŒ–ã€‚ å¦‚æœæ²¡æœ‰ä½¿ç”¨å¼•ç”¨ï¼Œé‚£ä¹ˆåœ¨å­å‡½æ•°ä¸­ç»™å½¢å‚èµ‹å€¼ï¼›å­å‡½æ•°ç»“æŸåï¼Œä¸»å‡½æ•°ä¸­çš„å®å‚ä¸ä¼šå‘ç”Ÿå˜åŒ–ã€‚ å…¶å®è¯´ç™½äº†å°±æ˜¯ï¼Œä½ åœ¨å­å‡½æ•°ä¸­è¦ä¸è¦æ”¹å˜å®å‚çš„å€¼-&gt;çœ‹å®é™…éœ€æ±‚ï¼Œå¦‚æœè°ƒç”¨çš„å­å‡½æ•°å°±æ˜¯ç”¨æ¥å»æ”¹å˜å®å‚çš„ï¼Œé‚£ä¹ˆå°±å¿…é¡»åŠ ä¸Šå¼•ç”¨ï¼Œå¦åˆ™ï¼Œå°±ä¸éœ€è¦åŠ å¼•ç”¨ï¼Œå½¢å‚å°±æ˜¯ä¸€ä¸ªè¾…åŠ©å˜é‡ã€‚å€ŸåŠ©å½¢å‚ï¼Œå»å®ç°å‡½æ•°åŠŸèƒ½ã€‚ å¦‚æœä¸ç†è§£ï¼Œä»»ä½•æƒ…å†µä¸‹éƒ½åŠ ä¸Š&amp; ç»“æ„ä½“å®šä¹‰æ—¶çš„å°ç»†èŠ‚åŒºåˆ«å¯¹æ¯”-typedef ç»“æ„ä½“å®šä¹‰å‰åŠ ä¸ä¸åŠ typedefçš„åŒºåˆ«æ˜¯åœ¨è°ƒç”¨ç»“æ„ä½“çš„æ—¶å€™å‘ç°çš„ã€‚ é¦–å…ˆå¯¹äºä¸åŒæ–¹å¼åˆ›å»ºç»“æ„ä½“ï¼š //å®šä¹‰typedefç»“æ„ä½“ typedef struct student{ int ID; char name[10]; char sex; }stu; //å®šä¹‰æ— typedefç»“æ„ä½“ struct student{ int ID; char name[10]; char sex; }stu; ä¸¤ç§åˆ›å»ºæ–¹å¼è™½ç„¶åŠŸèƒ½ä¸Šå¤§ä½“ä¸€è‡´ï¼Œä½†æ˜¯å¯¹äºstuè¿™ä¸ªåˆ«åçš„ä½¿ç”¨ä¸Šç¡®æœ‰è¿™åƒå·®ä¸‡åˆ«ã€‚ é¦–å…ˆå¯¹äºtypedefå®šä¹‰çš„ç»“æ„ä½“æ¥è¯´ï¼Œstuæ˜¯å¯ä»¥åœ¨ä¸»å‡½æ•°ä¸­å»å®ä¾‹åŒ–ä¸€ä¸ªå¯¹è±¡çš„ã€‚å®šä¹‰äº†ç»“æ„ä½“ç±»å‹studentå’Œstudentçš„ç±»åˆ«åstu stu s; s.ID = 1; s.name = 'ss'; s.sex = 'M'; è¿™æ ·ä¹¦å†™å®Œå…¨æ²¡é—®é¢˜ï¼›ä½†æ˜¯å¦‚æœåˆ›å»ºADTä¹‹å‰ä¸åŠ typedefï¼Œè¿™æ ·åˆ›å»ºå°±ä¼šæŠ¥é”™ã€‚ä¸åŠ typedef,stuå°±æ˜¯ä¸€ä¸ªå•çº¯çš„å®ä¾‹åŒ–å¯¹è±¡äº†ï¼Œåªèƒ½åœ¨ä¸»å‡½æ•°å»ä½¿ç”¨å±æ€§ï¼Œè€Œä¸èƒ½å†å»å®ä¾‹åŒ–å…¶ä»–å˜é‡ã€‚å®šä¹‰äº†ç»“æ„ä½“ç±»å‹studentå’Œstudentçš„å¯¹è±¡å®ä¾‹stu stu.ID = 1; stu.name = 'ss'; stu.sex = 'M'; stu sä¼šæŠ¥é”™ã€‚ ç»“æ„ä¹Ÿæ˜¯ä¸€ç§æ•°æ®ç±»å‹, å¯ä»¥ä½¿ç”¨ç»“æ„å˜é‡, å› æ­¤åƒå…¶å®ƒç±»å‹çš„å˜é‡ä¸€æ ·, åœ¨ä½¿ç”¨ç»“æ„å˜é‡æ—¶è¦å…ˆå¯¹å…¶å®šä¹‰ã€‚ å®šä¹‰ç»“æ„å˜é‡çš„ä¸€èˆ¬æ ¼å¼ä¸º: struct ç»“æ„å { ç±»å‹ å˜é‡å; ç±»å‹ å˜é‡å; ... } ç»“æ„å˜é‡; ç»“æ„åæ˜¯ç»“æ„çš„æ ‡è¯†ç¬¦ä¸æ˜¯å˜é‡åã€‚ å¦ä¸€ç§å¸¸ç”¨æ ¼å¼ä¸º: typedef struct ç»“æ„å { ç±»å‹ å˜é‡å; ç±»å‹ å˜é‡å; ... } ç»“æ„åˆ«å; å¦å¤–æ³¨æ„: åœ¨Cä¸­ï¼Œstructä¸èƒ½åŒ…å«å‡½æ•°ã€‚åœ¨C++ä¸­ï¼Œå¯¹structè¿›è¡Œäº†æ‰©å±•ï¼Œå¯ä»¥åŒ…å«å‡½æ•°ã€‚ æ–‡ä»¶ç±»å‹å…³ç³» åªæœ‰.hæ–‡ä»¶çš„Packageå¯ä»¥æ˜¯æ¥å£æˆ–æ¨¡æ¿(template)çš„å®šä¹‰ï¼› åªæœ‰.cppæ–‡ä»¶çš„Packageå¯ä»¥æ˜¯ä¸€ä¸ªç¨‹åºçš„å…¥å£ã€‚ ç®€å•è®²ï¼Œä¸€ä¸ªPackageå°±æ˜¯ç”±åŒåçš„.hå’Œ.cppæ–‡ä»¶ç»„æˆã€‚å½“ç„¶å¯ä»¥å°‘å…¶ä¸­ä»»æ„ä¸€ä¸ªæ–‡ä»¶ã€‚ .cppæ˜¯C++æ–‡ä»¶çš„æ‰©å±•åï¼Œ.cppä¸»è¦æ˜¯è¿›è¡Œå‡½æ•°å®šä¹‰çš„ï¼Œç±»ä¸­å‡½æ•°çš„å£°æ˜å’Œè°ƒç”¨æ˜¯åœ¨.hä¸­çš„ï¼Œ.hæ–‡ä»¶ä¸»è¦æ˜¯æŠŠå‡½æ•°è¿›è¡Œå°è£…ï¼Œåœ¨å†™å¾ˆå¤šä»£ç çš„æ—¶å€™ï¼Œç”¨ä¸Š.hæœ‰å¾ˆå¥½çš„ä½œç”¨ï¼Œè¿™æ—¶å€™æˆ‘ä»¬åªè¦ç»™å¯¹æ–¹å…¬å¸*.hæ–‡ä»¶å°±è¡Œäº†ï¼Œè¿™æ ·æ—¢æä¾›äº†å¿…è¦çš„ä¿¡æ¯ï¼Œåˆä¿æŠ¤äº†æˆ‘ä»¬çš„æ ¸å¿ƒä»£ç ã€‚åœ¨.cppä¸­å¯¹.hæ–‡ä»¶è¿›è¡Œè°ƒç”¨æ—¶ï¼Œè¦ç”¨#include.xxxhã€‚å»ºè®®æŒ‰ç…§**.h *.cppé…å¯¹åˆ†å¼€å†™ã€‚ .cppå†…ç”¨äºï¼š å‡½æ•°å®ç°ï¼ˆåŒ…æ‹¬å…¨å±€å‡½æ•°ï¼ˆé»˜è®¤ï¼‰ã€é™æ€å‡½æ•°ï¼‰ å…¨å±€å˜é‡ã€é™æ€å˜é‡å®šä¹‰ é™æ€å‡½æ•°å£°æ˜ï¼Œé™æ€å˜é‡å£°æ˜.hå†…ç”¨äº hå†…ç”¨äºï¼š å…¨å±€å‡½æ•°å£°æ˜ï¼Œæ³¨æ„é™æ€å‡½æ•°ä¸åŒ…æ‹¬åœ¨å†…ã€‚ å…¨å±€å˜é‡å£°æ˜ï¼Œæ— é™æ€å˜é‡ã€‚ ç‰ˆæƒå£°æ˜ï¼šæœ¬æ–‡ä¸ºCSDNåšä¸»ã€Œèœé¸Ÿç¨‹åºå‘˜å°é»„ã€çš„åŸåˆ›æ–‡ç« ï¼Œéµå¾ªCC 4.0 BY-SAç‰ˆæƒåè®®ï¼Œè½¬è½½è¯·é™„ä¸ŠåŸæ–‡å‡ºå¤„é“¾æ¥åŠæœ¬å£°æ˜ã€‚ åŸæ–‡é“¾æ¥ï¼šhttps://blog.csdn.net/m0_55671922/article/details/115552516 é€»è¾‘ç»“æ„ä¸å­˜å‚¨ç»“æ„ æ•°æ®å­˜å‚¨çš„é€»è¾‘ç»“æ„æœ‰ï¼šé›†åˆç»“æ„ã€é“¾å¼ç»“æ„ã€æ ‘çŠ¶ç»“æ„ã€å›¾ç»“æ„ å­˜å‚¨ç»“æ„æœ‰ï¼šé¡ºåºå­˜å‚¨å’Œé“¾å¼å­˜å‚¨ çº¿æ€§è¡¨ ç‰¹ç‚¹ï¼š å…ƒç´ ä¸ªæ•°æ˜¯æœ‰é™çš„ è¡¨ä¸­æ•°æ®çš„æ•°æ®ç±»å‹å…¨éƒ¨ç›¸åŒ-&gt;æ¯ä¸ªå…ƒç´ å æœ‰ç›¸åŒçš„å†…å­˜ç©ºé—´ æ‰€æœ‰å…ƒç´ é€»è¾‘ä¸Šæ˜¯è¿ç»­çš„ï¼Œæ’åºæœ‰å…ˆåé¡ºåº çº¿æ€§è¡¨æ˜¯ç‹¬ç«‹äºæ•°æ®ç»“æ„çš„é€»è¾‘ç»“æ„ä¸æ˜¯å­˜å‚¨ç»“æ„ï¼Œä¸è¦è½»æ˜“æŠŠæ•°ç»„å’Œé“¾è¡¨ä¸çº¿æ€§è¡¨æ··æ·†ã€‚ ä¼˜ç‚¹ï¼š å¯ä»¥éšæœºå­˜å–è¡¨ä¸­çš„ä»»æ„ä¸€ä¸ªå…ƒç´ ï¼Œå­˜å‚¨å¯†åº¦é«˜ï¼Œæ¯ä¸ªå…ƒç´ åªå­˜å–æ•°æ®å…ƒç´  ç¼ºç‚¹ï¼š æ’å…¥å’Œåˆ é™¤æ—¶éœ€è¦ç§»åŠ¨å¤§é‡å…ƒç´ ï¼Œå˜åŒ–è¾ƒå¤§ï¼Œéš¾ä»¥ç¡®å®šå­˜å‚¨ç©ºé—´å¤§å°ï¼›éœ€è¦åˆ†é…è¿ç»­çš„å­˜å‚¨ç©ºé—´ï¼Œä¸å¤Ÿçµæ´»ã€‚ å•é“¾è¡¨ å•é“¾è¡¨çš„å¢åˆ æ”¹æŸ¥ é‡ç‚¹æŒæ¡å•é“¾è¡¨çš„å¤´æ’æ³•ä¸å°¾æ’æ³•çš„æ’å…¥æ€è·¯ã€‚ #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; //åœ¨æ­¤ç¨‹åºä¸­ï¼Œ*LinkListæ˜¯å˜é‡çš„æŒ‡é’ˆï¼›LinkListä¸ºæŒ‡é’ˆå˜é‡ã€‚ //å•é“¾è¡¨çš„å¢åˆ æ”¹æŸ¥ //çº¿æ€§è¡¨çš„é“¾å¼è¡¨ç¤ºå°±æ˜¯å•é“¾è¡¨ #define Maxsize 50 #define InitSize 100 //å®šä¹‰ä¸€ä¸ªæ•´å‹ç±»å‹çš„å˜é‡ typedef int ElemType; //å•é“¾è¡¨ç»“æ„åˆ›å»º-8ä¸ªå­—èŠ‚ typedef struct LNode {//å•é“¾è¡¨çš„ç»“æ„ ElemType data;//æ•°æ®åŸŸ struct LNode* next;//æŒ‡é’ˆåŸŸ }LNode,*LinkList; //LinkListä¸ºç»“æ„ä½“æŒ‡é’ˆç­‰ä»·äºstruct LNode* //åˆ«åLNodeå¯ä»¥å’Œä¸Šé¢ä¿æŒä¸€è‡´ //å¤´æ’æ³•æ’å…¥æ–°çš„èŠ‚ç‚¹ //åˆ›å»ºå•é“¾è¡¨-&gt;å¸¦æœ‰å¤´ç»“ç‚¹ //å¤´ç»“ç‚¹åªéœ€è¦å¤´æŒ‡é’ˆæŒ‡å‘ï¼Œå•¥ä¹Ÿä¸å­˜ LinkList CreatList1(LinkList &amp;L) { LNode* q; int x; L = (LinkList)malloc(sizeof(LNode));//å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨ L-&gt;next = NULL; scanf_s(&quot;%d&quot;, &amp;x); while (x != 9999) { q = (LinkList)malloc(sizeof(LNode)); q-&gt;data = x; q-&gt;next = L-&gt;next; L-&gt;next = q; scanf_s(&quot;%d&quot;, &amp;x); } return L; } //å°¾æ’æ³•åˆ›å»ºå•é“¾è¡¨ LinkList CreatList2(LinkList &amp;L) { int x; L = (LinkList)malloc(sizeof(LNode));//å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨ //åœ¨è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œræœ¬èº«å°±æ˜¯è¡¨å°¾èŠ‚ç‚¹,æŒ‡å‘é“¾è¡¨å°¾éƒ¨ LNode* s, * r = L;//ç­‰ä»·äºLinkList s,r=L; scanf_s(&quot;%d&quot;, &amp;x); while (x != 9999) { s = (LinkList)malloc(sizeof(LNode)); s-&gt;data = x; r-&gt;next = s; r = s;//ræŒ‡å‘æ–°çš„è¡¨å°¾èŠ‚ç‚¹ scanf_s(&quot;%d&quot;, &amp;x); } r-&gt;next = NULL;//å°¾èŠ‚ç‚¹æŒ‡é’ˆèµ‹å€¼ä¸ºç©º return L; } //æŸ¥æ‰¾èŠ‚ç‚¹ LNode* GetElem(LinkList L, int i) { int j = 1; //åˆå§‹æŒ‡å‘è™šæ‹Ÿå¤´ç»“ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ LNode* p = L-&gt;next; if (i == 0) { return L; } if (i &lt; 1) { return NULL; } //p-&gt;éç©º while (p &amp;&amp; j &lt; i) { p = p-&gt;next; j++; } return p; } //ä»»æ„ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹é—´æ’å…¥èŠ‚ç‚¹ //ç¬¬iä¸ªä½ç½®æ’å…¥å€¼ä¸ºeçš„èŠ‚ç‚¹ bool InsertFrontList(LinkList L,int i,ElemType e) { LinkList p = GetElem(L,i - 1); if (NULL == p) { return false; } LinkList s = (LNode*)malloc(sizeof(LNode));//ä¸ºæ–°æ’å…¥çš„èŠ‚ç‚¹ç”³è¯·å†…å­˜ç©ºé—´ s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; return true; } bool InsertBackList(LinkList L,ElemType e) { //L = (LinkList)malloc(sizeof(LNode));//å¸¦å¤´ç»“ç‚¹çš„é“¾è¡¨ while (L-&gt;next != NULL) { L = L-&gt;next; } LNode* q; int x; scanf_s(&quot;%d&quot;, &amp;x); while (x != 9999) { q = (LinkList)malloc(sizeof(LNode)); q-&gt;data = x; L-&gt;next = q; q-&gt;next = NULL; scanf_s(&quot;%d&quot;, &amp;x); } return L; } //æ— è®ºæ˜¯ä¸­é—´æ’å…¥è¿˜æ˜¯åˆ é™¤ï¼Œæ‰¾åˆ°éœ€è¦æ“ä½œèŠ‚ç‚¹çš„å‰é©±èŠ‚ç‚¹æ˜¯å…³é”® //åˆ é™¤ç¬¬iä¸ªä½ç½®çš„èŠ‚ç‚¹ bool DeleteList(LinkList L,int i) { //æ‰¾åˆ°è¦åˆ é™¤å…ƒç´ çš„å‰é©±ç»“ç‚¹ LinkList p = GetElem(L, i - 1); LinkList q = p-&gt;next; if (p == NULL) { return false;//è¦åˆ é™¤çš„ä½ç½®ä¸å­˜åœ¨ } p-&gt;next = q-&gt;next;//æ–­é“¾ free(q); q = NULL; return true; } void PrintList(LinkList L) { //å¤´ç»“ç‚¹ L = L-&gt;next; while (L != NULL) { printf(&quot;%d\\t&quot;, L-&gt;data); L = L-&gt;next; } } //æŸ¥æ‰¾ç¬¬å‡ ä¸ªå…ƒç´  LinkList LocateElem(LinkList L, ElemType e) { int j = 1; LinkList p = L-&gt;next; while (p != NULL &amp;&amp; p-&gt;data != e) { p = p-&gt;next; j++; } return p; } int main() { //å®šä¹‰é“¾è¡¨å¤´,ç»“æ„ä½“æŒ‡é’ˆç±»å‹ LinkList L; LinkList search;//ç”¨æ¥å­˜å‚¨æ‹¿åˆ°çš„æŸä¸€ä¸ªèŠ‚ç‚¹ LinkList search1; printf(&quot;è¯·åœ¨ä¸‹æ–¹è¾“å…¥å•é“¾è¡¨çš„å€¼ï¼šï¼ˆ^_^å¤§äº5ä¸ªå…ƒç´ ä¸”è¾“å…¥9999ç»ˆæ­¢^_^ï¼‰\\n&quot;); CreatList1(L); printf(&quot;å¤´æ’æ³•çš„ç»“æœä¸ºï¼š&quot;); PrintList(L); search = GetElem(L, 2); if (search != NULL) { printf(&quot;\\næŒ‰åºå·æŸ¥æ‰¾æˆåŠŸï¼~\\n&quot;); printf(&quot;è¯¥ä½ç½®çš„å€¼ä¸ºï¼š%3d\\n&quot;, search-&gt;data); } search1 = LocateElem(L, 5); /* if (search1 != NULL) { printf(&quot;\\næŒ‰åºå·æŸ¥æ‰¾æˆåŠŸï¼~\\n&quot;); printf(&quot;è¯¥çš„å€¼ä¸ºï¼š%3d&quot;, search-&gt;data); } */ InsertFrontList(L, 3, 30); PrintList(L); printf(&quot;\\n-----------\\n&quot;); printf(&quot;åˆ é™¤åçš„ç»“æœä¸ºï¼š\\n&quot;); DeleteList(L, 3); PrintList(L); printf(&quot;\\n-----------\\n&quot;); printf(&quot;è¯·åœ¨ä¸‹æ–¹è¾“å…¥å•é“¾è¡¨çš„å€¼ï¼šï¼ˆ^_^å¤§äº5ä¸ªå…ƒç´ ä¸”è¾“å…¥9999ç»ˆæ­¢^_^ï¼‰\\n&quot;); CreatList2(L); printf(&quot;å°¾æ’æ³•çš„ç»“æœä¸ºï¼š&quot;); PrintList(L); return 0; } æ ˆ åªå…è®¸åœ¨ä¸€ç«¯è¿›è¡Œæ’å…¥æˆ–è€…åˆ é™¤çš„çº¿æ€§è¡¨ï¼Œæ ˆé¡¶ï¼ˆtopï¼‰ã€‚åè¿›å…ˆå‡º-&gt;LIFO ä¸¤ç§é‡è¦çš„è®¡ç®—æœºæ€ç»´ ä¸¤ç§é‡è¦çš„ç¼–ç¨‹æ€ç»´åœ¨æ—¥å¸¸ç»ƒä¹ ä¸­æå…¶é‡è¦ï¼Œå¯¹äºè®¡ç®—æ€ç»´çš„åŸ¹å…»æ˜¯å†³å®šä¸€ä¸ªç¨‹åºå‘˜èƒ½èµ°å¤šè¿œçš„å…³é”®æ‰€åœ¨ã€‚åœ¨å¹³æ—¶çš„ç¼–ç¨‹ç»ƒä¹ æ—¶è¦æ³¨é‡å¯¹äºä¸¤ç§æ€ç»´çš„åŸ¹å…»ä¸è®­ç»ƒã€‚ é€’å½’-é€†å‘æ€è€ƒ åˆ†æ²»-åŒ–ç¹ä¸ºç®€ å¯¹äºåˆ†æ²»ç®—æ³•çš„ç†è§£æ°´å¹³å’Œåº”ç”¨çš„å¾—å¿ƒåº”æ‰‹çš„ç¨‹åº¦ï¼Œæ˜¯è¡¡é‡ä¸€ä¸ªç¨‹åºçœ¼è®¡ç®—ç´ å…»çš„æ ‡å°ºã€‚è¿™ä¸€å…³æ— æ³•çªç ´å°±æ— æ³•æˆä¸ºä¸€ä¸ªå››çº§å·¥ç¨‹å¸ˆã€‚ å¯¹äºåˆ†æ²»ç®—æ³•ç†è§£çš„ä¸‰ä¸ªå±‚æ¬¡ï¼š äº†è§£çš®æ¯›ï¼Œè§£å†³ä¸€äº›ç®—æ³•ä¹ é¢˜ çµæ´»è¿ç”¨è®¡ç®—æ€ç»´ï¼Œè§£å†³å¤§é—®é¢˜ æŒæ¡ç²¾é«“ï¼Œè§£å†³ä»¥å‰ä»æœªè§£å†³çš„é—®é¢˜ åˆ†æ²»ç®—æ³•çš„æ­¥éª¤æè¿°ï¼š å°†å¤æ‚çš„é—®é¢˜åˆ†æˆè‹¥å¹²ä¸ªç®€å•çš„å­é—®é¢˜è¿›è¡Œè§£å†³ã€‚-&gt;åˆ†å‰² è§£å†³æ¯ä¸€ä¸ªå­é—®é¢˜ï¼Œè‹¥æœå­é—®é¢˜å¾ˆå¤§ç»§ç»­é€’å½’åˆ†è§£ã€‚-&gt;è§£å†³ å¯¹å­é—®é¢˜çš„ç»“æœè¿›è¡Œåˆå¹¶ã€‚-&gt;åˆå¹¶ forå¾ªç¯çš„å‡ ç§ä¹¦å†™æ–¹æ³• ä¸‹æ ‡å¾ªç¯ for(int i = 0;i &lt; nums.size();i++){ //æ“ä½œ ...... } å¦‚æœäº‹å…ˆå£°æ˜äº†ç´¢å¼•ä¸‹æ ‡ï¼Œåˆ™ä¸éœ€è¦åœ¨forå¾ªç¯ä¸­è¿›è¡Œä¸‹æ ‡çš„åˆå§‹åŒ–ã€‚ int i = 0; for(;i &lt; nums.size();i++){ //æ“ä½œ ...... } æ­»å¾ªç¯å½¢å¼ for(;;){ //æ“ä½œ ...... } è¿­ä»£å™¨å¾ªç¯ vector&lt;char&gt;myvector(arc,arc+23); vector&lt;char&gt;::iterator iter; //forå¾ªç¯éå† vector å®¹å™¨ for (iter = myvector.begin(); iter != myvector.end(); ++iter) { cout &lt;&lt; *iter; } for(auto ite : array) C++ 11 æ ‡å‡†ä¸­ï¼Œé™¤æ²¿ç”¨å‰é¢ä»‹ç»çš„ç”¨æ³•å¤–ï¼Œä¸º for å¾ªç¯æ·»åŠ äº†æ–°çš„è¯­æ³•æ ¼å¼ æ—§æ ¼å¼çš„ for å¾ªç¯å¯ä»¥æŒ‡å®šå¾ªç¯çš„èŒƒå›´ è€Œ C++11 æ ‡å‡†å¢åŠ çš„ for å¾ªç¯ï¼Œåªä¼šé€ä¸ªéå† expression å‚æ•°å¤„æŒ‡å®šåºåˆ—ä¸­çš„æ¯ä¸ªå…ƒç´  **for(auto a:b)**ä¸­bä¸ºä¸€ä¸ªå®¹å™¨æˆ–è€…æ•°ç»„ï¼Œæ•ˆæœæ˜¯åˆ©ç”¨aéå†å¹¶è·å¾—bå®¹å™¨ä¸­çš„æ¯ä¸€ä¸ªå€¼ï¼Œä½†æ˜¯aæ— æ³•å½±å“åˆ°bå®¹å™¨ä¸­çš„å…ƒç´ ã€‚ **for(auto &amp;a:b)**ä¸­åŠ äº†å¼•ç”¨ç¬¦å·ï¼Œå¯ä»¥å¯¹å®¹å™¨ä¸­çš„å†…å®¹è¿›è¡Œèµ‹å€¼ï¼Œå³å¯é€šè¿‡å¯¹aèµ‹å€¼æ¥åšåˆ°å®¹å™¨bçš„å†…å®¹å¡«å……ã€‚ 1ã€æ•°ç»„ int array[] = {1, 2, 3, 4, 5}; for(auto e : array) cout &lt;&lt; e &lt;&lt; endl; ç­‰ä»·äº for(int i = 0; i &lt; 5; i++) cout &lt;&lt; array[i]&lt;&lt;endl; 2ã€å­—ç¬¦ä¸² string str = &quot;hello world&quot;; for(auto ch : str) cout &lt;&lt; ch &lt;&lt;endl; ç­‰ä»·äº for(int i = 0; i &lt;str.size(); i++) cout &lt;&lt; str[i] &lt;&lt;endl; 3ã€vector vector&lt;int&gt; m_v = {1, 2, 3, 4}; for(auto e : m_v) cout &lt;&lt; e &lt;&lt;endl; ç­‰ä»·äº for(int i = 0; i &lt; m_v.size(); i++) cout &lt;&lt;v[i]&lt;&lt;endl; 4ã€map map&lt;int,string&gt; m = {{1, &quot;abc&quot;}, {2, &quot;bca&quot;}, {3, &quot;cab&quot;}}; for(auto e : m) cout &lt;&lt;e.first&lt;&lt;&quot; &quot;&lt;&lt; e.second&lt;&lt;endl; ç­‰ä»·äº for(map&lt;int, string&gt;::iterator it = m.begin();it != m.end(); it++) cout &lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl; â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” ç‰ˆæƒå£°æ˜ï¼šæœ¬æ–‡ä¸ºCSDNåšä¸»ã€ŒAé˜¿å“²ã€çš„åŸåˆ›æ–‡ç« ï¼Œéµå¾ªCC 4.0 BY-SAç‰ˆæƒåè®®ï¼Œè½¬è½½è¯·é™„ä¸ŠåŸæ–‡å‡ºå¤„é“¾æ¥åŠæœ¬å£°æ˜ã€‚ åŸæ–‡é“¾æ¥ï¼šhttps://blog.csdn.net/zhanghaizhe/article/details/103460084 åŸºæœ¬çš„è¯­æ³• æœ€è¿‘å†™c++ä»£ç æ˜¯æ”¶åˆ°äº†ä¸€ä¸ªç–‘æƒ‘ï¼Ÿå°±æ˜¯è¯­å¥ä¸­å¸¦æœ‰ï¼Ÿï¼ˆé—®å·ï¼‰æ˜¯è¯­å¥ç†è§£ä¸å¥½ å…¶å®è¯­å¥ä¸­å¸¦æœ‰é—®å·çš„c++è¯­å¥ï¼Œæ˜¯if-else if-elseçš„ç®€ä¾¿æ–¹å¼ è¯¥æ“ä½œç¬¦æ˜¯ä¸‰å…ƒçš„ï¼Œå…¶ä¸€èˆ¬å½¢å¼ä¸ºï¼š EXP1? EXP2: EXP3 EXP1ï¼ŒEXP2å’ŒEXP3æ˜¯è¡¨è¾¾å¼ï¼Œæ³¨æ„å†’å·çš„ç”¨æ³•å’Œä½ç½®ã€‚ è¿™ä¸ªå†™æ³•å’ŒPythonä¸­çš„åŒ¿åå‡½æ•°ç›¸ä¼¼ã€‚ ç»™Pythonçš„åŒ¿åå‡½æ•°ä¸¾ä¸€ä¸ªä¾‹å­: lambda x : x*2 C++åŒ¿åå‡½æ•° æ‰€è°“åŒ¿åå‡½æ•°ï¼Œå…¶å®ç±»ä¼¼äºpythonä¸­çš„lambdaå‡½æ•°ï¼Œå…¶å®å°±æ˜¯æ²¡æœ‰åå­—çš„å‡½æ•°ã€‚ä½¿ç”¨åŒ¿åå‡½æ•°ï¼Œå¯ä»¥å…å»å‡½æ•°çš„å£°æ˜å’Œå®šä¹‰ã€‚è¿™æ ·åŒ¿åå‡½æ•°ä»…åœ¨è°ƒç”¨å‡½æ•°çš„æ—¶å€™æ‰ä¼šåˆ›å»ºå‡½æ•°å¯¹è±¡ï¼Œè€Œè°ƒç”¨ç»“æŸåç«‹å³é‡Šæ”¾ï¼Œæ‰€ä»¥åŒ¿åå‡½æ•°æ¯”éåŒ¿åå‡½æ•°æ›´èŠ‚çœç©ºé—´ã€‚ æ•°æ®ç±»å‹ 1ã€é¢„å®šä¹‰ç±»å‹ æ•´å‹ c++æœ‰å››ç§æ•´å‹ç±»å‹ï¼šshortã€intã€longã€long longï¼Œæ¯ç§éƒ½æœ‰signed(æœ‰ç¬¦å·ï¼Œé»˜è®¤)ã€unsigned(æ— ç¬¦å·)ä¸¤ç§åˆ†ç±»ï¼Œæœ‰ç¬¦å·æ•´æ•°æ—¢å¯ä»¥è¡¨ç¤ºéè´Ÿæ•´æ•°ï¼Œåˆå¯ä»¥è¡¨ç¤ºè´Ÿæ•´æ•°ï¼›ä½†æ˜¯ï¼Œæ— ç¬¦å·æ•´æ•°ä¸èƒ½è¡¨ç¤ºè´Ÿæ•°ï¼Œåªèƒ½è¡¨ç¤ºéè´Ÿæ•´æ•°ã€‚ â— shortè‡³å°‘16ä½ â— intè‡³å°‘ä¸shortä¸€æ ·é•¿ â— longè‡³å°‘32ä½ï¼Œä¸”è‡³å°‘ä¸intä¸€æ ·é•¿ â— long longè‡³å°‘64ä½ï¼Œä¸”è‡³å°‘ä¸longä¸€æ ·é•¿ å­—ç¬¦å‹ ç±»å‹ å«ä¹‰ è¯¥ç±»å‹æ•°æ®æ‰€å çš„æœ€å°æ¯”ç‰¹ä½æ•° char å­—ç¬¦ 8ä½ï¼ˆå³å¯è¡¨ç¤º28ä¸ªå­—ç¬¦ï¼‰ wchar_t å®½å­—ç¬¦ 16ä½ char16_t Unicodeå­—ç¬¦ 16ä½ char32_t Unicodeå­—ç¬¦ 32ä½ å¸ƒå°”å‹ å¸ƒå°”ç±»å‹(bool)æ˜¯C++æ–°å¢çš„ä¸€ç§åŸºæœ¬æ•°æ®ç±»å‹ï¼Œå°±æ˜¯å°†intå‹å®šä¹‰ä¸ºboolå‹ï¼Œå°†intå‹çš„0å’Œ1ä¸¤ä¸ªå€¼åˆ†åˆ«å®šä¹‰ä¸ºboolç±»å‹çš„ä¸¤ä¸ªå€¼trueå’Œfalseã€‚ æµ®ç‚¹å‹ ç±»å‹ è¯´æ˜ double 64ä½åŒç²¾åº¦æµ®ç‚¹å‹ float 32ä½å•ç²¾åº¦æµ®ç‚¹å‹ ç©ºç±»å‹ å…³é”®å­—voidå®šä¹‰çš„ç±»å‹ï¼Œä¸èƒ½ç”¨äºæ™®é€šå˜é‡çš„å£°æ˜å’Œæ™®é€šçš„æ“ä½œï¼Œåªèƒ½ç”¨äºæŒ‡é’ˆå‹å˜é‡ï¼Œå‡½æ•°è¿”å›å€¼å’Œå‡½æ•°å‚æ•°ã€‚ æŒ‡é’ˆç±»å‹ æŒ‡é’ˆï¼Œç”¨æ¥æè¿°å†…å­˜åœ°å€ï¼Œå¹¶é€šè¿‡æä¾›æŒ‡é’ˆæ“ä½œæ¥å®ç°ä¸å†…å­˜ç›¸å…³çš„ç¨‹åºåŠŸèƒ½ã€‚&lt;ç±»å‹&gt;* &lt;æŒ‡é’ˆå˜é‡&gt;; å…¶ä¸­&lt;ç±»å‹&gt;å†³å®šäº†æŒ‡å‘çš„å†…å­˜ç©ºé—´çš„å¤§å°ã€‚ æŒ‡é’ˆå˜é‡ä¹Ÿæ˜¯ä¸€ç§å˜é‡ï¼Œæœ‰ç€è‡ªå·±çš„å†…å­˜ç©ºé—´ï¼Œè¯¥ç©ºé—´ä¸Šå­˜å‚¨çš„æ˜¯å¦ä¸€ä¸ªå˜é‡çš„å†…å­˜ç©ºé—´ã€‚ 2ã€è‡ªå®šä¹‰æ•°æ®ç±»å‹ æ•°ç»„ç±»å‹ æ•°ç»„ç±»å‹æ˜¯ä¸€ç§æœ‰å›ºå®šå¤šä¸ªåŒç±»å‹çš„å…ƒç´ æŒ‰ä¸€å®šæ¬¡åºæ‰€æ„æˆçš„æ•°æ®ç±»å‹ã€‚ 2.1ã€ä¸€ç»´æ•°ç»„ç±»å‹ int dp[5] 2.2ã€äºŒç»´æ•°ç»„ç±»å‹ int dp[2] [3] ç»“æ„ä½“æ•°æ®ç±»å‹ 1ã€ç»“æ„ä½“ ç»“æ„ä½“æ˜¯ç”±ä¸€ç³»åˆ—å…·æœ‰ç›¸åŒç±»å‹æˆ–è€…ä¸åŒç±»å‹çš„æ•°æ®æ„æˆçš„æ•°æ®é›†åˆã€‚ struct åç§°{ æ•°æ®ç±»å‹ å˜é‡å1ï¼› æ•°æ®ç±»å‹ å˜é‡å2ï¼› .... æ•°æ®ç±»å‹ å˜é‡ånï¼› }ç»“æ„ä½“å˜é‡å; ç»“æ„ä½“æ•°ç»„: struct Info{ int age; char name[32]; }info[SIZE]; æšä¸¾ç±»å‹ æšä¸¾ç±»å‹(enumeration)æ˜¯C++ä¸­çš„ä¸€ç§æ´¾ç”Ÿæ•°æ®ç±»å‹ï¼Œå®ƒæ˜¯ç”±ç”¨æˆ·å®šä¹‰çš„è‹¥å¹²æšä¸¾å¸¸é‡çš„é›†åˆã€‚å¦‚æœä¸€ä¸ªå˜é‡åªæœ‰å‡ ç§å¯èƒ½çš„å€¼ï¼Œå¯ä»¥å®šä¹‰ä¸ºæšä¸¾(enumeration)ç±»å‹ã€‚æ‰€è°“&quot;æšä¸¾&quot;æ˜¯æŒ‡å°†å˜é‡çš„å€¼ä¸€ä¸€åˆ—ä¸¾å‡ºæ¥ï¼Œå˜é‡çš„å€¼åªèƒ½åœ¨åˆ—ä¸¾å‡ºæ¥çš„å€¼çš„èŒƒå›´å†…ã€‚ enum æšä¸¾å{ æ ‡è¯†ç¬¦[=æ•´å‹å¸¸æ•°], æ ‡è¯†ç¬¦[=æ•´å‹å¸¸æ•°], ... æ ‡è¯†ç¬¦[=æ•´å‹å¸¸æ•°] } æšä¸¾å˜é‡; å‡½æ•° å®šä¹‰å‡½æ•° åœ¨ C++ ä¸­ï¼Œå‡½æ•°ç”±ä¸€ä¸ªå‡½æ•°å¤´å’Œä¸€ä¸ªå‡½æ•°ä¸»ä½“ç»„æˆã€‚ä¸‹é¢åˆ—å‡ºä¸€ä¸ªå‡½æ•°çš„æ‰€æœ‰ç»„æˆéƒ¨åˆ†ï¼š **è¿”å›ç±»å‹ï¼š**ä¸€ä¸ªå‡½æ•°å¯ä»¥è¿”å›ä¸€ä¸ªå€¼ã€‚return_type æ˜¯å‡½æ•°è¿”å›çš„å€¼çš„æ•°æ®ç±»å‹ã€‚æœ‰äº›å‡½æ•°æ‰§è¡Œæ‰€éœ€çš„æ“ä½œè€Œä¸è¿”å›å€¼ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œreturn_type æ˜¯å…³é”®å­— voidã€‚ **å‡½æ•°åç§°ï¼š**è¿™æ˜¯å‡½æ•°çš„å®é™…åç§°ã€‚å‡½æ•°åå’Œå‚æ•°åˆ—è¡¨ä¸€èµ·æ„æˆäº†å‡½æ•°ç­¾åã€‚ **å‚æ•°ï¼š**å‚æ•°å°±åƒæ˜¯å ä½ç¬¦ã€‚å½“å‡½æ•°è¢«è°ƒç”¨æ—¶ï¼Œæ‚¨å‘å‚æ•°ä¼ é€’ä¸€ä¸ªå€¼ï¼Œè¿™ä¸ªå€¼è¢«ç§°ä¸ºå®é™…å‚æ•°ã€‚å‚æ•°åˆ—è¡¨åŒ…æ‹¬å‡½æ•°å‚æ•°çš„ç±»å‹ã€é¡ºåºã€æ•°é‡ã€‚å‚æ•°æ˜¯å¯é€‰çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå‡½æ•°å¯èƒ½ä¸åŒ…å«å‚æ•°ã€‚ **å‡½æ•°ä¸»ä½“ï¼š**å‡½æ•°ä¸»ä½“åŒ…å«ä¸€ç»„å®šä¹‰å‡½æ•°æ‰§è¡Œä»»åŠ¡çš„è¯­å¥ã€‚ ä¸€ä¸ªå‡½æ•°å°±æ˜¯ä¸€ä¸ªåŠŸèƒ½ï¼Œä¸€èˆ¬æŠŠä¸€ä¸ªå¤§å‹ç¨‹åºåˆ’åˆ†ä¸ºè‹¥å¹²ä¸ªç¨‹åºæ¨¡å—ã€‚æ— è®ºæŠŠå‡½æ•°åˆ†ä¸ºå¤šå°‘ä¸ªç¨‹åºæ¨¡å—ï¼Œå…¶ä¸­åªèƒ½æœ‰ä¸€ä¸ªmainå‡½æ•°ï¼Œç¨‹åºæ€»æ˜¯ä»mainå‡½æ•°å¼€å§‹æ‰§è¡Œçš„ã€‚c++ç»§æ‰¿äº†cè¯­è¨€ä¸­é¢å‘å‡½æ•°çš„è¯­è¨€ç‰¹æ€§ï¼Œåœ¨å…¶ä¹‹ä¸ŠåˆåŠ å…¥äº†é¢å‘å¯¹è±¡çš„å‡½æ•°è®¾è®¡æ€æƒ³ã€‚å­¦ä¼šè®¾è®¡å¹¶ä½¿ç”¨å‡½æ•°ã€‚ ä¸»å‡½æ•°å†™çš„å¾ˆç®€å•ï¼Œå®ƒçš„ä½œç”¨å°±æ˜¯è°ƒç”¨å„ä¸ªå­å‡½æ•°ï¼Œç¨‹åºçš„å„éƒ¨åˆ†åŠŸèƒ½æ˜¯ç”±å„ä¸ªå­å‡½æ•°ç»„åˆå®ç°çš„ï¼Œä¸»å‡½æ•°ç›¸å½“äºæ€»è°ƒåº¦ã€‚ å‡½æ•°åˆ†ç±» ï¼ˆ1ï¼‰ç³»ç»Ÿå‡½æ•°ï¼Œå³åº“å‡½æ•° ç”±ç¼–è¯‘ç³»ç»Ÿæä¾›çš„å‡½æ•°ï¼Œå¯ä»¥ç›´æ¥é€šè¿‡å¤´æ–‡ä»¶è°ƒç”¨ï¼›è¿™å°±æ˜¯ä¸ºä»€ä¹ˆåœ¨è°ƒç”¨å‡½æ•°æ—¶å¿…é¡»åœ¨ç¨‹åºæœ€å‰é¢æ·»åŠ #include&lt;&gt;çš„åŸå› ã€‚ ï¼ˆ2ï¼‰ç”¨æˆ·è‡ªå®šä¹‰çš„å‡½æ•° ï¼ˆ1æ— å‚å‡½æ•° è°ƒç”¨æ—¶ä¸å¿…ç»™å‡ºå‚æ•° ï¼ˆ2æœ‰å‚å‡½æ•° åœ¨è°ƒç”¨å‡½æ•°æ—¶è¦ç»™å‡ºå¿…è¦çš„å‚æ•°ã€‚ ç±»å‹å å‡½æ•°åï¼ˆå½¢å¼å‚æ•°åˆ—è¡¨ï¼‰ { **å£°æ˜éƒ¨åˆ†;** **æ‰§è¡Œè¯­å¥;** } å‡½æ•°å‚æ•° å¦‚æœå‡½æ•°è¦ä½¿ç”¨å‚æ•°ï¼Œåˆ™å¿…é¡»å£°æ˜æ¥å—å‚æ•°å€¼çš„å˜é‡ã€‚è¿™äº›å˜é‡ç§°ä¸ºå‡½æ•°çš„å½¢å¼å‚æ•°ã€‚åœ¨å®šä¹‰å‡½æ•°æ—¶ï¼Œå‡½æ•°ååé¢æ‹¬å·ä¸­çš„å˜é‡åç§°ä¸ºå½¢å¼å‚æ•°ï¼›åœ¨ä¸»å‡½æ•°ä¸­è°ƒç”¨å‡½æ•°æ—¶ï¼Œå‡½æ•°ååé¢æ‹¬å·ä¸­çš„å‚æ•°ä¸ºå®é™…å‚æ•°ã€‚ å½¢å¼å‚æ•°å°±åƒå‡½æ•°å†…çš„å…¶ä»–å±€éƒ¨å˜é‡ï¼Œåœ¨è¿›å…¥å‡½æ•°æ—¶è¢«åˆ›å»ºï¼Œé€€å‡ºå‡½æ•°æ—¶è¢«é”€æ¯ã€‚ è°ƒç”¨ç±»å‹ æè¿° ä¼ å€¼è°ƒç”¨ è¯¥æ–¹æ³•æŠŠå‚æ•°çš„å®é™…å€¼èµ‹å€¼ç»™å‡½æ•°çš„å½¢å¼å‚æ•°ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä¿®æ”¹å‡½æ•°å†…çš„å½¢å¼å‚æ•°å¯¹å®é™…å‚æ•°æ²¡æœ‰å½±å“ã€‚ æŒ‡é’ˆè°ƒç”¨ è¯¥æ–¹æ³•æŠŠå‚æ•°çš„åœ°å€èµ‹å€¼ç»™å½¢å¼å‚æ•°ã€‚åœ¨å‡½æ•°å†…ï¼Œè¯¥åœ°å€ç”¨äºè®¿é—®è°ƒç”¨ä¸­è¦ç”¨åˆ°çš„å®é™…å‚æ•°ã€‚è¿™æ„å‘³ç€ï¼Œä¿®æ”¹å½¢å¼å‚æ•°ä¼šå½±å“å®é™…å‚æ•°ã€‚ å¼•ç”¨è°ƒç”¨ è¯¥æ–¹æ³•æŠŠå‚æ•°çš„å¼•ç”¨èµ‹å€¼ç»™å½¢å¼å‚æ•°ã€‚åœ¨å‡½æ•°å†…ï¼Œè¯¥å¼•ç”¨ç”¨äºè®¿é—®è°ƒç”¨ä¸­è¦ç”¨åˆ°çš„å®é™…å‚æ•°ã€‚è¿™æ„å‘³ç€ï¼Œä¿®æ”¹å½¢å¼å‚æ•°ä¼šå½±å“å®é™…å‚æ•° å‡½æ•°è¿”å›å€¼ é€šè¿‡å‡½æ•°çš„è°ƒç”¨ä½¿å¾—ä¸»å‡½æ•°å¾—åˆ°ä¸€ä¸ªç¡®å®šçš„å‡½æ•°å€¼ï¼Œè¿™å°±æ˜¯å‡½æ•°çš„è¿”å›å€¼ã€‚ è°ƒç”¨å‡½æ•°ä¸é€’å½’è°ƒç”¨ åˆ›å»º C++ å‡½æ•°æ—¶ï¼Œä¼šå®šä¹‰å‡½æ•°åšä»€ä¹ˆï¼Œç„¶åé€šè¿‡è°ƒç”¨å‡½æ•°æ¥å®Œæˆå·²å®šä¹‰çš„ä»»åŠ¡ã€‚ å½“ç¨‹åºè°ƒç”¨å‡½æ•°æ—¶ï¼Œç¨‹åºæ§åˆ¶æƒä¼šè½¬ç§»ç»™è¢«è°ƒç”¨çš„å‡½æ•°ã€‚è¢«è°ƒç”¨çš„å‡½æ•°æ‰§è¡Œå·²å®šä¹‰çš„ä»»åŠ¡ï¼Œå½“å‡½æ•°çš„è¿”å›è¯­å¥è¢«æ‰§è¡Œæ—¶ï¼Œæˆ–åˆ°è¾¾å‡½æ•°çš„ç»“æŸæ‹¬å·æ—¶ï¼Œä¼šæŠŠç¨‹åºæ§åˆ¶æƒäº¤è¿˜ç»™ä¸»ç¨‹åºã€‚ åœ¨è°ƒç”¨ä¸€ä¸ªå‡½æ•°è¿‡ç¨‹ä¸­åˆå‡ºç°ç›´æ¥æˆ–è€…é—´æ¥è°ƒç”¨å‡½æ•°æœ¬èº«ï¼Œç§°ä¸ºå‡½æ•°é€’å½’è°ƒç”¨ã€‚ æŒ‡é’ˆå‚æ•°è°ƒç”¨ è¦æƒ³æ”¹å˜ä¸»è°ƒå‡½æ•°ä¸­çš„å€¼ï¼Œå¿…é¡»ä¼ å…¥å‡½æ•°çš„åœ°å€ï¼Œè€Œä¸”å¿…é¡»é€šè¿‡*+åœ°å€å»èµ‹å€¼ï¼Œæ— è®ºåœ¨è¿™ä¸ªå˜é‡æ—¶ä»€ä¹ˆç±»å‹çš„ã€‚ void f(int *p){ //è¢«è°ƒç”¨çš„æ—¶å€™å¾—åˆ°äº†æŸä¸ªå˜é‡çš„åœ°å€ } int main(){ int i = 0; f(&amp;i); //ä¼ é€’åœ°å€ç±»å‹çš„å‚æ•° } åœ¨å‡½æ•°é‡Œé¢å¯ä»¥é€šè¿‡è¿™ä¸ªæŒ‡é’ˆè®¿é—®å¤–é¢è¿™ä¸ªi æ³¨ï¼šåœ¨ä¼ é€’æ•°ç»„é•¿åº¦sizeofæ—¶ï¼Œå¿…é¡»åœ¨mainå‡½æ•°ä¸­ä¼ é€’ã€‚å¦‚æœåˆ©ç”¨æŒ‡é’ˆä¼ é€’å‚æ•°ï¼Œé‚£ä¹ˆå­å‡½æ•°ä¸­è¿”å›çš„sizeofè¿”å›çš„æ˜¯int*açš„é•¿åº¦è€Œä¸æ˜¯int a[ ]çš„é•¿åº¦ï¼› int *aæ˜¯é¦–åœ°å€å³ a[0]çš„sizeofã€‚ Lambda å‡½æ•°ä¸è¡¨è¾¾å¼ C++11 æä¾›äº†å¯¹åŒ¿åå‡½æ•°çš„æ”¯æŒ,ç§°ä¸º Lambda å‡½æ•°(ä¹Ÿå« Lambda è¡¨è¾¾å¼)ã€‚ Lambda è¡¨è¾¾å¼æŠŠå‡½æ•°çœ‹ä½œå¯¹è±¡ã€‚Lambda è¡¨è¾¾å¼å¯ä»¥åƒå¯¹è±¡ä¸€æ ·ä½¿ç”¨ï¼Œæ¯”å¦‚å¯ä»¥å°†å®ƒä»¬èµ‹ç»™å˜é‡å’Œä½œä¸ºå‚æ•°ä¼ é€’ï¼Œè¿˜å¯ä»¥åƒå‡½æ•°ä¸€æ ·å¯¹å…¶æ±‚å€¼ã€‚ C++ æ•°å­¦è¿ç®— åœ¨ C++ ä¸­ï¼Œé™¤äº†å¯ä»¥åˆ›å»ºå„ç§å‡½æ•°ï¼Œè¿˜åŒ…å«äº†å„ç§æœ‰ç”¨çš„å‡½æ•°ä¾›æ‚¨ä½¿ç”¨ã€‚è¿™äº›å‡½æ•°å†™åœ¨æ ‡å‡† C å’Œ C++ åº“ä¸­ï¼Œå«åšå†…ç½®å‡½æ•°ã€‚æ‚¨å¯ä»¥åœ¨ç¨‹åºä¸­å¼•ç”¨è¿™äº›å‡½æ•°ã€‚ C++ å†…ç½®äº†ä¸°å¯Œçš„æ•°å­¦å‡½æ•°ï¼Œå¯å¯¹å„ç§æ•°å­—è¿›è¡Œè¿ç®—ã€‚ä¸‹è¡¨åˆ—å‡ºäº† C++ ä¸­ä¸€äº›æœ‰ç”¨çš„å†…ç½®çš„æ•°å­¦å‡½æ•°ã€‚ ä¸ºäº†åˆ©ç”¨è¿™äº›å‡½æ•°ï¼Œæ‚¨éœ€è¦å¼•ç”¨æ•°å­¦å¤´æ–‡ä»¶ ã€‚ åºå· å‡½æ•° &amp; æè¿° 1 double cos(double); è¯¥å‡½æ•°è¿”å›å¼§åº¦è§’ï¼ˆdouble å‹ï¼‰çš„ä½™å¼¦ã€‚ 2 double sin(double); è¯¥å‡½æ•°è¿”å›å¼§åº¦è§’ï¼ˆdouble å‹ï¼‰çš„æ­£å¼¦ã€‚ 3 double tan(double); è¯¥å‡½æ•°è¿”å›å¼§åº¦è§’ï¼ˆdouble å‹ï¼‰çš„æ­£åˆ‡ã€‚ 4 double log(double); è¯¥å‡½æ•°è¿”å›å‚æ•°çš„è‡ªç„¶å¯¹æ•°ã€‚ 5 double pow(double, double); å‡è®¾ç¬¬ä¸€ä¸ªå‚æ•°ä¸º xï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸º yï¼Œåˆ™è¯¥å‡½æ•°è¿”å› x çš„ y æ¬¡æ–¹ã€‚ 6 double hypot(double, double); è¯¥å‡½æ•°è¿”å›ä¸¤ä¸ªå‚æ•°çš„å¹³æ–¹æ€»å’Œçš„å¹³æ–¹æ ¹ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå‚æ•°ä¸ºä¸€ä¸ªç›´è§’ä¸‰è§’å½¢çš„ä¸¤ä¸ªç›´è§’è¾¹ï¼Œå‡½æ•°ä¼šè¿”å›æ–œè¾¹çš„é•¿åº¦ã€‚ 7 double sqrt(double); è¯¥å‡½æ•°è¿”å›å‚æ•°çš„å¹³æ–¹æ ¹ã€‚ 8 int abs(int); è¯¥å‡½æ•°è¿”å›æ•´æ•°çš„ç»å¯¹å€¼ã€‚ 9 double fabs(double); è¯¥å‡½æ•°è¿”å›ä»»æ„ä¸€ä¸ªæµ®ç‚¹æ•°çš„ç»å¯¹å€¼ã€‚ 10 double floor(double); è¯¥å‡½æ•°è¿”å›ä¸€ä¸ªå°äºæˆ–ç­‰äºä¼ å…¥å‚æ•°çš„æœ€å¤§æ•´æ•°ã€‚ C++ä¸­ç›´æ¥è°ƒç”¨çš„å‡½æ•° 1ã€sqrt(x) å–xçš„å¹³æ–¹æ ¹ã€‚ 2ã€pow(x,y) å€¼ä¸ºxçš„yæ¬¡æ–¹ã€‚ 3ã€abs(x) å–æ•´æ•°çš„ç»å¯¹å€¼ã€‚ fabs(x) æ±‚ç²¾åº¦æ›´é«˜çš„doubleã€floatå‹çš„ç»å¯¹å€¼ã€‚ 4ã€floor(x) è¿”å›ä¸€ä¸ªå°äºæˆ–ç­‰äºxçš„æœ€å¤§æ•´æ•°ã€‚ 5ã€setw(x) ç©ºxä¸ªç©ºæ ¼ã€‚ 6ã€strcpy(s1,s2) å¤åˆ¶å­—ç¬¦ä¸²s2åˆ°å­—ç¬¦ä¸²s1ã€‚ 7ã€strlen(s1) è¿”å›å­—ç¬¦ä¸²s1çš„é•¿åº¦ã€‚ 8ã€strcat(s1,s2) è¿æ¥å­—ç¬¦ä¸² s2 åˆ°å­—ç¬¦ä¸² s1 çš„æœ«å°¾ã€‚ 9ã€strchr(s1,ch) è¿”å›ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘å­—ç¬¦ä¸² s1 ä¸­å­—ç¬¦ ch çš„ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®ã€‚ 10ã€strstr(s1,s2) è¿”å›ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘å­—ç¬¦ä¸² s1 ä¸­å­—ç¬¦ä¸² s2 çš„ç¬¬ä¸€æ¬¡å‡ºç°çš„ä½ç½®ã€‚ 11ã€strcmp(s1,s2) å¦‚æœ s1 å’Œ s2 æ˜¯ç›¸åŒçš„ï¼Œåˆ™è¿”å› 0ï¼›å¦‚æœ s1&lt;s2 åˆ™è¿”å›å€¼å°äº 0ï¼›å¦‚æœ s1&gt;s2 åˆ™è¿”å›å€¼å¤§äº 0ã€‚ åŸæ–‡é“¾æ¥ï¼šhttps://blog.csdn.net/qq_55196230/article/details/122525491 å¸¸ç”¨çš„å­—ç¬¦ä¸²å‡½æ•° æŒ‡é’ˆ æŒ‡é’ˆç±»å‹å¯ä»¥æœ‰å‡½æ•°ç±»å‹ã€å¯¹è±¡ç±»å‹æˆ–è€…ä¸å®Œå…¨ç±»å‹æ´¾ç”Ÿå‡ºæ¥ï¼Œæ´¾ç”ŸæŒ‡é’ˆç±»å‹çš„ç±»å‹ç§°ä¸ºè¢«å¼•ç”¨ç±»å‹ã€‚æŒ‡é’ˆç±»å‹æè¿°äº†ä¸€ç§å¯¹è±¡ï¼Œå…¶å€¼ç”¨äºå¼•ç”¨è¢«å¼•ç”¨ç±»å‹çš„å®ä½“ã€‚ è¿™æ˜¯C11ä¸­ç»™å‡ºæŒ‡é’ˆç±»å‹çš„æ ‡å‡†å®šä¹‰ï¼Œè¯»èµ·æ¥æ‹—å£éš¾æ‡‚ï¼ é‚£ä¹ˆï¼Œæ ¹æ®ç¬¬ä¸€æ€§åŸç†ï¼Œä»ç®€å•å¤„å…¥æ‰‹â€”â€”ç±»å‹ã€‚ æåˆ°ç±»å‹ï¼Œç«‹åˆ»ä¼šè®©äººæƒ³èµ·intç±»å‹ã€douleç±»å‹ç­‰ï¼ŒåŒæ ·çš„ï¼ŒæŒ‡é’ˆä¹Ÿæ˜¯ä¸€ç§ç±»å‹ï¼Œä½†æ˜¯æŒ‡é’ˆç±»å‹å¹¶ä¸æ˜¯ç‹¬ç«‹å­˜åœ¨çš„ï¼Œè€Œæ˜¯ç”±å…¶ä»–ç±»å‹æ´¾ç”Ÿå‡ºæ¥çš„ã€‚ç”±è¢«å¼•ç”¨ç±»å‹Tæ´¾ç”Ÿå‡ºçš„æŒ‡é’ˆç±»å‹ç§°ä¸ºâ€œæŒ‡å‘Tçš„æŒ‡é’ˆâ€ã€‚æŒ‡é’ˆç±»å‹æ˜¯ç±»å‹ï¼Œæ‰€ä»¥ä¹Ÿå­˜åœ¨â€œæŒ‡é’ˆç±»å‹çš„å˜é‡â€å’Œâ€œæŒ‡é’ˆç±»å‹çš„å€¼â€ã€‚ä½†æ˜¯ç³Ÿç³•çš„äº‹ï¼Œå¤§å¤šæ•°äººå¯¹æŒ‡é’ˆç±»å‹ã€æŒ‡é’ˆç±»å‹çš„å€¼ã€æŒ‡é’ˆç±»å‹çš„å˜é‡æ··ä¸ºä¸€è°ˆï¼Œç¬¼ç»Ÿåœ°è®¤ä¸ºä»–ä»¬éƒ½æ˜¯â€œæŒ‡é’ˆâ€ï¼Œæ‰€ä»¥å¯¹äºåŸºæœ¬çš„æ¦‚å¿µç†è§£è¦æé«˜è­¦æƒ•ã€‚ ç°æœ‰çš„æŒ‡é’ˆç±»å‹ï¼Œå› ä¸ºæœ‰äº†æŒ‡é’ˆç±»å‹ï¼Œæ‰€ä»¥æ‰æœ‰æŒ‡é’ˆç±»å‹çš„å˜é‡å’ŒæŒ‡é’ˆç±»å‹çš„å€¼ã€‚ ä¾‹å¦‚åœ¨Cè¯­è¨€ä¸­ï¼Œintç±»å‹ç”¨æ¥è¡¨ç¤ºæ•´æ•°ã€‚å› ä¸ºintæ˜¯â€œç±»å‹â€ï¼Œæ‰€ä»¥å­˜åœ¨ç”¨äºä¿å­˜intç±»å‹çš„å˜é‡ï¼Œå½“ç„¶ä¹Ÿå­˜åœ¨intç±»å‹çš„å€¼ã€‚æŒ‡é’ˆç±»å‹ä¹Ÿæ˜¯å¦‚æ­¤ï¼Œæ—¢å­˜åœ¨æŒ‡é’ˆç±»å‹çš„å˜é‡ï¼Œä¹Ÿå­˜åœ¨æŒ‡é’ˆç±»å‹çš„å€¼ã€‚æŒ‡é’ˆç±»å‹çš„å€¼å®é™…ä¸Šå°±æ˜¯å†…å­˜çš„åœ°å€ã€‚ ä»€ä¹ˆæ˜¯æŒ‡é’ˆï¼Ÿ æŒ‡é’ˆæ˜¯ä¸€ä¸ªå˜é‡ï¼Œå…¶å€¼ä¸ºæŸä¸€ä¸ªå˜é‡çš„åœ°å€ï¼Œå³ï¼Œå†…å­˜ä½ç½®çš„ç›´æ¥åœ°å€ã€‚å°±åƒå…¶ä»–å˜é‡æˆ–å¸¸é‡ä¸€æ ·ï¼Œæ‚¨å¿…é¡»åœ¨ä½¿ç”¨æŒ‡é’ˆå­˜å‚¨å…¶ä»–å˜é‡åœ°å€ä¹‹å‰ï¼Œå¯¹å…¶è¿›è¡Œå£°æ˜ã€‚ type *var-name; åœ¨è¿™é‡Œï¼Œtype æ˜¯æŒ‡é’ˆçš„åŸºç±»å‹ï¼Œå®ƒå¿…é¡»æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„ C++ æ•°æ®ç±»å‹ï¼Œvar-name æ˜¯æŒ‡é’ˆå˜é‡çš„åç§°ã€‚ç”¨æ¥å£°æ˜æŒ‡é’ˆçš„æ˜Ÿå· * ä¸ä¹˜æ³•ä¸­ä½¿ç”¨çš„æ˜Ÿå·æ˜¯ç›¸åŒçš„ã€‚ä½†æ˜¯ï¼Œåœ¨è¿™ä¸ªè¯­å¥ä¸­ï¼Œæ˜Ÿå·æ˜¯ç”¨æ¥æŒ‡å®šä¸€ä¸ªå˜é‡æ˜¯æŒ‡é’ˆã€‚ä»¥ä¸‹æ˜¯æœ‰æ•ˆçš„æŒ‡é’ˆå£°æ˜ï¼š int *ip; /* ä¸€ä¸ªæ•´å‹çš„æŒ‡é’ˆ */ double *dp; /* ä¸€ä¸ª double å‹çš„æŒ‡é’ˆ */ float *fp; /* ä¸€ä¸ªæµ®ç‚¹å‹çš„æŒ‡é’ˆ */ char *ch; /* ä¸€ä¸ªå­—ç¬¦å‹çš„æŒ‡é’ˆ */ æ‰€æœ‰æŒ‡é’ˆçš„å€¼çš„å®é™…æ•°æ®ç±»å‹ï¼Œä¸ç®¡æ˜¯æ•´å‹ã€æµ®ç‚¹å‹ã€å­—ç¬¦å‹ï¼Œè¿˜æ˜¯å…¶ä»–çš„æ•°æ®ç±»å‹ï¼Œéƒ½æ˜¯ä¸€æ ·çš„ï¼Œéƒ½æ˜¯ä¸€ä¸ªä»£è¡¨å†…å­˜åœ°å€çš„é•¿çš„åå…­è¿›åˆ¶æ•°ã€‚ä¸åŒæ•°æ®ç±»å‹çš„æŒ‡é’ˆä¹‹é—´å”¯ä¸€çš„ä¸åŒæ˜¯ï¼ŒæŒ‡é’ˆæ‰€æŒ‡å‘çš„å˜é‡æˆ–å¸¸é‡çš„æ•°æ®ç±»å‹ä¸åŒã€‚ &amp;ä¸*åŒºåˆ«ä½¿ç”¨æ–¹å¼ï¼š* pæ˜¯ä¸€ä¸ªå€¼ï¼›pæ˜¯ä¸€ä¸ªåœ°å€ï¼›ä¸¤è€…å®Œå…¨ä¸ç›¸åŒã€‚ä»£è¡¨ç€pæŒ‡å‘çš„åœ°å€çš„å€¼ï¼Œç®€å•æ¥è¯´å°±æ˜¯å–å€¼ï¼›&amp;æ˜¯å–åœ°å€ç¬¦å·ï¼Œå–çš„æ˜¯åœ°å€ï¼›pæ˜¯æŒ‡é’ˆï¼Œå¯ä»¥ç†è§£ä¸ºæ‰€æŒ‡å‘çš„å€¼çš„åœ°å€ï¼Œ* på°±æ˜¯å–pæŒ‡é’ˆæŒ‡å‘çš„åœ°å€çš„å€¼ï¼Œ&amp;aå°±æ˜¯å–açš„åœ°å€ã€‚ &amp;æ˜¯å–åœ°å€ç¬¦å·ï¼Œå…¶è¿”å›çš„æ˜¯ä¸€ä¸ªå˜é‡çš„åœ°å€ï¼›è€Œ*æ˜¯ä¸€ä¸ªå•ç›®è¿ç®—ç¬¦ï¼Œç”¨æ¥è®¿é—®æŒ‡é’ˆçš„å€¼æ‰€è¡¨ç¤ºçš„åœ°å€ä¸Šçš„å˜é‡ï¼Œå…¶è¿”å›çš„æ˜¯æ ¹æ®åœ°å€æ‰€å¯¹åº”çš„æ•°å€¼ï¼›æˆ‘ä»¬ä¹Ÿä¿—ç§°å«åšâ€œè§£å¼•ç”¨â€ï¼Œå¯ä»¥ä½œä¸ºå·¦å€¼ä½¿ç”¨ã€‚ æŒ‡é’ˆçš„è¿ç®—ç¬¦&amp;ä¸*èµ·åˆ°äº’ä½œç”¨ï¼š int xptr = &amp;xï¼› *xptr = xï¼› *&amp;xptr -&gt; *(&amp;xptr) -&gt; *(xptrçš„åœ°å€) -&gt; å¾—åˆ°é‚£ä¸ªåœ°å€ä¸Šçš„å˜é‡ -&gt; xptr &amp;*xptr -&gt; &amp;( *xptr) -&gt; &amp;(x) -&gt; å¾—åˆ°xçš„åœ°å€ï¼Œä¹Ÿå°±æ˜¯xptr -&gt; xptr [ç™¾åº¦ç™¾ç§‘]å•ç›®è¿ç®—æ˜¯æŒ‡è¿ç®—ç¬¦åŒ…æ‹¬ç®—æœ¯è¿ç®—ç¬¦ã€é€»è¾‘è¿ç®—ç¬¦ã€ä½é€»è¾‘è¿ç®—ç¬¦ã€ä½ç§»è¿ç®—ç¬¦ã€å…³ç³»è¿ç®—ç¬¦ã€è‡ªå¢è‡ªå‡è¿ç®—ç¬¦ã€‚-&gt;åªéœ€è¦ä¸€ä¸ªå˜é‡å‚ä¸å³å¯å®Œæˆç›¸åº”çš„è®¡ç®—è¿‡ç¨‹ã€‚ [ç¿æº]å·¦å€¼ä¹‹æ‰€ä»¥å«å·¦å€¼ï¼Œæ˜¯å› ä¸ºå‡ºç°åœ¨èµ‹å€¼å·å·¦è¾¹çš„ä¸æ˜¯ä¸€ä¸ªå˜é‡è€Œæ˜¯ä¸€ä¸ªå€¼(æˆ–è€…æ˜¯è¡¨è¾¾å¼çš„ç»“æœ)ï¼Œæ˜¯ä¸€ä¸ªç‰¹æ®Šçš„å€¼ï¼Œæ‰€ä»¥å«å·¦å€¼ã€‚a[0] = 2ã€*p = 3. int a = 5;//å˜é‡çš„å£°æ˜ä¸å®šä¹‰ int *p = a;//æŒ‡é’ˆå˜é‡çš„å£°æ˜ä¸å®šä¹‰ 32ä½æ¶æ„ä¹‹ä¸‹scanf(&quot;%d&quot;,i)ï¼›ä¸ä¼šæŠ¥é”™-&gt;å› ä¸ºæ•´æ•°å’Œåœ°å€æ˜¯ä¸€æ ·å¤§çš„ å¯¹äºè¿™ä¸ª*è€Œè¨€ï¼Œå®ƒå¯ä»¥é è¿‘å˜é‡æœ¬èº«ä¹Ÿå¯ä»¥é è¿‘å…³é”®å­—ï¼Œæœ¬èº«æ²¡æœ‰å®é™…çš„åŒºåˆ« -&gt;å˜é‡çš„å€¼æ˜¯å†…å­˜çš„åœ°å€ï¼›æ™®é€šå˜é‡çš„å€¼æ˜¯å®é™…çš„å€¼ï¼›æŒ‡é’ˆå˜é‡çš„å€¼æ˜¯å…·æœ‰å®é™…å€¼çš„å˜é‡çš„åœ°å€ã€‚ åœ¨å½“ä½¿ç”¨*+å˜é‡åä½œä¸ºå‚æ•°æ˜¯ï¼Œå…¶å®šä¹‰çš„ç±»å‹ä¸ºæŒ‡é’ˆç±»å‹ï¼Œæ‰€ä»¥åœ¨ä¼ å…¥å‚æ•°æ—¶ï¼ŒåŠ¡å¿…ä¼ å…¥å˜é‡çš„åœ°å€ï¼Œè€Œä¸æ˜¯å•çº¯çš„ä¼ å…¥ä¸€ä¸ªå˜é‡åã€‚åªæœ‰ä¸»è°ƒå‡½æ•°å‚æ•°ä¼ å…¥åœ°å€ï¼Œè¢«è°ƒå‡½æ•°æ‰èƒ½æ ¹æ®å®šä¹‰çš„æŒ‡é’ˆç±»å‹å‚æ•°å»å¤ç”¨åœ°å€ï¼Œä»è€Œè¾¾åˆ°äº†æ”¹å˜ä¸»è°ƒå‡½æ•°ä¸­çš„å€¼çš„æ“ä½œã€‚ void swap(int *a,int *b){ int temp = *a; *a = *b; *b = temp; } ä»¥ä¸Šé¢çš„äº¤æ¢å‡½æ•°ä¸ºä¾‹ï¼Œè°ƒç”¨swapå‡½æ•°æ—¶ï¼Œå¿…é¡»ä¼ å…¥çš„æ˜¯ä¸¤ä¸ªåœ°å€(&amp;+å˜é‡å)ï¼›è¿™æ˜¯ä¸»è°ƒå‡½æ•°int *a,int *bæ‰èƒ½æ ¹æ®ä¼ å…¥çš„åœ°å€å»è§£æåœ°å€æ‰€å¯¹åº”çš„æ•°å€¼ã€‚åœ¨å†…å­˜ä¸­(æ— è®ºæ˜¯åœ¨å †ç©ºé—´è¿˜æ˜¯æ ˆç©ºé—´)å­˜æ”¾å¥½çš„å˜é‡æ˜¯ä¸æ€•è¢«è¦†ç›–çš„ï¼Œæ¢è¨€ä¹‹ï¼Œä»–ä»¬æ˜¯éšæ—¶åšå¥½å‡†å¤‡è€Œå»è¢«è¦†ç›–çš„ã€‚ è¿™ä¹Ÿæ˜¯å€¼ä¼ é€’å’Œåœ°å€ä¼ é€’çš„åŒºåˆ«ã€‚ä¸»è°ƒå‡½æ•°å‘ç”Ÿå€¼ä¼ é€’åï¼Œä¼ å…¥çš„å‚æ•°ä¼šåœ¨è¢«è°ƒå‡½æ•°ä¸­çš„æ ˆåŒºä¸­è‡ªå·±å¼€è¾Ÿæ–°çš„ç©ºé—´å­˜æ”¾ä¼ è¿›æ¥çš„å‚æ•°å€¼ã€‚è¿™ä¹Ÿæ˜¯æ‰€è°“çš„Cè¯­è¨€çš„ç‰¹æ€§ä¹‹ä¸€ï¼šå•å‘å€¼ä¼ é€’ã€‚è€Œä¸»è°ƒå‡½æ•°ä¼ å…¥åœ°å€åï¼Œè¢«è°ƒå‡½æ•°æ‹¿åˆ°ä¼ å…¥çš„åœ°å€å³è§£æï¼Œåˆ°å †åŒºä¸»è°ƒå‡½æ•°ä¸­(è¿™é‡Œè¯´çš„ä¸ä¸¥è°¨ï¼Œå› ä¸ºå½“ä¸»è°ƒå‡½æ•°ä¸è¢«è°ƒå‡½æ•°éƒ½å®šä¹‰åœ¨æ ˆåŒºæ—¶ï¼Œå‚æ•°çš„ä¼ é€’ä¹Ÿåªåœ¨æ ˆåŒºä¸­ä¼ é€’)å»æ”¹å˜ä¸»è°ƒå‡½æ•°ä¸­å‚æ•°çš„å€¼ã€‚ç†è§£å †åŒºå’Œæ ˆåŒºæ˜¯å‚æ•°ä¼ é€’è¿‡ç¨‹çš„ä¸­çš„é‡ç‚¹é—®é¢˜ã€‚ åº”ç”¨åœºæ™¯ï¼š å‡½æ•°è¿”å›å¤šä¸ªå€¼çš„æ—¶å€™ï¼šswapäº¤æ¢å‡½æ•°ã€å¯»æ‰¾minä¸maxå‡½æ•° and so onâ€¦ å‡½æ•°è¿”å›è¿ç®—çš„çŠ¶æ€å¯èƒ½ä¼šç”¨åˆ°æŒ‡é’ˆè¿›è¡Œè¿”å›ã€‚è®©å‡½æ•°è¿”å›æŸäº›ç‰¹æ®Šçš„ä¸å±äºæœ‰æ•ˆèŒƒå›´å†…çš„å€¼è¡¨ç¤ºå‡ºé”™ã€‚ int divide(int a,int b,int *res){ int ret = 1; if(b == 0) ret = 0; else{ *result = a/b; } return ret; } int main(){ int a = 2; int b = 10; int c; if(divide(a,b,&amp;c)){ printf(&quot;%d%d%d&quot;,a,b,c); } } åˆå­¦è€…ä½¿ç”¨æŒ‡é’ˆçš„å¸¸è§é”™è¯¯ï¼š å®šä¹‰äº†æŒ‡é’ˆå˜é‡ï¼Œä½†æ˜¯è¿˜æ²¡æœ‰å¼€å§‹æŒ‡å‘ä»»ä½•å˜é‡ï¼Œå°±å¼€å§‹ä½¿ç”¨æŒ‡é’ˆã€‚-&gt;é‡æŒ‡é’ˆçš„äº§ç”Ÿ C99æ ‡å‡†ä¸‹constä¸æŒ‡é’ˆï¼š -&gt;æŒ‡é’ˆçš„constè¡¨ç¤ºä¸€æ—¦å¾—åˆ°äº†æŸä¸ªå˜é‡çš„åœ°å€ï¼Œä¸èƒ½åœ¨æŒ‡å‘å…¶ä»–çš„å˜é‡ã€‚æŒ‡é’ˆä¸èƒ½è¢«ä¿®æ”¹ int *const q = &amp;i;//qæ˜¯const *q = 26;//OK q++ï¼›//ERROR -&gt;constæ‰€æŒ‡çš„intè¡¨ç¤ºä¸èƒ½é€šè¿‡æœ‰è¿™ä¸ªæŒ‡é’ˆå»ä¿®æ”¹æ‰€æŒ‡å‘çš„å˜é‡ã€‚æ‰€æŒ‡çš„ä¸œè¥¿ä¸èƒ½è¢«ä¿®æ”¹ const int *p = &amp;i; *p = 26;//ERROR i = 26;//OK p = &amp;j;//OK æ•°ç»„æŒ‡é’ˆ æ•°ç»„å‚æ•°çš„ç­‰ä»·ï¼š int sum(int *a,int n); int sum(int *,int n); int sum(int a[ ],int n); int sum(int [ ],int n); æ•°ç»„ä¸æŒ‡é’ˆå‡ ç‚¹ç‰¹æ€§ï¼š æ•°ç»„å˜é‡æ˜¯ç‰¹æ®Šçš„æŒ‡é’ˆï¼Œæ•°ç»„æœ¬èº«å°±æ˜¯è¡¨è¾¾åœ°å€ã€‚ []å¯ä»¥å¯¹æ•°ç»„åšï¼Œä¹Ÿå¯ä»¥å¯¹æŒ‡é’ˆåšã€‚ *å¯ä»¥å¯¹æ•°ç»„åšï¼Œä¹Ÿå¯ä»¥å¯¹æŒ‡é’ˆåšã€‚ æ•°ç»„å˜é‡æ˜¯constæŒ‡é’ˆï¼Œæ‰€ä»¥ä¸èƒ½è¢«èµ‹å€¼ã€‚ å…¶å®æ•°ç»„åœ¨ä¼ å…¥åˆ°å­å‡½æ•°æ—¶ï¼Œæœ¬è´¨ä¸Šå°±æ˜¯ä¼ å…¥å­å‡½æ•°çš„é¦–åœ°å€ã€‚ æŒ‡é’ˆå‡½æ•°å‚æ•°ï¼Œå…·å¤‡è¾“å…¥è¾“å‡ºç‰¹æ€§ï¼š mainå‡½æ•°ï¼š int main(){ test01(); test02(); test03(); return 0; } è¾“å…¥ç‰¹æ€§ï¼šä¸»è°ƒå‡½æ•°åˆ†é…å†…å­˜ï¼Œè¢«è°ƒå‡½æ•°ä¸­ä½¿ç”¨å†…å­˜ //æ ˆåŒºå†…å­˜åˆ†é… void func(char *c){ strcpy(c,&quot;helloworld!&quot;); } void test02(){ char buf[100] = {0}; func(buf); printf(&quot;%s\\n&quot;,buf); } //å †åŒºå†…å­˜åˆ†é… void PrintString(char *str){ printf(&quot;%s\\n&quot;,str); } void test01(){ //å †åŒºå†…å­˜åˆ†é… char *p = malloc(sizeof(char)*64); memset(p,0,64); strcpy(p,&quot;helloworld!&quot;); PrintString(p); } è¾“å‡ºç‰¹æ€§ï¼šè¢«è°ƒå‡½æ•°åˆ†é…å†…å­˜ï¼Œä¸»è°ƒå‡½æ•°ä¸­ä½¿ç”¨å†…å­˜ //è¾“å‡ºç‰¹æ€§ï¼šè¢«è°ƒå‡½æ•°åˆ›å»ºå†…å­˜ï¼Œä¸»è°ƒå‡½æ•°ä½¿ç”¨å†…å­˜ void allocateSpace(char **pp){ char *temp = malloc(sizeof(char)*64); memset(temp,0,64); strcpy(temp,&quot;helloworld!&quot;); *pp = temp; } void test03(){ char *p = NULL; allocateSpace(&amp;p); printf(&quot;%s\\n&quot;,p); } æ•°ç»„æŒ‡é’ˆä¸æŒ‡é’ˆæ•°ç»„ æ•°ç»„æŒ‡é’ˆï¼šæ˜¯æŒ‡ä¸€ä¸ªæŒ‡å‘æ•°ç»„çš„æŒ‡é’ˆï¼Œå®ƒå…¶å®è¿˜æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œåªä¸è¿‡æ˜¯æŒ‡å‘æ•°ç»„è€Œå·² int (*p)[10] æŒ‡é’ˆæ•°ç»„ï¼šæ˜¯æŒ‡ä¸€ä¸ªæ•°ç»„é‡Œé¢è£…ç€æŒ‡é’ˆï¼Œä¹Ÿå³æŒ‡é’ˆæ•°ç»„æ˜¯ä¸€ä¸ªæ•°ç»„ int *a[10] æŒ‡é’ˆæ•°ç»„çš„ä½¿ç”¨ï¼š #include &lt;stdio.h&gt; int main(){ int a = 16, b = 932, c = 100; //å®šä¹‰ä¸€ä¸ªæŒ‡é’ˆæ•°ç»„ int *arr[3] = {&amp;a, &amp;b, &amp;c};//ä¹Ÿå¯ä»¥ä¸æŒ‡å®šé•¿åº¦ï¼Œç›´æ¥å†™ä½œ int *arr[] //parr æ˜¯æŒ‡å‘æ•°ç»„ arr çš„æŒ‡é’ˆï¼Œç¡®åˆ‡åœ°è¯´æ˜¯æŒ‡å‘ arr ç¬¬ 0 ä¸ªå…ƒç´ çš„æŒ‡é’ˆï¼Œ //å®ƒçš„å®šä¹‰å½¢å¼åº”è¯¥ç†è§£ä¸ºint *(*parr)ï¼Œæ‹¬å·ä¸­çš„*è¡¨ç¤º parr æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œæ‹¬å·å¤–é¢çš„int *è¡¨ç¤º parr æŒ‡å‘çš„æ•°æ®çš„ç±»å‹ã€‚ //arr ç¬¬ 0 ä¸ªå…ƒç´ çš„ç±»å‹ä¸º int *ï¼Œæ‰€ä»¥åœ¨å®šä¹‰ parr æ—¶è¦åŠ ä¸¤ä¸ª *ã€‚ int **parr = arr; printf(&quot;%d, %d, %d\\n&quot;, *arr[0], *arr[1], *arr[2]);//16, 932, 100 printf(&quot;%d, %d, %d\\n&quot;, **(parr+0), **(parr+1), **(parr+2));//16, 932, 100 return 0; } #include &lt;stdio.h&gt; int main(){ char *str[3] = { &quot;c.biancheng.net&quot;, &quot;Cè¯­è¨€ä¸­æ–‡ç½‘&quot;, &quot;C Language&quot; }; printf(&quot;%s\\n%s\\n%s\\n&quot;, str[0], str[1], str[2]); /* è¿è¡Œç»“æœï¼š c.biancheng.net Cè¯­è¨€ä¸­æ–‡ç½‘ C Language */ return 0; } æ•°ç»„æŒ‡é’ˆçš„ä½¿ç”¨ï¼š #include&lt;stdio.h&gt; int main(void) { char a[5]={'A','K','C','G','L'}; char (*p)[5]=&amp;a;//&amp;aä»£è¡¨çš„æ˜¯æ•´ä¸ªæ•°ç»„çš„é¦–åœ°å€ //char (*p)[5]=a;è¿™æ ·æ˜¯é”™è¯¯çš„ï¼Œå› ä¸ºaä»£è¡¨ç¬¬ä¸€ä¸ªå…ƒç´ çš„é¦–åœ°å€ printf(&quot;%c %c %c&quot;,**p,*(*p+1),*(*p+3));//è¾“å‡ºï¼šA K G return 0; } ç»“æ„ä½“æŒ‡é’ˆ **-&gt;**å‰æ˜¯æŒ‡é’ˆï¼Œè€Œ . å‰æ˜¯ç»“æ„ä½“å˜é‡ .ç”¨äºç±»çš„å®ä¾‹ï¼Œè€Œ-&gt;ç”¨äºç±»çš„æŒ‡é’ˆ .ï¼šæˆå‘˜è®¿é—®è¡¨è¾¾å¼æŒ‡å®šç”±å…¶å·¦æ“ä½œæ•°æŒ‡å®šçš„ç»“æ„æˆ–è”åˆçš„å‘½åæˆå‘˜ï¼Œå®ƒå…·æœ‰ä¸å·¦æ“ä½œæ•°ç›¸åŒçš„å€¼ç±»åˆ«ã€‚ -&gt;ï¼šé€šè¿‡æŒ‡é’ˆè¡¨è¾¾å¼çš„æˆå‘˜è®¿é—®æŒ‡å®šç”±å…¶å·¦æ“ä½œæ•°æŒ‡å‘çš„ç»“æ„æˆ–è”åˆç±»å‹çš„å‘½åæˆå‘˜ã€‚å®ƒçš„å€¼lç±»åˆ«å§‹ç»ˆæ˜¯å·¦å€¼ã€‚ ç®€å•ç‚¹è¯´å°±æ˜¯ï¼š A-&gt;aè¡¨ç¤ºAæ˜¯æŒ‡å‘ç»“æ„ä½“çš„æŒ‡é’ˆ A.aè¡¨ç¤ºAæ˜¯ç»“æ„ä½“ A-&gt;aç­‰æ•ˆäº(*A).a -&gt;æ¯”å¦‚C++ä¸­ä¸€ä¸ªç±»Class Student;é‡Œé¢æœ‰ä¸ªå…¬æœ‰æˆå‘˜å˜é‡test å¦‚æœä½ å£°æ˜è¿™ä¸ªç±»çš„å¯¹è±¡Student s;é‚£ä¹ˆä½ è¦å¯¹testæ“ä½œè¦ç”¨&quot;.&quot; s.test å¦‚æœä½ å£°æ˜è¿™ä¸ªç±»çš„å¯¹è±¡Student *sä¸ºæŒ‡é’ˆç±»å‹çš„è¯ï¼Œé‚£ä¹ˆä½ è¦å¯¹testæ“ä½œè¦ç”¨&quot;-&gt;&quot; s-&gt;test ç»“æ„ä½“æŒ‡é’ˆçš„ç­‰ä»·æ€§ï¼š int *p = &amp;ç»“æ„ä½“å˜é‡ï¼› ç»“æ„ä½“å˜é‡å.æˆå‘˜å (*p).æˆå‘˜å p-&gt;æˆå‘˜å å‡½æ•°æŒ‡é’ˆ å†…å­˜ä¸­æ¯ä¸ªæŒ‡ä»¤éƒ½é¡ºåºå­˜æ”¾çš„ï¼Œæ¯ä¸ªæŒ‡ä»¤éƒ½æœ‰ä¸€ä¸ªä¸å…¶ç›¸å¯¹åº”çš„åœ°å€ï¼›è€Œå‡½æ•°ååº”åˆ°å†…å­˜ä¸­å°±æ˜¯ä¸€å¤§å—æŒ‡ä»¤çš„é›†åˆã€‚ #include&lt;stdio.h&gt; int Add(int a,int b){ return a + b; } int main(){ int c; int (*p)(int ,int); p = &amp;Add; c = (*p)(2,3); ------------------ p = Add; c = p(2,3); ------------------ printf(&quot;%d&quot;,c); return 0; //ç¨‹åºå¾—åˆ°çš„ç»“æœä¸º5 } æ°´ç…®æ˜“æ··æŒ‡é’ˆ int *a[5] è¿™æ˜¯ä¸€ä¸ªæŒ‡é’ˆæ•°ç»„ï¼Œæ¯ä¸€ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ªint *æŒ‡é’ˆå˜é‡,æŒ‡å‘intç±»å‹çš„åœ°å€ã€‚æŒ‡å‘ *a[5]æ—¶åº”è¯¥ä½¿ç”¨äºŒçº§æŒ‡é’ˆè€Œä¸æ˜¯ä¸€çº§æŒ‡é’ˆã€‚ int (*a)[5] è¿™æ˜¯ä¸€ä¸ªæ•°ç»„æŒ‡é’ˆï¼Œå®ƒæ˜¯ä¸€ä¸ªæŒ‡é’ˆå˜é‡ï¼Œå æœ‰8ä¸ªå­—èŠ‚å­˜åœ°å€ç¼–å·ï¼Œå®ƒæŒ‡å‘ä¸€ä¸ªæ•°ç»„ï¼ŒäºŒç»´æ•°ç»„åŠ ä¸€åç§»åæŒ‡å‘ä¸‹ä¸€è¡Œï¼Œä¹Ÿå¯ä»¥å°†&amp;+ä¸€ç»´æ•°ç»„èµ‹å€¼ç»™å®ƒã€‚ int **p è¿™æ˜¯ä¸€ä¸ªæŒ‡é’ˆçš„æŒ‡é’ˆï¼Œå­˜æ”¾çš„æ˜¯ä¿å­˜æŒ‡é’ˆçš„åœ°å€ã€‚ int *f(void) å®ƒæ˜¯ä¸€ä¸ªå‡½æ•°çš„å£°æ˜ï¼Œè¿”å›çš„æ˜¯ä¸€ä¸ªå‡½æ•°çš„åœ°å€-&gt;int *ç±»å‹ã€‚ int (*f)(void) fæ˜¯ä¸ªå‡½æ•°çš„æŒ‡é’ˆå˜é‡ï¼Œå­˜æ”¾å‡½æ•°çš„åœ°å€ï¼Œå®ƒæŒ‡å‘çš„å‡½æ•°å¿…é¡»æœ‰ä¸€ä¸ªintç±»å‹çš„è¿”å›å€¼ï¼Œæ²¡æœ‰å‚æ•°ã€‚ ç»“æ„ä½“ ç»“æ„ä½“çš„ä½œç”¨ï¼šæŠŠä¸€äº›ç›¸å…³çš„å˜é‡ç»„åˆèµ·æ¥ï¼Œä»¥ä¸€ä¸ªæ•´ä½“å½¢å¼å¯¹å¯¹è±¡è¿›è¡Œæè¿° ã€æ³¨ã€‘: åªæœ‰ç»“æ„ä½“å˜é‡æ‰åˆ†é…åœ°å€ï¼Œè€Œç»“æ„ä½“çš„å®šä¹‰æ˜¯ä¸åˆ†é…ç©ºé—´çš„ ç»“æ„ä½“ä¸­å„æˆå‘˜çš„å®šä¹‰å’Œä¹‹å‰çš„å˜é‡å®šä¹‰ä¸€æ ·ï¼Œä½†åœ¨å®šä¹‰æ—¶ä¹Ÿä¸åˆ†é…ç©ºé—´ ç»“æ„ä½“å˜é‡çš„å£°æ˜éœ€è¦åœ¨ä¸»å‡½æ•°ä¹‹ä¸Šæˆ–è€…ä¸»å‡½æ•°ä¸­å£°æ˜ï¼Œå¦‚æœåœ¨ä¸»å‡½æ•°ä¹‹ä¸‹åˆ™ä¼šæŠ¥é”™ cè¯­è¨€ä¸­çš„ç»“æ„ä½“ä¸èƒ½ç›´æ¥è¿›è¡Œå¼ºåˆ¶è½¬æ¢ï¼Œåªæœ‰ç»“æ„ä½“æŒ‡é’ˆæ‰èƒ½è¿›è¡Œå¼ºåˆ¶è½¬æ¢ ç›¸åŒç±»å‹çš„æˆå‘˜æ˜¯å¯ä»¥å®šä¹‰åœ¨åŒä¸€ç±»å‹ä¸‹ å®šä¹‰ç»“æ„ä½“å˜é‡ä»¥åï¼Œç³»ç»Ÿå°±ä¼šä¸ºå…¶åˆ†é…å†…å­˜å•å…ƒã€‚ åœ¨å¯¹ç»“æ„ä½“å˜é‡åˆå§‹åŒ–æ—¶ï¼Œè¦å¯¹ç»“æ„ä½“æˆå‘˜ä¸€ä¸€èµ‹å€¼ï¼Œä¸èƒ½è·³è¿‡å‰é¢æˆå‘˜å˜é‡ï¼Œè€Œç›´æ¥ç»™åé¢æˆå‘˜èµ‹åˆå€¼ã€‚ ç”¨ç»“æ„ä½“æŒ‡é’ˆå˜é‡è®¿é—®ç»“æ„ä½“å˜é‡æˆå‘˜æœ‰ä»¥ä¸‹ä¸¤ç§æ–¹å¼ï¼š (*p).å±æ€§ //è¿™é‡Œçš„æ‹¬å·ä¸èƒ½å°‘ p-&gt;å±æ€§ å…¨å±€å˜é‡ä¸å® å…¨å±€å˜é‡ å®šä¹‰åœ¨å‡½æ•°çš„å¤–éƒ¨çš„å˜é‡ç§°ä¸ºå…¨å±€å˜é‡ï¼Œå…¨å±€å˜é‡å…·æœ‰å…¨å±€çš„ç”Ÿå­˜æœŸå’Œä½œç”¨åŸŸã€‚ä»–ä»¬ä¸ä»»ä½•å‡½æ•°éƒ½æ— å…³ï¼Œä»»ä½•å‡½æ•°éƒ½å¯ä»¥è°ƒç”¨ã€‚æ²¡æœ‰åˆå§‹åŒ–çš„å…¨å±€å˜é‡ä¼šè¢«èµ‹äºˆ0å€¼ï¼ŒæŒ‡é’ˆä¼šå¾—åˆ°NULLå€¼ï¼Œä»–ä»¬çš„åˆå§‹åŒ–åœ¨mainå‡½æ•°ä¹‹å‰ã€‚å…¨å±€å˜é‡ç¦æ­¢å¥—å¨ƒ int gall = 12; void f(){ gall += 2; printf(&quot;value in f is %d&quot;,gall); } int main(){ f(); printf(&quot;value in main is %d&quot;,gall); } é™æ€å…¨å±€å˜é‡ åœ¨æœ¬åœ°å˜é‡å®šä¹‰æ—¶å‰é¢åŠ ä¸Šstaticå°±å˜æˆäº†é™æ€æœ¬åœ°å˜é‡ã€‚å‡½æ•°ç¦»å¼€æ—¶ï¼Œé™æ€æœ¬åœ°å˜é‡ä¼šä¿æŒå…¶åŸæ¥çš„å€¼ï¼Œé™æ€æœ¬åœ°å˜é‡çš„åˆå§‹åŒ–åªä¼šåœ¨ç¬¬ä¸€æ¬¡è¿›å…¥è¿™ä¸ªå‡½æ•°æ—¶åšï¼Œä»¥åè¿›å…¥å‡½æ•°ä¼šä¿æŒå’Œä¸Šæ¬¡ç¦»å¼€æ—¶çš„å€¼ã€‚ #include&lt;stdio.h&gt; int gall = 12; //int gall = 12; void f(){ int all1 = 2;//ä¸åŠ staticä¸ºæœ¬åœ°å˜é‡ static int all2 = 2; //åŠ static //éµå®ˆçš„åŸåˆ™ï¼šä»¥åè¿›å…¥å‡½æ•°ä¼šä¿æŒä¸Šæ¬¡ç¦»å¼€æ—¶çš„å€¼ printf(&quot;value in f is %d&quot;,all); all += 2; printf(&quot;value in f is %d&quot;,all); } int main(){ f(); f(); f(); } å®é™…ä¸Šåœ¨å†…å­˜ä¸­ï¼šgallåœ°å€0x3800cï¼Œall2åœ°å€0x38010ä¸¤è€…æ˜¯ç´§æŒ¨ç€çš„ï¼Œè€Œé™æ€æœ¬åœ°å˜é‡ä¸æœ¬åœ°å˜é‡all1åŒºç›¸éš”åä¸‡å…«åƒé‡Œã€‚ é™æ€æœ¬åœ°å˜é‡å®é™…ä¸Šæ˜¯ç‰¹æ®Šçš„å…¨å±€å˜é‡ï¼Œä»–ä»¬ä½äºç›¸åŒçš„å†…å­˜åŒºåŸŸã€‚é™æ€æœ¬åœ°å˜é‡å…·æœ‰å…¨å±€çš„ç”Ÿå­˜åŒºï¼Œå‡½æ•°å†…å±€éƒ¨ä½œç”¨åŸŸã€‚å…¨å±€ç”Ÿå­˜æœŸï¼Œæœ¬åœ°ä½œç”¨åŸŸã€‚ æŒ‡é’ˆä½œä¸ºè¿”å›å€¼è¿”å›æœ¬åœ°å˜é‡æ˜¯å±é™©çš„ï¼Œè¿”å›å…¨å±€å˜é‡æˆ–è€…é™æ€æœ¬åœ°å˜é‡æ˜¯å®‰å…¨çš„ï¼Œæœ€å¥½çš„åšæ³•æ˜¯è¿”å›æŒ‡é’ˆã€‚ å°è´´å£«ï¼š ä¸è¦ä½¿ç”¨å…¨å±€å˜é‡æ¥ä½œä¸ºå‡½æ•°ä¹‹é—´çš„å‚æ•°ä¼ é€’çš„ç»“æœ å°½é‡é¿å…ä½¿ç”¨å…¨å±€å˜é‡ *ä½¿ç”¨å…¨å±€å˜é‡å’Œé™æ€æœ¬åœ°å˜é‡æ—¶å‡½æ•°çš„çº¿ç¨‹æ˜¯ä¸å»å®‰å…¨çš„ ç¼–è¯‘é¢„å¤„ç†ä¸å® #include: #å¼€æœ‰å°±æ˜¯ç¼–è¯‘é¢„å¤„ç†æŒ‡ä»¤ï¼Œä»–ä»¬ä¸æ˜¯Cè¯­è¨€çš„æŒ‡ä»¤ï¼Œä½†æ˜¯ä»–ä»¬ä¸å¯æˆ–ç¼ºã€‚#defineæ¥å®šä¹‰ä¸€ä¸ªå®ã€‚ #define å®ï¼š#define PI 3.14ï¼›å› ä¸ºä¸æ˜¯Cè¯­è¨€çš„è¯­å¥æ‰€ä»¥ç»“å°¾æ²¡å¿…è¦åŠ åˆ†å·ï¼åå­—å¿…é¡»æ˜¯ä¸€ä¸ªå•è¯ï¼Œå€¼å¯ä»¥æ˜¯ä»»ä½•ä¸œè¥¿ã€‚å®ä¹Ÿå¯ä»¥å¸¦ç€å‚æ•°ï¼Œå½¢æˆå‡½æ•°çš„å®ã€‚ #define cube(x) (x * x * x) ä¸€åˆ‡éƒ½è¦æœ‰æ‹¬å·ï¼Œæ•´ä¸ªå€¼éƒ½è¦æœ‰æ‹¬å· #define MIN(a,b) ((a&gt;b)?(b):(a)) #ifndefçš„ç”¨æ³• #ifndef &lt;æ ‡è¯†&gt; #define &lt;æ ‡è¯†&gt; ...... ...... #endif #ifndefèµ·åˆ°çš„æ•ˆæœæ˜¯é˜²æ­¢ä¸€ä¸ªæºæ–‡ä»¶(.cpp)ä¸¤æ¬¡åŒ…å«åŒä¸€ä¸ªå¤´æ–‡ä»¶(.h)ï¼Œè€Œä¸æ˜¯é˜²æ­¢ä¸¤ä¸ªæºæ–‡ä»¶åŒ…å«åŒä¸€ä¸ªå¤´æ–‡ä»¶ã€‚å®ƒæ˜¯if not define çš„ç®€å†™ï¼Œæ˜¯å®å®šä¹‰çš„ä¸€ç§ï¼Œå®é™…ä¸Šç¡®åˆ‡çš„è¯´ï¼Œè¿™åº”è¯¥æ˜¯é¢„å¤„ç†åŠŸèƒ½ä¸‰ç§ï¼ˆå®å®šä¹‰ã€æ–‡ä»¶åŒ…å«ã€æ¡ä»¶ç¼–è¯‘ï¼‰ä¸­çš„ä¸€ç§â€”â€”æ¡ä»¶ç¼–è¯‘ã€‚ &lt;æ ‡è¯†&gt;åœ¨ç†è®ºä¸Šæ¥è¯´å¯ä»¥æ˜¯è‡ªç”±å‘½åçš„ï¼Œä½†æ¯ä¸ªå¤´æ–‡ä»¶çš„è¿™ä¸ªâ€œæ ‡è¯†â€éƒ½åº”è¯¥æ˜¯å”¯ä¸€çš„ã€‚æ ‡è¯†çš„å‘½åè§„åˆ™ä¸€èˆ¬æ˜¯å¤´æ–‡ä»¶åå…¨å¤§å†™ï¼Œå‰ååŠ ä¸‹åˆ’çº¿ï¼Œå¹¶æŠŠæ–‡ä»¶åä¸­çš„â€œ.â€ä¹Ÿå˜æˆä¸‹åˆ’çº¿ï¼Œå¦‚ï¼šstdio.h #ifndef STDIO_H #define STDIO_H ...... #endif ä½¿ç”¨#ifndefå¯ä»¥é¿å…ä¸‹é¢è¿™ç§é”™è¯¯ï¼šå¦‚æœåœ¨hæ–‡ä»¶ä¸­å®šä¹‰äº†å…¨å±€å˜é‡ï¼Œä¸€ä¸ªcæ–‡ä»¶åŒ…å«åŒä¸€ä¸ªhæ–‡ä»¶å¤šæ¬¡ï¼Œå¦‚æœä¸åŠ #ifndefå®å®šä¹‰ï¼Œä¼šå‡ºç°å˜é‡é‡å¤å®šä¹‰çš„é”™è¯¯ï¼›å¦‚æœåŠ äº†#ifndefï¼Œåˆ™ä¸ä¼šå‡ºç°è¿™ç§é”™è¯¯ã€‚ æ¡ä»¶æŒ‡ç¤ºç¬¦#ifndef çš„æœ€ä¸»è¦ç›®çš„æ˜¯é˜²æ­¢å¤´æ–‡ä»¶çš„é‡å¤åŒ…å«å’Œç¼–è¯‘ã€‚ constå…³é”®å­— å…³é”®å­—constç”¨æ¥å®šä¹‰å¸¸é‡ï¼Œå¦‚æœä¸€ä¸ªå˜é‡è¢«constä¿®é¥°ï¼Œé‚£ä¹ˆå®ƒçš„å€¼å°±ä¸èƒ½å†è¢«æ”¹å˜ã€‚ä¸å‰é¢çš„#define(é¢„ç¼–è¯‘æŒ‡ä»¤)ç›¸æ¯”ï¼Œconstå…·æœ‰å¦‚ä¸‹çš„ä¼˜ç‚¹ï¼š é¢„ç¼–è¯‘æŒ‡ä»¤åªæ˜¯å¯¹å€¼è¿›è¡Œç®€å•çš„æ›¿æ¢ï¼Œä¸èƒ½è¿›è¡Œç±»å‹æ£€æŸ¥ å¯ä»¥ä¿æŠ¤è¢«ä¿®é¥°çš„ä¸œè¥¿ï¼Œé˜²æ­¢æ„å¤–ä¿®æ”¹ï¼Œå¢å¼ºç¨‹åºçš„å¥å£®æ€§ ç¼–è¯‘å™¨é€šå¸¸ä¸ä¸ºæ™®é€šconstå¸¸é‡åˆ†é…å­˜å‚¨ç©ºé—´ï¼Œè€Œæ˜¯å°†å®ƒä»¬ä¿å­˜åœ¨ç¬¦å·è¡¨ä¸­ï¼Œè¿™ä½¿å¾—å®ƒæˆä¸ºä¸€ä¸ªç¼–è¯‘æœŸé—´çš„å¸¸é‡ï¼Œæ²¡æœ‰äº†å­˜å‚¨ä¸è¯»å†…å­˜çš„æ“ä½œï¼Œä½¿å¾—å®ƒçš„æ•ˆç‡ä¹Ÿå¾ˆé«˜ éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œç”¨constä¿®é¥°å˜é‡æ—¶ï¼Œä¸€å®šè¦ç»™å˜é‡åˆå§‹åŒ–ï¼Œå¦åˆ™ä¹‹åå°±ä¸èƒ½å†è¿›è¡Œèµ‹å€¼äº†ã€‚ ä½¿ç”¨constä¿®é¥°å˜é‡åï¼Œå¯ä»¥é«˜æ•æ— å¿§çš„è¿›è¡Œå‡½æ•°çš„å‚æ•°ä¼ é€’ï¼Œä½†æ˜¯ä¸å¯ä»¥ C++çš„å¼•ç”¨ å‡†ç¡®æ¥è¯´å°±æ˜¯ç»™å˜é‡èµ·åˆ«åï¼›å‡†ç¡®æ¥è¯´å®é™…çš„ä½œç”¨å’ŒæŒ‡é’ˆç±»ä¼¼ã€‚-&gt;å…±åŒæ“çºµå†…å­˜ int a = 10;//æ ˆåŒºå­˜æ”¾å†…å­˜åœ°å€ int &amp;b = a; cout &lt;&lt; &quot;a =&quot;&lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b =&quot;&lt;&lt; b &lt;&lt; endl; b = 20; cout &lt;&lt; &quot;a =&quot;&lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b =&quot;&lt;&lt; b &lt;&lt; endl; å¼•ç”¨å¿…é¡»åˆå§‹åŒ–ï¼Œå¿…é¡»å¼€å§‹çš„æ—¶å€™å°±è¦åˆå§‹åŒ–ã€‚int &amp;bæ˜¯é”™è¯¯çš„ï¼›int &amp;b = ä¸€ä¸ªå˜é‡å; å¼•ç”¨ä¸€æ—¦åˆå§‹åŒ–åï¼Œå°±ä¸å¯ä»¥æ›´æ”¹äº†ã€‚ å¼•ç”¨ä½œä¸ºå‡½æ•°çš„å‚æ•° ä½œç”¨ï¼šå‡½æ•°ä¼ å‚æ—¶ï¼Œå¯ä»¥åˆ©ç”¨å¼•ç”¨æŠ€æœ¯è®©å½¢å‚ä¿®é¥°å®å‚ã€‚ ä¼˜ç‚¹:å¯ä»¥ç®€åŒ–æŒ‡é’ˆä¿®æ”¹å®å‚ã€‚ //äº¤æ¢å‡½æ•°ä¸‰ç§æ–¹æ³•å®ç° //å€¼ä¼ é€’ void swap(int a,int b){ int temp = a; a = b; b =temp; } //åœ°å€ä¼ é€’ void swap(int *a,int *b){ int temp = *a; *a = *b; *b =temp; } swap(&amp;a,&amp;b); //å¼•ç”¨ä¼ é€’ void swap(int &amp;a,int &amp;b){ int temp = *a; *a = *b; *b =temp; } swap(a,b);//æœ¬è´¨ä¸Šaå°±æ˜¯ä¸Šé¢å­å‡½æ•°ä¸­å½¢å‚çš„åˆ«å é€šè¿‡å¼•ç”¨å‚æ•°äº§ç”Ÿçš„æ•ˆæœå’Œä½¿ç”¨æŒ‡é’ˆçš„äº§ç”Ÿçš„æ•ˆæœæ˜¯ä¸€æ ·çš„ï¼Œå¼•ç”¨çš„è¯­æ³•æ›´åŠ ç®€ä»‹æ¸…æ™°ã€‚ å¼•ç”¨ä½œä¸ºå‡½æ•°çš„è¿”å›å€¼ ä¸è¦è¿”å›å±€éƒ¨å˜é‡çš„å¼•ç”¨ int&amp; func(){ int a = 1; return a; } int main(){ int &amp;ref = func(); cout &lt;&lt; &quot;ref=&quot; &lt;&lt; ref &lt;&lt;endl;//ç¬¬ä¸€æ¬¡æ‰“refçš„å€¼æ˜¯1ï¼Œå› ä¸ºç¼–è¯‘å™¨åšäº†ä¿ç•™ cout &lt;&lt; &quot;ref=&quot; &lt;&lt; ref &lt;&lt;endl;//ç¬¬äºŒæ¬¡æ‰“æ˜¯ä¸ªä¹±ç ã€é”™è¯¯å€¼ï¼Œå› ä¸ºå±€éƒ¨å˜é‡é‡Šæ”¾ } å‡½æ•°çš„è°ƒç”¨å¯ä»¥ä½œä¸ºå·¦å€¼ int&amp; func(){ static int a = 1; return a; } int main(){ int &amp;ref = func(); cout &lt;&lt; &quot;ref=&quot; &lt;&lt; ref &lt;&lt;endl; cout &lt;&lt; &quot;ref=&quot; &lt;&lt; ref &lt;&lt;endl;//ç»“æœéƒ½æ˜¯1 func() = 200; cout &lt;&lt; &quot;ref=&quot; &lt;&lt; ref &lt;&lt;endl; cout &lt;&lt; &quot;ref=&quot; &lt;&lt; ref &lt;&lt;endl;//ç»“æœéƒ½æ˜¯200 } void test(){ static int a = 10; return a; } int &amp;ref = test(); cout &lt;&lt; &quot;ref =&quot;&lt;&lt;ref &lt;&lt; endl; cout &lt;&lt; &quot;ref =&quot;&lt;&lt;ref &lt;&lt; endl; test() = 1000;//å‡½æ•°çš„è°ƒç”¨å¯ä»¥ä½œä¸ºå·¦å€¼ cout &lt;&lt; &quot;ref =&quot;&lt;&lt;ref &lt;&lt; endl; cout &lt;&lt; &quot;ref =&quot;&lt;&lt;ref &lt;&lt; endl; å¼•ç”¨çš„æœ¬è´¨ å¼•ç”¨çš„æœ¬è´¨åœ¨C++ä¸­å†…éƒ¨çš„å®ç°å°±æ˜¯ä¸€ä¸ªæŒ‡é’ˆå¸¸é‡ã€‚å¼•ç”¨ä¸€æ—¦åˆå§‹åŒ–ï¼Œå°±ä¸å¯ä»¥è¿›è¡Œæ›´æ”¹ã€‚ C++æ¨èä½¿ç”¨å¼•ç”¨æŠ€æœ¯ï¼Œå› ä¸ºè¯­æ³•æ–¹ä¾¿ï¼Œæ‰€æœ‰çš„æŒ‡é’ˆæ“ä½œç¼–è¯‘å™¨éƒ½å¸®æˆ‘ä»¬åšå¥½äº†ã€‚ //ç¼–è¯‘å™¨å‘ç°æ˜¯å¼•ç”¨çš„è¯ï¼Œè½¬åŒ–ä¸º int* const ref = &amp;a; void func(int &amp;ref){ int ref = 100; } int main(){ //è‡ªåŠ¨è½¬æ¢ä¸º int* const ref = &amp;a;æŒ‡é’ˆå¸¸é‡æ˜¯æŒ‡é’ˆæŒ‡å‘ä¸å¯ä»¥æ”¹å˜ï¼Œä¹Ÿè¯´æ˜äº†ä¸ºä»€ä¹ˆå¼•ç”¨ä¸å¯ä»¥æ›´æ”¹ã€‚ int &amp;ref = a; ref = 20;//å†…éƒ¨å‘ç°refæ˜¯å¼•ç”¨ä»¥åï¼Œè‡ªåŠ¨å¸®æˆ‘ä»¬è½¬æ¢ä¸ºï¼š*ref = 20ï¼› cout &lt;&lt; &quot;a&quot; &lt;&lt; a &lt;&lt;endl; cout &lt;&lt; &quot;ref&quot; &lt;&lt; ref &lt;&lt;endl; func(a); return 0; } ä¿®é¥°å½¢å‚æ”¾ç½® void PrintValue(const int &amp;x){ x = &quot;æ–°å€¼&quot;;//åŠ ä¸Šconstä»¥åï¼Œè¿™å¥è¯å°±ä¼šæŠ¥é”™ cout &lt;&lt; &quot;val = &quot; &lt;&lt; endl; } //å¯¹äºå¸¸é‡çš„å¼•ç”¨ int main(){ int a = 10; int &amp;ref = a; //ä»¥ä¸Šå†…å®¹æ˜¯åˆæ³•çš„ï¼Œä½†æ˜¯å¦‚æœå·¦å€¼èµ‹ç»™äº†ä¸€ä¸ªæ–°çš„æ•°å€¼å°±ä¼šå¼•èµ·éæ³•æ“ä½œ ref = 20;//è¿™æ ·æ“ä½œæ˜¯éæ³•çš„ï¼Œ20ä¸‹é¢ä¼šåŠ ä¸Šçº¢è‰²æ³¢æµªçº¿æŠ¥é”™æç¤ºã€‚ //åŠ ä¸Šconstä¹‹åï¼Œç¼–è¯‘å™¨å°†ä»£ç ä¿®æ”¹ä¸º int temp = 20 const int &amp;ref = temp; const int &amp;ref = 20; int x = 10; PrintValue(x);//ä¸ºäº†é¿å…åœ¨å­å‡½æ•°ä¸­å¯¹å®å‚è¿›è¡Œä¿®æ”¹ï¼Œå¯ä»¥åœ¨å½¢å‚å‰é¢åŠ ä¸Šconstå…³é”®å­— cout &lt;&lt; &quot;val = &quot; &lt;&lt; endl; } åŠ¨æ€å†…å­˜åˆ†é… ç¨‹åºè¿è¡Œè¿‡ç¨‹ä¸­ï¼Œéœ€è¦æ ¹æ®è‡ªèº«å¤§å°è‡ªç”±åˆ†é…ç©ºé—´ æŒ‰éœ€åˆ†é… åˆ†é…åœ¨å †åŒºï¼Œä¸€èˆ¬ä½¿ç”¨ç‰¹å®šçš„å‡½æ•°è¿›è¡Œåˆ†é… -&gt;freeå‡½æ•°é‡Šæ”¾pæŒ‡é’ˆæŒ‡å‘çš„å†…å­˜ã€‚å†…å­˜å¤§å°æœ‰é™ï¼Œå¥½å€Ÿå¥½è¿˜ã€å†å€Ÿä¸éš¾ã€‚ free(p); mallocå‡½æ•°æ— æ³•é¿å…å†…å­˜çš„ç¢ç‰‡åŒ–ã€‚ malloc #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; void *malloc(int size){ }//åœ¨å †åŒºä¸­åˆ†é…ä¸€å—é•¿åº¦ä¸ºsizeçš„è¿ç»­å†…å­˜å—ï¼Œç”¨æ¥å­˜æ”¾å†…å­˜è¯´æ˜ç¬¦å·æŒ‡å®šçš„æ•°æ®ç±»å‹ï¼Œå‡½æ•°è¿”å› void *æŒ‡é’ˆ int main(){ int *p = (int *)malloc(size);//(int *)æ³¨æ„å¼ºè½¬ } è¿”å›å€¼ï¼š åˆ†é…å†…å­˜ç©ºé—´çš„èµ·å§‹åœ°å€(åˆ†é…æˆåŠŸ) NULL(åˆ†é…å¤±è´¥) calloc åœ¨å†…å­˜å †ä¸­ï¼Œç”³è¯·nå—ï¼Œæ¯å—sizeof(æŒ‡å®šæ•°æ®ç±»å‹)ä¸ªå­—èŠ‚çš„å­—èŠ‚çš„è¿ç»­åŒºåŸŸã€‚ #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; void *calloc(int size){ }//åœ¨å †åŒºä¸­åˆ†é…ä¸€å—é•¿åº¦ä¸ºsizeçš„è¿ç»­å†…å­˜å—ï¼Œç”¨æ¥å­˜æ”¾å†…å­˜è¯´æ˜ç¬¦å·æŒ‡å®šçš„æ•°æ®ç±»å‹ï¼Œå‡½æ•°è¿”å› void *æŒ‡é’ˆ int main(){ //æœ¬è´¨ä¸Šå°±æ˜¯ä¸€ä¸ªäºŒç»´çš„æ•°ç»„æŒ‡é’ˆ datatype *p = (datatype *)calloc(n,sizeof(datatype));//(datatype *)æ³¨æ„å¼ºè½¬ } memsetå‡½æ•° void *memset(void *ptr,int value,size_t num); //memsetå‡½æ•°æ˜¯å°†ptræŒ‡é’ˆæŒ‡å‘çš„å†…å­˜ç©ºé—´çš„numä¸ªå­—èŠ‚å…¨éƒ¨èµ‹å€¼ä¸ºvalueï¼› int *str = (int *)malloc(sizeof(int)*100); if(!str) return; memset(str,0,100); for(int i = 0;i &lt; sizeof(str)/sizeif(int);i++){ printf(&quot;%d\\t&quot;,str[i]); } æ–‡ä»¶æ“ä½œ åˆè¯†æ–‡ä»¶ æ–‡ä»¶æ˜¯ç”¨æ¥å­˜æ”¾ç¨‹åºã€æ–‡æ¡£ã€éŸ³é¢‘ã€è§†é¢‘æ•°æ®ã€å›¾ç‰‡ç­‰æ•°æ®ã€‚æ–‡ä»¶æ˜¯å­˜æ”¾åœ¨ç£ç›˜ä¸Šçš„æ•°æ®é›†åˆã€‚ **ç£ç›˜æ–‡ä»¶ï¼š**ä¸€ç»„ç›¸å…³æ•°æ®çš„é›†åˆï¼Œé€šå¸¸å­˜æ”¾åœ¨å¤–éƒ¨ä»‹è´¨ä¸Šï¼Œä½¿ç”¨æ—¶æ‰è°ƒå…¥å†…å­˜ **è®¾å¤‡æ–‡ä»¶ï¼š**åœ¨OSä¸­æŠŠæ¯ä¸€ä¸ªä¸ä¸»æœºç›¸è¿çš„è¾“å…¥ã€è¾“å‡ºè®¾å¤‡çœ‹åšä¸€ä¸ªæ–‡ä»¶ï¼ŒæŠŠä»–ä»¬çš„è¾“å…¥ã€è¾“å‡ºç­‰åŒäºç£ç›˜æ–‡ä»¶çš„è¯»å’Œå†™ã€‚ é”®ç›˜ï¼šæ ‡å‡†è¾“å…¥æ–‡ä»¶ å±å¹•ï¼šæ ‡å‡†è¾“å‡ºæ–‡ä»¶ Cè¯­è¨€ä¸­æ–‡ä»¶çš„æ“ä½œï¼š FILE *fopen(const char *filename, const char *mode); è¿”å›å€¼ï¼š fopenå‡½æ•°è¿”å›æ–°æ‰“å¼€æ–‡ä»¶çš„æ–‡ä»¶æŒ‡é’ˆï¼› å¦‚æœæ­¤æ–‡ä»¶ä¸èƒ½æ‰“å¼€ï¼Œåˆ™è¿”å›NULLæŒ‡é’ˆã€‚ &quot;r&quot; æ‰“å¼€æ–‡ä»¶ä»…ä¾›è¯»å– å¿…é¡»å­˜åœ¨ &quot;w&quot; åˆ›å»ºæ–°æ–‡ä»¶ä»…ä¾›å†™å…¥ è‹¥å­˜åœ¨ï¼Œåˆ™æ¸…ç©ºåå†å†™å…¥ &quot;a&quot; æ‰“å¼€æ–‡ä»¶é™„åŠ å†™å…¥ è‹¥ä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºæ–°æ–‡ä»¶å†™å…¥ &quot;r+&quot; æ‰“å¼€æ–‡ä»¶ä¾›è¯»å–å¹¶å†™å…¥ å¿…é¡»å­˜åœ¨ &quot;w+&quot; åˆ›å»ºæ–°æ–‡ä»¶ä¾›è¯»å–å¹¶å†™å…¥ è‹¥å­˜åœ¨ï¼Œåˆ™æ¸…ç©ºåå†å†™å…¥ &quot;a&quot; æ‰“å¼€æ–‡ä»¶è¯»å–å¹¶é™„åŠ å†™å…¥ è‹¥ä¸å­˜åœ¨ï¼Œåˆ™åˆ›å»ºæ–°æ–‡ä»¶å†™å…¥ FILE* fp = fopen('file','r'); if(fp){ fscanf(fp,...); fclose(fp); } else{ } ç¼–ç ã€è¿ç®—ä¸å˜é‡ æ•°æ®å­˜å‚¨é‡çš„é‡çº§å¢é•¿ï¼š 1å­—èŠ‚1KB=8æ¯”ç‰¹bits 1å…†å­—èŠ‚1MB=1024KB 1å‰å­—èŠ‚1GB=1024MB 1å¤ªå­—èŠ‚1TB=1024GB åƒä¸‡äº¿å­—èŠ‚1PBæ‹å­—èŠ‚ = 1024TB ç™¾äº¿äº¿å­—èŠ‚1EBè‰¾å­—èŠ‚ = 1024PB åä¸‡äº¿äº¿å­—èŠ‚1ZBæ³½å­—èŠ‚ = 1024EB ä¸€äº¿äº¿äº¿å­—èŠ‚1YBå°§å­—èŠ‚ = 1024ZB ä¸€åƒäº¿äº¿äº¿å­—èŠ‚1BB = 1024YB è¡¥ç çš„ä½œç”¨ ç»„æˆåŸç†è¦è€ƒï¼ è®¡ç®—æœºçš„CPUæ— æ³•è¿›è¡Œå‡æ³•è¿ç®—ï¼Œåªèƒ½åšåŠ æ³•è¿ç®—ã€‚CPUæœ‰ä¸€ä¸ªé€»è¾‘å•å…ƒäº¤åŠ æ³•å™¨ï¼Œåªèƒ½è¿›è¡ŒåŠ æ³•æ“ä½œã€‚CPUä¸­åŒ…å«ä¸‰éƒ¨åˆ†ï¼šåŠ æ³•å™¨ã€ç§»ä½å™¨ã€è¯‘ç å™¨ã€‚å¯¹äºå‡æ³•æ“ä½œï¼š2-5-&gt;2+(-5)çš„æ“ä½œã€‚ç”±äºè®¡ç®—æœºåªèƒ½å­˜å‚¨0å’Œ1ï¼Œç¼–å†™ç¨‹åºæ¥çœ‹-5æ˜¯å¦‚ä½•å­˜å‚¨çš„ã€‚ åœ¨æ•°æ®çš„å­˜å‚¨ä¸­ï¼Œæœ‰ä¸¤ç§å­˜å‚¨å½¢å¼ï¼Œ*å¤§ç«¯å­˜å‚¨å’Œå°ç«¯å­˜å‚¨ã€‚*æ‰€æœ‰çš„æ•°æ®éƒ½æ˜¯åœ¨å†…å­˜å½“ä¸­å­˜çš„ï¼Œè€Œå†…å­˜å½“ä¸­çš„åŸºæœ¬å•ä½æ˜¯å­—èŠ‚æ•°æ®è®¿å­˜çš„åŸºæœ¬å•ä½æ˜¯å­—èŠ‚çš„è¯ï¼Œé‚£ä¹ˆä¸€ä¸ªæ•´å½¢å˜é‡ï¼ˆintï¼‰å°±æœ‰å››ä¸ªå­—èŠ‚ï¼Œé‚£ä¹ˆå°±æ„å‘³ç€æ•°æ®åœ¨å­˜å‚¨è¿‡ç¨‹ä¸­ä¼šè¢«åˆ’åˆ†ä¸ºå››å—ã€‚æ•°æ®æŒ‰ç…§å­—èŠ‚åºä¸ºå•ä½ï¼Œä¹Ÿæœ‰é«˜æƒå€¼ä½ï¼Œä½æƒå€¼ä½ä¹‹åˆ«çš„ã€‚æŒ‰ç©ºé—´æ¥åˆ’åˆ†çš„è¯ï¼Œæœ‰é«˜åœ°å€ï¼Œä½åœ°å€ä¹‹åˆ†ã€‚ ä¸¤ç§å­˜å‚¨æ–¹æ¡ˆï¼š å¤§ç«¯ï¼šæŒ‰ç…§å­—èŠ‚ä½å•ä½ï¼Œä½æƒå€¼ä½æ•°æ®å­˜å‚¨åœ¨é«˜åœ°å€å¤„ï¼Œå°±å«åšå¤§ç«¯ï¼› å°ç«¯ï¼šæŒ‰ç…§å­—èŠ‚ä½å•ä½ï¼Œä½æƒå€¼ä½æ•°æ®å­˜å‚¨åœ¨ä½åœ°å€å¤„ï¼Œå°±å«åšå°ç«¯ã€‚ æˆ‘ä»¬ä»¥ int a = -10 ä¸ºä¾‹ï¼š ï¼ˆå› ä¸ºintç±»å‹å æœ‰å››ä¸ªå­—èŠ‚ï¼Œè€Œä¸€ä¸ªå­—èŠ‚ç­‰äº8ä¸ªbiteä½ï¼‰ ï¼ˆè¯´æ˜:æ•°æ®åœ¨å†…å­˜ä¸­æ˜¯ä»¥è¡¥ç çš„å½¢å¼å­˜å‚¨çš„ï¼‰ æ‰€ä»¥å°†å…¶è½¬åŒ–ä¸ºäºŒè¿›åˆ¶åŸç ä¸º: 10000000 00000000 00000000 00001010 åç (ç¬¦å·ä½ä¸å˜ï¼Œå…¶ä»–ä½æŒ‰ä½å–å): 11111111 11111111 11111111 11110101 è¡¥ç ï¼ˆåç +1ï¼‰ï¼š 11111111 11111111 11111111 11110110 è½¬åŒ–ä¸ºåå…­è¿›åˆ¶ä¸º: ï¼¦ï¼¦ ï¼¦ï¼¦ ï¼¦ï¼¦ ï¼¦ï¼– å¤§ç«¯å­˜å‚¨ï¼š ä½åœ°å€-&gt;é«˜åœ°å€ï¼šï¼¦ï¼¦ ï¼¦ï¼¦ ï¼¦ï¼¦ ï¼¦ï¼– å°æ®µå­˜å‚¨ï¼š é«˜åœ°å€-&gt;ä½åœ°å€ï¼šï¼¦ï¼– ï¼¦ï¼¦ ï¼¦ï¼¦ ï¼¦ï¼¦ 5 0000 0101-&gt;ä¸€ä¸ªå­—èŠ‚ åŸç  -5 å–åååŠ 1ï¼š1111 1010-&gt;1111 1011 ç”¨è¡¥ç æ¥è¡¨ç¤ºè´Ÿæ•° å¯¹äºæœ‰ç¬¦å·æ•°è€Œè¨€ï¼Œæœ€é«˜ä½ä¸º1è¡¨ç¤ºè´Ÿæ•°ï¼Œæœ€é«˜ä½ä¸º0è¡¨ç¤ºæ­£æ•°ã€‚æœ€é«˜ä½ä¸º1åˆ™è‡ªç„¶è¡¨ç¤ºè¯¥æ•°æ®çš„è¡¥ç ï¼ŒåŠ 1å–ååˆ™å¾—åˆ°ç›¸åæ•° åç çš„ä½œç”¨ åç æ˜¯è®¡ç®—æœºä¸­ä¸€ç§æœºå™¨ç çš„è¡¨ç¤ºã€‚å¯¹äºå•ä¸ªæ•°å€¼(äºŒè¿›åˆ¶çš„0å’Œ1)è€Œè¨€ï¼Œå¯¹å…¶è¿›è¡Œåæ“ä½œå°±æ˜¯å°†0å˜æˆ1ï¼Œå°†1å˜æˆ0ã€‚æ­£æ•°çš„åç å’ŒåŸç ä¸€è‡´ï¼Œè´Ÿæ•°çš„åç å°±æ˜¯åœ¨å…¶åŸç çš„åŸºç¡€ä¹‹ä¸Šï¼Œç¬¦å·ä½ä¸å˜çš„æƒ…å†µä¸‹ï¼Œå…¶ä»–ä½ç½®å–åã€‚ åç æ˜¯å†å²é—ç•™çš„æ®‹ç‰©ã€‚ä½œç”¨å°±æ˜¯è§£å†³å¯¹äºè´Ÿæ•°è¡¥ç çš„æ±‚å€¼ã€‚ è´Ÿæ•°çš„è¡¥ç =è´Ÿæ•°çš„åŸç -&gt;è´Ÿæ•°çš„åç -&gt;åç åŠ 1 intæ•°å€¼å‹ æ‹¬å·å¯ä»¥ç¼ºçœï¼Œæ— ç¬¦å·åªèƒ½å­˜å‚¨éè´Ÿæ•°ã€‚ æ•´å‹å˜é‡çš„ç±»å‹ï¼š æœ‰ç¬¦å·åŸºæœ¬æ•´å‹ï¼š(signed)int æœ‰ç¬¦å·çŸ­æ•´å‹ï¼š(signed)short(int) æœ‰ç¬¦å·é•¿æ•´å‹ï¼š(signed)long(int) æ— ç¬¦å·åŸºæœ¬æ•´å‹ï¼šunsigned int æ— ç¬¦å·çŸ­æ•´å‹ï¼šunsigned short(int) æ— ç¬¦å·é•¿æ•´å‹ï¼šunsigned long(int) æ•°æ®ç±»å‹ å­—èŠ‚æ•° èŒƒå›´ (signed)int 4 âˆ’231-2^{31}âˆ’231~231âˆ’12^{31}-1231âˆ’1 (signed)short(int) 2 âˆ’215-2^{15}âˆ’215~215âˆ’12^{15}-1215âˆ’1 (signed)long(int) 4 âˆ’231-2^{31}âˆ’231~231âˆ’12^{31}-1231âˆ’1 æˆ– âˆ’263-2^{63}âˆ’263~263âˆ’12^{63}-1263âˆ’1 unsigned int 4 000~232âˆ’12^{32}-1232âˆ’1 unsigned short(int) 2 0-65535 unsigned long(int) 4 000~232âˆ’12^{32}-1232âˆ’1 æˆ– 000~264âˆ’12^{64}-1264âˆ’1 Linux OSä¸‹longç±»å‹å æœ‰8ä¸ªå­—èŠ‚ ä¸ºå•¥ç¬¦å·ä½çš„å­—èŠ‚æ•°è¦æ¯”ç¬¦å·ä½å°‘ä¸€æ¬¡å¹‚å‘¢ï¼Ÿå› ä¸ºç¬¦å·ä½ æœ€å°çš„è´Ÿæ•°æ˜¯ï¼š 1000 0000 0000 0000 0000 0000 0000 0000 è€Œä¸æ˜¯ï¼š 1111 1111 1111 1111 1111 1111 1111 1111 é¿å…æº¢å‡ºç°è±¡çš„å‘ç”Ÿï¼š æŒæ¡å­—ç¬¦å‹æ•°å€¼çš„å–å€¼èŒƒå›´ï¼ æµ®ç‚¹å‹æ•°æ® åœ¨Cè¯­è¨€ä¸­ï¼Œæµ®ç‚¹å‹æ•°æ®ç”¨doubleå’Œfloatè¡¨ç¤ºã€‚floatå ç”¨4ä¸ªå­—èŠ‚ï¼Œdoubleå ç”¨8ä¸ªå­—èŠ‚ã€‚ä¸æ•´æ•°å½¢å¼ä¸åŒï¼Œæµ®ç‚¹æ•°å­˜å‚¨æ˜¯æŒ‰ç…§æŒ‡æ•°å½¢å¼å­˜å‚¨çš„ã€‚ç³»ç»Ÿä¼šæŠŠä¸€ä¸ªæµ®ç‚¹æ•°åˆ†æˆå°æ•°éƒ¨åˆ†Må’ŒæŒ‡æ•°éƒ¨åˆ†Eï¼Œåˆ†åˆ«å­˜æ”¾ã€‚ 0/1è¡¨ç¤ºç¬¦å·ä½ï¼ŒæŒ‡æ•°éƒ¨åˆ†æœ‰8ä½ï¼Œå°æ•°éƒ¨åˆ†æœ‰23ä½ã€‚ æµ®ç‚¹æ•°çš„å–å€¼èŒƒå›´è¦çœ‹æŒ‡æ•°éƒ¨åˆ†çš„å–å€¼ï¼šæŒ‡æ•°éƒ¨åˆ†æœ‰æ•ˆä½æ•°æ˜¯8ä½ï¼Œæ‰€ä»¥èŒƒå›´å°±æ˜¯2âˆ’127åˆ°1282^{-127åˆ°128}2âˆ’127åˆ°128,æ±‚å¾—çš„ç»“æœç”¨ç§‘å­¦è®¡æ•°æ³•è¡¨ç¤ºå°±æ˜¯ä¸‹é¢floatçš„èŒƒå›´ã€‚æœ‰æ•ˆéƒ¨åˆ†æ˜¯å°æ•°éƒ¨åˆ†ï¼Œ23ä½å°±æ˜¯2çš„23æ¬¡æ–¹=8388608ä¸èƒ½è¡¨ç¤ºåˆ°9999999. æ•°æ®ç±»å‹ ä½æ•° èŒƒå›´ æœ‰æ•ˆä½æ•° float 32 10âˆ’3710^{-37}10âˆ’37~^10{38}-1$ 6-7 double 64 10âˆ’30710^{-307}10âˆ’307~^10{308}-1$ 15-16 long double 128 10âˆ’493110^{-4931}10âˆ’4931~104932âˆ’110^{4932}-1104932âˆ’1 18-19 IEEE-754æ ‡å‡†: 0x:40 90 00 00: 0o:0 100 0000 1001 0000 0000 0000 0000 0000 å­—ç¬¦ä¸²å¸¸é‡ è½¬ä¹‰å­—ç¬¦ï¼š \\n æ¢è¡Œ \\t æ¨ªå‘è·³æ ¼ \\r å›è½¦ \\ \\ åæ–œæ  \\b é€€æ ¼ \\0 ç©ºå­—ç¬¦ç”¨äºæ ‡è¯†å­—ç¬¦ä¸²çš„ç»“å°¾ï¼Œä¸æ˜¯ç©ºæ ¼ï¼Œæ— æ³•æ‰“å° ä½è¿ç®— &lt;&lt;:å·¦ç§» &gt;&gt;:å³ç§» ~: æŒ‰ä½å–å |: æŒ‰ä½æˆ– ^: æŒ‰ä½å¼‚æˆ– &amp;: æŒ‰ä½ä¸ ä¸€ä¸ªå˜é‡å·¦ç§»ä¸å³ç§»ä¹‹åç±»ä¼¼äº++æˆ–è€…â€”â€“å…¶æœ¬èº«å¾ˆä¸ä¼šå‘ç”Ÿæ”¹å˜ï¼Œé™¤éå¯¹å…¶è‡ªèº«è¿›è¡Œèµ‹å€¼ã€‚ **å·¦ç§»ï¼š**ä¸¢å¼ƒé«˜ä½ï¼Œä½ä½ä»¥0è¡¥å……ï¼Œç›¸å½“äºä¹˜ä»¥2.ç”³è¯·å†…å­˜æ˜¯éœ€è¦ç”¨åˆ°å·¦ç§»ã€‚ä¾‹å¦‚è¦ç”³è¯·ä¸€ä¸ªGçš„å†…å­˜ï¼Œå¯ä»¥ä½¿ç”¨malloc(1&lt;&lt;20)ã€‚ **å³ç§»ï¼š**ä½ä½ä¸¢å¼ƒï¼Œæ­£æ•°é«˜ä½è¡¥0ï¼Œè´Ÿæ•°é«˜ä½è¡¥1ï¼Œç›¸å½“äºé™¤ä»¥2ã€‚ç§»ä½å¯¹äºä¹˜é™¤æ³•æ¥è¯´æ•ˆç‡è¦é«˜ï¼Œè´Ÿæ•°å³ç§»å¯¹å¶æ•°æ¥è¯´æ˜¯é™¤ä»¥2ï¼Œä½†æ˜¯å¯¹äºæŠ€æœ¯æ¥è¯´æ˜¯å…ˆå‡1åé™¤ä»¥2.-æ— ç¬¦å·æ•°å³ç§»æ—¶çš„é«˜ä½è¡¥1. **å¼‚æˆ–ï¼š**ç›¸åŒçš„æ•°å­—è¿›è¡Œå¼‚æˆ–æ˜¯ç»“æœä¸º0ï¼›ä»»ä½•æ•°å­—å’Œ0å¼‚æˆ–çš„ç»“æœæ—¶å…¶æœ¬èº«ã€‚æ•°å­—ä½ç›¸åŒä¸º0ï¼Œç›¸å¼‚ä¸º1ã€‚ **æŒ‰ä½å–åï¼š**æ•°ä½ä¸Šçš„0å˜æˆ1,1å˜æˆ0ã€‚æ­£æ•°æŒ‰ä½å–åçš„ç»“æœæ˜¯å…¶ç›¸åæ•°-1. **æŒ‰ä½ä¸å’ŒæŒ‰ä½æˆ–ï¼š**ç”¨ä¸¤ä¸ªæ•°å­—çš„æ¯ä¸€ç»´è¿›è¡Œä¸å’Œæˆ–ã€‚ä¸æ˜¯å‰è€…ï¼Œæˆ–æ˜¯åè€…ã€‚ &amp; ä¸ï¼šå…¨1åˆ™1ï¼Œæœ‰0åˆ™0 | æˆ–ï¼šå…¨0ä¸º0ï¼Œæœ‰1åˆ™1 ~ éï¼šæŒ‰æœªå–å ^ å¼‚æˆ–ï¼šç›¸åŒä¸º0ï¼Œä¸åŒä¸º1 &gt;&gt; å³ç§» &lt;&lt; å·¦ç§» ä¸¤ä¸ªæ•°å–å¼‚æˆ–åå¾—åˆ°çš„ç»“æœå†åˆ†åˆ«ä¸è‡ªèº«å–å¼‚æˆ–ï¼Œä¾¿å¯ä»¥å¾—åˆ°ä¸¤ä¸ªæ•°äº¤æ¢çš„ç»“æœã€‚ C++ åŸºæœ¬çš„è¾“å…¥è¾“å‡º C++ æ ‡å‡†åº“æä¾›äº†ä¸€ç»„ä¸°å¯Œçš„è¾“å…¥/è¾“å‡ºåŠŸèƒ½ï¼Œæˆ‘ä»¬å°†åœ¨åç»­çš„ç« èŠ‚è¿›è¡Œä»‹ç»ã€‚æœ¬ç« å°†è®¨è®º C++ ç¼–ç¨‹ä¸­æœ€åŸºæœ¬å’Œæœ€å¸¸è§çš„ I/O æ“ä½œã€‚ C++ çš„ I/O å‘ç”Ÿåœ¨æµä¸­ï¼Œæµæ˜¯å­—èŠ‚åºåˆ—ã€‚å¦‚æœå­—èŠ‚æµæ˜¯ä»è®¾å¤‡ï¼ˆå¦‚é”®ç›˜ã€ç£ç›˜é©±åŠ¨å™¨ã€ç½‘ç»œè¿æ¥ç­‰ï¼‰æµå‘å†…å­˜ï¼Œè¿™å«åšè¾“å…¥æ“ä½œã€‚å¦‚æœå­—èŠ‚æµæ˜¯ä»å†…å­˜æµå‘è®¾å¤‡ï¼ˆå¦‚æ˜¾ç¤ºå±ã€æ‰“å°æœºã€ç£ç›˜é©±åŠ¨å™¨ã€ç½‘ç»œè¿æ¥ç­‰ï¼‰ï¼Œè¿™å«åšè¾“å‡ºæ“ä½œã€‚ I/O åº“å¤´æ–‡ä»¶ ä¸‹åˆ—çš„å¤´æ–‡ä»¶åœ¨ C++ ç¼–ç¨‹ä¸­å¾ˆé‡è¦ã€‚ å¤´æ–‡ä»¶ å‡½æ•°å’Œæè¿° è¯¥æ–‡ä»¶å®šä¹‰äº† cinã€coutã€cerr å’Œ clog å¯¹è±¡ï¼Œåˆ†åˆ«å¯¹åº”äºæ ‡å‡†è¾“å…¥æµã€æ ‡å‡†è¾“å‡ºæµã€éç¼“å†²æ ‡å‡†é”™è¯¯æµå’Œç¼“å†²æ ‡å‡†é”™è¯¯æµã€‚ è¯¥æ–‡ä»¶é€šè¿‡æ‰€è°“çš„å‚æ•°åŒ–çš„æµæ“çºµå™¨ï¼ˆæ¯”å¦‚ setw å’Œ setprecisionï¼‰ï¼Œæ¥å£°æ˜å¯¹æ‰§è¡Œæ ‡å‡†åŒ– I/O æœ‰ç”¨çš„æœåŠ¡ã€‚ è¯¥æ–‡ä»¶ä¸ºç”¨æˆ·æ§åˆ¶çš„æ–‡ä»¶å¤„ç†å£°æ˜æœåŠ¡ã€‚æˆ‘ä»¬å°†åœ¨æ–‡ä»¶å’Œæµçš„ç›¸å…³ç« èŠ‚è®¨è®ºå®ƒçš„ç»†èŠ‚ã€‚ C++ ç¼–è¯‘å™¨æ ¹æ®è¦è¾“å‡ºå˜é‡çš„æ•°æ®ç±»å‹ï¼Œé€‰æ‹©åˆé€‚çš„æµæ’å…¥è¿ç®—ç¬¦æ¥æ˜¾ç¤ºå€¼ã€‚&lt;&lt; è¿ç®—ç¬¦è¢«é‡è½½æ¥è¾“å‡ºå†…ç½®ç±»å‹ï¼ˆæ•´å‹ã€æµ®ç‚¹å‹ã€double å‹ã€å­—ç¬¦ä¸²å’ŒæŒ‡é’ˆï¼‰çš„æ•°æ®é¡¹ã€‚ æµæ’å…¥è¿ç®—ç¬¦ &lt;&lt; åœ¨ä¸€ä¸ªè¯­å¥ä¸­å¯ä»¥å¤šæ¬¡ä½¿ç”¨ï¼Œå¦‚ä¸Šé¢å®ä¾‹ä¸­æ‰€ç¤ºï¼Œendl ç”¨äºåœ¨è¡Œæœ«æ·»åŠ ä¸€ä¸ªæ¢è¡Œç¬¦ã€‚ using namespace stdçš„æ„æ€æ˜¯ä½¿ç”¨å‘½åç©ºé—´ stdã€‚C++æ ‡å‡†åº“ä¸­çš„ç±»å’Œå‡½æ•°æ˜¯åœ¨å‘½åç©ºé—´ stdä¸­å£°æ˜çš„ï¼Œå› æ­¤ç¨‹åºä¸­å¦‚æœéœ€è¦ç”¨åˆ° C++æ ‡å‡†åº“ï¼Œï¼ˆæ­¤æ—¶å°±éœ€è¦ç”¨ #includeå‘½ä»¤è¡Œï¼‰ç”¨using namespace stdä½œå£°æ˜ï¼Œè¡¨ç¤ºè¦ç”¨åˆ°å‘½åç©ºé—´ stdä¸­çš„å†…å®¹ã€‚ å¦‚æœç¨‹åºæœ‰è¾“å…¥æˆ–è¾“å‡ºæ—¶ï¼Œå¿…é¡»ä½¿ç”¨#include å‘½ä»¤ä»¥æä¾›å¿…è¦çš„ä¿¡æ¯ï¼ŒåŒæ—¶è¦ç”¨using namespace std; ä½¿ç¨‹åºèƒ½å¤Ÿä½¿ç”¨è¿™äº›ä¿¡æ¯ï¼Œå¦åˆ™ç¨‹åºç¼–è¯‘æ—¶å°†å‡ºé”™ã€‚ cin&gt;&gt;è¾“å…¥æµ&gt;&gt;endlï¼› cin&gt;&gt;å˜é‡1&gt;&gt;å˜é‡2&gt;&gt;å˜é‡3&gt;&gt;å˜é‡n&gt;&gt;endlï¼› cout&lt;&lt;è¾“å‡ºæµ&lt;&lt;endl; cout&lt;&lt;è¡¨è¾¾å¼1&lt;&lt;è¡¨è¾¾å¼2&lt;&lt;è¡¨è¾¾å¼3&lt;&lt;è¡¨è¾¾å¼n&lt;&lt;endlï¼› åœ¨å®šä¹‰æµå¯¹è±¡æ—¶ï¼Œç³»ç»Ÿä¼šåœ¨å†…å­˜ä¸­å¼€è¾Ÿä¸€æ®µç¼“å†²åŒºï¼Œç”¨æ¥æš‚å­˜è¾“å…¥è¾“å‡ºæµçš„æ•°æ®ã€‚å…ˆæŠŠæ’å…¥çš„æ•°æ®é¡ºåºå­˜æ”¾è¾“å‡ºç¼“å†²åŒºä¸­ï¼Œç›´åˆ°è¾“å‡ºç¼“å†²åŒºæ»¡æˆ–é‡åˆ° coutè¯­å¥ä¸­çš„ endlï¼›æ­¤æ—¶å°†ç¼“å†²åŒºä¸­å·²æœ‰çš„æ•°æ®ä¸€èµ·è¾“å‡ºï¼Œå¹¶æ¸…ç©ºç¼“å†²åŒºã€‚è¾“å‡ºæµä¸­çš„æ•°æ®åœ¨ç³»ç»Ÿé»˜è®¤çš„è®¾å¤‡( ä¸€èˆ¬ä¸ºæ˜¾ç¤ºå™¨) è¾“å‡ºã€‚ ä¸èƒ½ç”¨ cinè¯­å¥æŠŠç©ºæ ¼å­—ç¬¦å’Œå›è½¦æ¢è¡Œç¬¦ä½œä¸ºå­—ç¬¦è¾“å…¥ç»™å­—ç¬¦å˜é‡ï¼Œå®ƒä»¬å°†è¢«è·³è¿‡ã€‚å¦‚æœæƒ³å°†ç©ºæ ¼å­—ç¬¦æˆ–å›è½¦æ¢è¡Œç¬¦(æˆ–ä»»ä½•å…¶ä»–é”®ç›˜ä¸Šçš„å­—ç¬¦)è¾“å…¥ç»™å­—ç¬¦å˜é‡ï¼Œç”¨getcharå‡½æ•°ã€‚åœ¨ç»„ç»‡è¾“å…¥æµæ•°æ®æ—¶ï¼Œè¦ä»”ç»†åˆ†æ cinè¯­å¥ä¸­å˜é‡çš„ç±»å‹ï¼ŒæŒ‰ç…§ç›¸åº”çš„æ ¼å¼è¾“å…¥ï¼Œå¦åˆ™å®¹æ˜“å‡ºé”™ã€‚ C++è¿˜ä¿ç•™äº†Cè¯­è¨€ä¸­ç”¨äºè¾“å…¥å’Œè¾“å‡ºå•ä¸ªå­—ç¬¦çš„å‡½æ•°ï¼Œä½¿ç”¨å¾ˆæ–¹ä¾¿ã€‚å…¶ä¸­æœ€å¸¸ç”¨çš„æœ‰ getcharå‡½æ•°å’Œputcharå‡½æ•°ã€‚åœ¨C è¯­è¨€ä¸­æ˜¯ç”¨ printfå‡½æ•°è¿›è¡Œè¾“å‡ºï¼Œç”¨ scanfå‡½æ•°è¿›è¡Œè¾“å…¥çš„ã€‚ C++ä¿ç•™äº†Cè¯­è¨€çš„è¿™ä¸€ç”¨æ³•ã€‚ å¸¸ç”¨I/Oæµæ§åˆ¶ç¬¦ æè¿° dec è½¬æ¢æ•´æ•°çš„åŸºæ•°ä¸ºåè¿›åˆ¶ oct è½¬æ¢æ•´æ•°çš„åŸºæ•°ä¸ºå…«è¿›åˆ¶ hex è½¬æ¢æ•´æ•°çš„åŸºæ•°ä¸ºåå…­è¿›åˆ¶ showbase åœ¨è¾“å‡ºä¸­æ˜¾ç¤ºåŸºæ•°æŒ‡ç¤ºç¬¦ uppercase åå…­è¿›åˆ¶è¾“å‡ºæ—¶ä¸€å¾‹ç”¨å¤§å†™å­—æ¯ scientific ç§‘å­¦è®¡æ•°æ³•æ˜¾ç¤ºæµ®ç‚¹æ•° fixed å®šç‚¹å°æ•°å½¢å¼æ˜¾ç¤ºæµ®ç‚¹æ•° showpoint æŠŠå¸¦æœ‰å°æ•°ç‚¹çš„æµ®ç‚¹æ•°å€¼è¾“å…¥åˆ°æµä¸­ showpos æ­£æ•´æ•°å‰å¸¦æœ‰&quot;+&quot;å· unitbuf è¾“å‡ºæ“ä½œåç«‹å³åˆ·æ–°æµ left è¾“å‡ºæ•°æ®åœ¨æœ¬åŸŸå®½èŒƒå›´å†…å·¦å¯¹é½ right è¾“å‡ºæ•°æ®åœ¨æœ¬åŸŸå®½èŒƒå›´å†…å³å¯¹é½ ç‰ˆæƒå£°æ˜ï¼šæœ¬æ–‡ä¸ºCSDNåšä¸»ã€Œäº²äº²Friendsã€çš„åŸåˆ›æ–‡ç«  åœ¨C++ä¸‹ï¼Œè‹¥è¦ä½¿ç”¨Cä¸­å·²æœ‰åº“ä¸­çš„å‡½æ•°å¦‚stdioï¼Œæ–‡ä»¶åŒ…å«æ–¹å¼ä¸ºå‰é¢åŠ ä¸€ä¸ªcï¼ŒåŒæ—¶å»æ‰.håç¼€ï¼Œå¦‚#include &lt; cstdio &gt;ï¼ŒåŒæ—¶å¿…é¡»åŠ ä¸Šusing namaspace;å¯¹äºå…¶ä»–ç±»ä¼¼çš„å‡½æ•°åŒæ · å¯¹äºC++ç‰¹æœ‰çš„åº“ï¼Œç›´æ¥ç”¨å»æ‰.håç¼€çš„æ–‡ä»¶åŒ…å«ï¼Œå¹¶åŠ ä¸Šusing namaspace &quot;.h&quot;å¤´æ–‡ä»¶å°†æ‰€æœ‰åå­—æ”¾åœ¨global namespaceä¸­ï¼Œåœ¨æ–°çš„æ–¹å¼ä¸‹ï¼ˆæŒ‡çš„æ˜¯è¯¸å¦‚cstdioè¿™æ ·çš„å¤´æ–‡ä»¶ï¼‰ï¼Œåå­—æ˜¯æ”¾åœ¨namespace stdä¸­çš„ã€‚å› æ­¤ï¼Œæ–°çš„æ–¹å¼æ˜¯æ‰€æœ‰åº”ç”¨æ¨èçš„æ–¹å¼ï¼Œé™¤éæ˜¯è¦ç¼–å†™ä¸Cä¸¥æ ¼å…¼å®¹çš„ç¨‹åº Standard Template Library-STL æ ‡å‡†æ¨¡æ¿åº“ï¼ˆStandard Template Libraryï¼ŒSTLï¼‰æ˜¯æƒ æ™®å®éªŒå®¤å¼€å‘çš„ä¸€ç³»åˆ—è½¯ä»¶çš„ç»Ÿç§°ã€‚STLçš„ä»£ç ä»å¹¿ä¹‰ä¸Šè®²åˆ†ä¸ºä¸‰ç±»ï¼šalgorithmï¼ˆç®—æ³•ï¼‰ã€containerï¼ˆå®¹å™¨ï¼‰å’Œiteratorï¼ˆè¿­ä»£å™¨ï¼‰ï¼›åœ¨C++æ ‡å‡†ä¸­ï¼ŒSTLè¢«ç»„ç»‡ä¸ºä¸‹é¢çš„13ä¸ªå¤´æ–‡ä»¶ï¼šã€ã€ã€ã€ã€ã€ã€ã€ã€ã€ã€å’Œã€‚ C++ å¯¹æ¨¡æ¿ï¼ˆTemplateï¼‰æ”¯æŒå¾—å¾ˆå¥½ï¼ŒSTL å°±æ˜¯å€ŸåŠ©æ¨¡æ¿æŠŠå¸¸ç”¨çš„æ•°æ®ç»“æ„åŠå…¶ç®—æ³•éƒ½å®ç°äº†ä¸€éï¼Œå¹¶ä¸”åšåˆ°äº†æ•°æ®ç»“æ„å’Œç®—æ³•çš„åˆ†ç¦»ã€‚STLå°è£…äº†å¾ˆå¤šå®ç”¨çš„å®¹å™¨ï¼Œçœæ—¶çœåŠ›ï¼Œèƒ½å¤Ÿè®©ä½ å°†æ›´å¤šå¿ƒæ€æ”¾åˆ°è§£å†³é—®é¢˜çš„æ­¥éª¤ä¸Šï¼Œè€Œéè´¹åŠ›å»å®ç°æ•°æ®ç»“æ„è¯¸å¤šç»†èŠ‚ä¸Šï¼Œåƒæäº†ç”¨pythonæ—¶å€™çš„é…£ç•…æ·‹æ¼“ã€‚ P.S. å¦‚æœä½ å¯¹STLæºç é¢‡æœ‰å…´è¶£ï¼Œé‚£ä½ ä¸å¦¨æ‹œè¯»C++å¤§å¸ˆä¾¯æ·çš„æ°ä½œã€ŠSTLæºç å‰–æã€‹ã€‚ STLæ˜¯æé«˜C++ç¼–å†™æ•ˆç‡çš„ä¸€ä¸ªåˆ©å™¨. STLå…­å¤§éƒ¨ä»¶ å®¹å™¨ï¼ˆContainersï¼‰ åˆ†é…å™¨ï¼ˆAllocatorsï¼‰ ç®—æ³•ï¼ˆAlgorithmï¼‰ è¿­ä»£å™¨ï¼ˆIteratorsï¼‰ é€‚é…å™¨ï¼ˆAdaptersï¼‰ ä»¿å‡½æ•°ï¼ˆFunctorsï¼‰ vector #include &lt; vector &gt; vectoræ˜¯å˜é•¿æ•°ç»„ï¼Œæ”¯æŒéšæœºè®¿é—®ï¼Œä¸æ”¯æŒåœ¨ä»»æ„ä½ç½®O(1)æ’å…¥ã€‚ä¸ºäº†ä¿è¯æ•ˆç‡ï¼Œå…ƒç´ çš„å¢åˆ ä¸€èˆ¬åº”è¯¥åœ¨æœ«å°¾è¿›è¡Œã€‚ å£°æ˜: \\#include &lt; vector &gt; å¤´æ–‡ä»¶ //å¼•ç”¨vectoræ˜¯å¿…é¡»åœ¨å¤´æ–‡ä»¶æ·»åŠ çš„ vector&lt; int &gt; a; ç›¸å½“äºä¸€ä¸ªé•¿åº¦åŠ¨æ€å˜åŒ–çš„intæ•°ç»„ //åˆå§‹åŒ–åŠ¨æ€æ•°ç»„ vector&lt; int &gt; b[233]; ç›¸å½“äºç¬¬ä¸€ç»´é•¿233ï¼Œç¬¬äºŒç»´é•¿åº¦åŠ¨æ€å˜åŒ–çš„intæ•°ç»„ struct rec{â€¦}; vector&lt; rec &gt; c; è‡ªå®šä¹‰çš„ç»“æ„ä½“ç±»å‹ä¹Ÿå¯ä»¥ä¿å­˜åœ¨vectorä¸­ //ç»“æ„ä½“æ•°ç»„ size/empty sizeå‡½æ•°è¿”å›vectorçš„å®é™…é•¿åº¦ï¼ˆåŒ…å«çš„å…ƒç´ ä¸ªæ•°ï¼‰ï¼Œemptyå‡½æ•°è¿”å›ä¸€ä¸ªboolç±»å‹ï¼Œè¡¨æ˜vectoræ˜¯å¦ä¸ºç©ºã€‚äºŒè€…çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯O(1)ã€‚ -&gt; æ‰€æœ‰çš„STLå®¹å™¨éƒ½æ”¯æŒè¿™ä¸¤ä¸ªæ–¹æ³•ï¼Œå«ä¹‰ä¹Ÿç›¸åŒï¼Œä¹‹åæˆ‘ä»¬å°±ä¸å†é‡å¤ç»™å‡ºã€‚ lear clearå‡½æ•°æŠŠvectoræ¸…ç©ºã€‚ è¿­ä»£å™¨ è¿­ä»£å™¨å°±åƒSTLå®¹å™¨çš„â€œæŒ‡é’ˆâ€ï¼Œå¯ä»¥ç”¨æ˜Ÿå·â€œ*â€æ“ä½œç¬¦è§£é™¤å¼•ç”¨ã€‚ ä¸€ä¸ªä¿å­˜intçš„vectorçš„è¿­ä»£å™¨å£°æ˜æ–¹æ³•ä¸ºï¼š vector&lt; int &gt;::iterator it; vector&lt; int &gt;::iteratoræ˜¯è¿­ä»£å™¨å¼•ç”¨ï¼Œitæ˜¯è¿­ä»£å™¨çš„å‘½åã€‚ vectorçš„è¿­ä»£å™¨æ˜¯â€œéšæœºè®¿é—®è¿­ä»£å™¨â€ï¼Œå¯ä»¥æŠŠvectorçš„è¿­ä»£å™¨ä¸ä¸€ä¸ªæ•´æ•°ç›¸åŠ å‡ï¼Œå…¶è¡Œä¸ºå’ŒæŒ‡é’ˆçš„ç§»åŠ¨ç±»ä¼¼ã€‚å¯ä»¥æŠŠvectorçš„ä¸¤ä¸ªè¿­ä»£å™¨ç›¸å‡ï¼Œå…¶ç»“æœä¹Ÿå’ŒæŒ‡é’ˆç›¸å‡ç±»ä¼¼ï¼Œå¾—åˆ°ä¸¤ä¸ªè¿­ä»£å™¨å¯¹åº”ä¸‹æ ‡ä¹‹é—´çš„è·ç¦»ã€‚ begin/end beginå‡½æ•°è¿”å›æŒ‡å‘vectorä¸­ç¬¬ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨ã€‚ä¾‹å¦‚aæ˜¯ä¸€ä¸ªéç©ºçš„vectorï¼Œåˆ™***a.begin()ä¸a[0]**çš„ä½œç”¨ç›¸åŒã€‚ æ‰€æœ‰çš„å®¹å™¨éƒ½å¯ä»¥è§†ä½œä¸€ä¸ªâ€œå‰é—­åå¼€â€çš„ç»“æ„ï¼Œendå‡½æ•°è¿”å›vectorçš„å°¾éƒ¨ï¼Œå³ç¬¬nä¸ªå…ƒç´ å†å¾€åçš„â€œè¾¹ç•Œâ€ã€‚*a.end()ä¸a[n]éƒ½æ˜¯è¶Šç•Œè®¿é—®ï¼Œå…¶ä¸­n=a.size()ã€‚ front/back frontå‡½æ•°è¿”å›vectorçš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œç­‰ä»·äº*a.begin() å’Œ a[0]ã€‚ backå‡½æ•°è¿”å›vectorçš„æœ€åä¸€ä¸ªå…ƒç´ ï¼Œç­‰ä»·äº*==a.end() å’Œ a[a.size() â€“ 1]ã€‚ push_back() and pop_back() a.push_back(x) æŠŠå…ƒç´ xæ’å…¥åˆ°vector açš„å°¾éƒ¨ã€‚ b.pop_back() åˆ é™¤vector açš„æœ€åä¸€ä¸ªå…ƒç´ ã€‚ queue #include &lt; queue &gt; å¤´æ–‡ä»¶queueä¸»è¦åŒ…æ‹¬å¾ªç¯é˜Ÿåˆ—queueå’Œä¼˜å…ˆé˜Ÿåˆ—priority_queueä¸¤ä¸ªå®¹å™¨ã€‚ å£°æ˜ queue&lt; int &gt; q; struct rec{â€¦}; queue&lt; rec &gt; q; //ç»“æ„ä½“recä¸­å¿…é¡»å®šä¹‰å°äºå· priority_queue&lt; int &gt; q; // å¤§æ ¹å † priority_queue&lt;int, vector&lt; int &gt;, greater&lt; int &gt; q; // å°æ ¹å † priority_queue&lt;pair&lt;int, int&gt;&gt;q; å¾ªç¯é˜Ÿåˆ— queue push ä»é˜Ÿå°¾æ’å…¥ pop ä»é˜Ÿå¤´å¼¹å‡º front è¿”å›é˜Ÿå¤´å…ƒç´  back è¿”å›é˜Ÿå°¾å…ƒç´  ä¼˜å…ˆé˜Ÿåˆ— priority_queue push æŠŠå…ƒç´ æ’å…¥å † pop åˆ é™¤å †é¡¶å…ƒç´  top æŸ¥è¯¢å †é¡¶å…ƒç´ ï¼ˆæœ€å¤§å€¼ï¼‰ stack #include &lt; stack &gt; å¤´æ–‡ä»¶stackåŒ…å«æ ˆã€‚ å£°æ˜ stack&lt; int &gt; st; push å‘æ ˆé¡¶æ’å…¥ pop å¼¹å‡ºæ ˆé¡¶å…ƒç´  deque #include &lt; deque &gt; åŒç«¯é˜Ÿåˆ—dequeæ˜¯ä¸€ä¸ªæ”¯æŒåœ¨ä¸¤ç«¯é«˜æ•ˆæ’å…¥æˆ–åˆ é™¤å…ƒç´ çš„è¿ç»­çº¿æ€§å­˜å‚¨ç©ºé—´ã€‚å®ƒå°±åƒæ˜¯vectorå’Œqueueçš„ç»“åˆã€‚ä¸vectorç›¸æ¯”ï¼Œdequeåœ¨å¤´éƒ¨å¢åˆ å…ƒç´ ä»…éœ€è¦O(1)çš„æ—¶é—´ï¼›ä¸queueç›¸æ¯”ï¼Œdequeåƒæ•°ç»„ä¸€æ ·æ”¯æŒéšæœºè®¿é—®ã€‚ begin/end è¿”å›dequeçš„å¤´/å°¾è¿­ä»£å™¨ front/back é˜Ÿå¤´/é˜Ÿå°¾å…ƒç´  push_back ä»é˜Ÿå°¾å…¥é˜Ÿ push_front ä»é˜Ÿå¤´å…¥é˜Ÿ pop_back ä»é˜Ÿå°¾å‡ºé˜Ÿ pop_front ä»é˜Ÿå¤´å‡ºé˜Ÿ clear æ¸…ç©ºé˜Ÿåˆ— set #include &lt; set &gt; å¤´æ–‡ä»¶setä¸»è¦åŒ…æ‹¬setå’Œmultisetä¸¤ä¸ªå®¹å™¨ï¼Œåˆ†åˆ«æ˜¯â€œæœ‰åºé›†åˆâ€å’Œâ€œæœ‰åºå¤šé‡é›†åˆâ€ï¼Œå³å‰è€…çš„å…ƒç´ ä¸èƒ½é‡å¤ï¼Œè€Œåè€…å¯ä»¥åŒ…å«è‹¥å¹²ä¸ªç›¸ç­‰çš„å…ƒç´ ã€‚setå’Œmultisetçš„å†…éƒ¨å®ç°æ˜¯ä¸€æ£µçº¢é»‘æ ‘ï¼Œå®ƒä»¬æ”¯æŒçš„å‡½æ•°åŸºæœ¬ç›¸åŒã€‚ å£°æ˜ set&lt; int &gt; s; struct rec{â€¦}; set&lt; rec &gt; s; // ç»“æ„ä½“recä¸­å¿…é¡»å®šä¹‰å°äºå· multiset&lt; double &gt; s; size/empty/clear ä¸vectorç±»ä¼¼ è¿­ä»£å™¨ setå’Œmultisetçš„è¿­ä»£å™¨ç§°ä¸ºâ€œåŒå‘è®¿é—®è¿­ä»£å™¨â€ï¼Œä¸æ”¯æŒâ€œéšæœºè®¿é—®â€ï¼Œæ”¯æŒæ˜Ÿå·(*)è§£é™¤å¼•ç”¨ï¼Œä»…æ”¯æŒâ€œ++â€å’Œâ€œâ€”â€“â€ä¸¤ä¸ªä¸ç®—æœ¯ç›¸å…³çš„æ“ä½œã€‚ è®¾itæ˜¯ä¸€ä¸ªè¿­ä»£å™¨ï¼Œä¾‹å¦‚set&lt; int &gt;::iterator it; è‹¥æŠŠit++ï¼Œåˆ™itä¼šæŒ‡å‘â€œä¸‹ä¸€ä¸ªâ€å…ƒç´ ã€‚è¿™é‡Œçš„â€œä¸‹ä¸€ä¸ªâ€å…ƒç´ æ˜¯æŒ‡åœ¨å…ƒç´ ä»å°åˆ°å¤§æ’åºçš„ç»“æœä¸­ï¼Œæ’åœ¨itä¸‹ä¸€åçš„å…ƒç´ ã€‚åŒç†ï¼Œè‹¥æŠŠit--ï¼Œåˆ™itå°†ä¼šæŒ‡å‘æ’åœ¨â€œä¸Šä¸€ä¸ªâ€çš„å…ƒç´ ã€‚ begin/end è¿”å›é›†åˆçš„é¦–ã€å°¾è¿­ä»£å™¨ï¼Œæ—¶é—´å¤æ‚åº¦å‡ä¸ºO(1)ã€‚ s.begin() æ˜¯æŒ‡å‘é›†åˆä¸­æœ€å°å…ƒç´ çš„è¿­ä»£å™¨ã€‚ s.end() æ˜¯æŒ‡å‘é›†åˆä¸­æœ€å¤§å…ƒç´ çš„ä¸‹ä¸€ä¸ªä½ç½®çš„è¿­ä»£å™¨ã€‚æ¢è¨€ä¹‹ï¼Œå°±åƒvectorä¸€æ ·ï¼Œæ˜¯ä¸€ä¸ªâ€œå‰é—­åå¼€â€çš„å½¢å¼ã€‚å› æ­¤--s.end()æ˜¯æŒ‡å‘é›†åˆä¸­æœ€å¤§å…ƒç´ çš„è¿­ä»£å™¨ã€‚ insert s.insert(x)æŠŠä¸€ä¸ªå…ƒç´ xæ’å…¥åˆ°é›†åˆsä¸­ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(logn)ã€‚ åœ¨setä¸­ï¼Œè‹¥å…ƒç´ å·²å­˜åœ¨ï¼Œåˆ™ä¸ä¼šé‡å¤æ’å…¥è¯¥å…ƒç´ ï¼Œå¯¹é›†åˆçš„çŠ¶æ€æ— å½±å“ã€‚ find s.find(x) åœ¨é›†åˆsä¸­æŸ¥æ‰¾ç­‰äºxçš„å…ƒç´ ï¼Œå¹¶è¿”å›æŒ‡å‘è¯¥å…ƒç´ çš„è¿­ä»£å™¨ã€‚è‹¥ä¸å­˜åœ¨ï¼Œåˆ™è¿”å›s.end()ã€‚æ—¶é—´å¤æ‚åº¦ä¸ºO(logn)ã€‚ lower_bound/upper_bound è¿™ä¸¤ä¸ªå‡½æ•°çš„ç”¨æ³•ä¸findç±»ä¼¼ï¼Œä½†æŸ¥æ‰¾çš„æ¡ä»¶ç•¥æœ‰ä¸åŒï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(logn)ã€‚ s.lower_bound(x) æŸ¥æ‰¾å¤§äºç­‰äºxçš„å…ƒç´ ä¸­æœ€å°çš„ä¸€ä¸ªï¼Œå¹¶è¿”å›æŒ‡å‘è¯¥å…ƒç´ çš„è¿­ä»£å™¨ã€‚ s.upper_bound(x) æŸ¥æ‰¾å¤§äºxçš„å…ƒç´ ä¸­æœ€å°çš„ä¸€ä¸ªï¼Œå¹¶è¿”å›æŒ‡å‘è¯¥å…ƒç´ çš„è¿­ä»£å™¨ã€‚ erase è®¾itæ˜¯ä¸€ä¸ªè¿­ä»£å™¨ï¼Œs.erase(it) ä»sä¸­åˆ é™¤è¿­ä»£å™¨itæŒ‡å‘çš„å…ƒç´ ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(logn) è®¾xæ˜¯ä¸€ä¸ªå…ƒç´ ï¼Œs.erase(x) ä»sä¸­åˆ é™¤æ‰€æœ‰ç­‰äºxçš„å…ƒç´ ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(k+logn)ï¼Œå…¶ä¸­kæ˜¯è¢«åˆ é™¤çš„å…ƒç´ ä¸ªæ•°ã€‚ count s.count(x) è¿”å›é›†åˆsä¸­ç­‰äºxçš„å…ƒç´ ä¸ªæ•°ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(k +logn)ï¼Œå…¶ä¸­kä¸ºå…ƒç´ xçš„ä¸ªæ•°ã€‚ map #include &lt; map &gt; mapå®¹å™¨æ˜¯ä¸€ä¸ªé”®å€¼å¯¹key-valueçš„æ˜ å°„ï¼Œå…¶å†…éƒ¨å®ç°æ˜¯ä¸€æ£µä»¥keyä¸ºå…³é”®ç çš„çº¢é»‘æ ‘ã€‚Mapçš„keyå’Œvalueå¯ä»¥æ˜¯ä»»æ„ç±»å‹ï¼Œå…¶ä¸­keyå¿…é¡»å®šä¹‰å°äºå·è¿ç®—ç¬¦ã€‚ç±»æ¯”Pythonä¸­çš„å­—å…¸ å£°æ˜ map&lt;key_type, value_type&gt; name; ä¾‹å¦‚ï¼š map&lt;long, long, bool&gt; vis; -&gt;map&lt;string, int&gt; hash;//å“ˆå¸Œç»“æ„é‡ç‚¹ç†è§£ï¼Œç†Ÿç»ƒè¿ç”¨ map&lt;pair&lt;int, int&gt;, vector&lt;int&gt;&gt; test; size/empty/clear/begin/end å‡ä¸setç±»ä¼¼ insert/erase ä¸setç±»ä¼¼ï¼Œä½†å…¶å‚æ•°å‡æ˜¯pair&lt;key_type, value_type&gt; find h.find(x) åœ¨å˜é‡åä¸ºhçš„mapä¸­æŸ¥æ‰¾keyä¸ºxçš„äºŒå…ƒç»„ã€‚ []æ“ä½œç¬¦ hash[key] è¿”å›keyæ˜ å°„çš„valueçš„å¼•ç”¨ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºO(logn)ã€‚ []æ“ä½œç¬¦æ˜¯mapæœ€å¸å¼•äººçš„åœ°æ–¹ã€‚æˆ‘ä»¬å¯ä»¥å¾ˆæ–¹ä¾¿åœ°é€šè¿‡hash[key]æ¥å¾—åˆ°keyå¯¹åº”çš„valueï¼Œè¿˜å¯ä»¥å¯¹h[key]è¿›è¡Œèµ‹å€¼æ“ä½œï¼Œæ”¹å˜keyå¯¹åº”çš„valueã€‚ å¸¸ç”¨åº“å‡½æ•° å¸¸ç”¨åº“å‡½æ•° ä¸‡èƒ½å¤´æ–‡ä»¶ #include&lt;bits/stdc++.h&gt; #include&lt; algorithm &gt; reverse ç¿»è½¬ ç¿»è½¬ä¸€ä¸ªvectorï¼š reverse(a.begin(), a.end()); ç¿»è½¬ä¸€ä¸ªæ•°ç»„ï¼Œå…ƒç´ å­˜æ”¾åœ¨ä¸‹æ ‡1~nï¼š reverse(a + 1, a + 1 + n); unique å»é‡ è¿”å›å»é‡ä¹‹åçš„å°¾è¿­ä»£å™¨ï¼ˆæˆ–æŒ‡é’ˆï¼‰ï¼Œä»ç„¶ä¸ºå‰é—­åå¼€ï¼Œå³è¿™ä¸ªè¿­ä»£å™¨æ˜¯å»é‡ä¹‹åæœ«å°¾å…ƒç´ çš„ä¸‹ä¸€ä¸ªä½ç½®ã€‚è¯¥å‡½æ•°å¸¸ç”¨äºç¦»æ•£åŒ–ï¼Œåˆ©ç”¨è¿­ä»£å™¨ï¼ˆæˆ–æŒ‡é’ˆï¼‰çš„å‡æ³•ï¼Œå¯è®¡ç®—å‡ºå»é‡åçš„å…ƒç´ ä¸ªæ•°ã€‚ æŠŠä¸€ä¸ªvectorå»é‡ï¼š int m = unique(a.begin(), a.end()) â€“ a.begin(); æŠŠä¸€ä¸ªæ•°ç»„å»é‡ï¼Œå…ƒç´ å­˜æ”¾åœ¨ä¸‹æ ‡1~nï¼š int m = unique(a + 1, a + 1 + n) â€“ (a + 1); random_shuffle éšæœºæ‰“ä¹± ç”¨æ³•ä¸reverseç›¸åŒ sort å¯¹ä¸¤ä¸ªè¿­ä»£å™¨ï¼ˆæˆ–æŒ‡é’ˆï¼‰æŒ‡å®šçš„éƒ¨åˆ†è¿›è¡Œå¿«é€Ÿæ’åºã€‚å¯ä»¥åœ¨ç¬¬ä¸‰ä¸ªå‚æ•°ä¼ å…¥å®šä¹‰å¤§å°æ¯”è¾ƒçš„å‡½æ•°ï¼Œæˆ–è€…é‡è½½â€œå°äºå·â€è¿ç®—ç¬¦ã€‚ æŠŠä¸€ä¸ªintæ•°ç»„ï¼ˆå…ƒç´ å­˜æ”¾åœ¨ä¸‹æ ‡1~nï¼‰ä»å¤§åˆ°å°æ’åºï¼Œä¼ å…¥æ¯”è¾ƒå‡½æ•°ï¼š int a[MAX_SIZE]; bool cmp(int a, int b) {return a &gt; b; } sort(a + 1, a + 1 + n, cmp); æŠŠè‡ªå®šä¹‰çš„ç»“æ„ä½“vectoræ’åºï¼Œé‡è½½â€œå°äºå·â€è¿ç®—ç¬¦ï¼š struct rec{ int id, x, y; } vector&lt; rec &gt; a; bool operator &lt;(const rec &amp;a, const rec &amp;b) { return a.x &lt; b.x || a.x == b.x &amp;&amp; a.y &lt; b.y; } sort(a.begin(), a.end()); lower_bound/upper_bound äºŒåˆ† lower_bound çš„ç¬¬ä¸‰ä¸ªå‚æ•°ä¼ å…¥ä¸€ä¸ªå…ƒç´ xï¼Œåœ¨ä¸¤ä¸ªè¿­ä»£å™¨ï¼ˆæŒ‡é’ˆï¼‰æŒ‡å®šçš„éƒ¨åˆ†ä¸Šæ‰§è¡ŒäºŒåˆ†æŸ¥æ‰¾ï¼Œè¿”å›æŒ‡å‘ç¬¬ä¸€ä¸ªå¤§äºç­‰äºxçš„å…ƒç´ çš„ä½ç½®çš„è¿­ä»£å™¨ï¼ˆæŒ‡é’ˆï¼‰ã€‚ upper_bound çš„ç”¨æ³•å’Œlower_boundå¤§è‡´ç›¸åŒï¼Œå”¯ä¸€çš„åŒºåˆ«æ˜¯æŸ¥æ‰¾ç¬¬ä¸€ä¸ªå¤§äºxçš„å…ƒç´ ã€‚å½“ç„¶ï¼Œä¸¤ä¸ªè¿­ä»£å™¨ï¼ˆæŒ‡é’ˆï¼‰æŒ‡å®šçš„éƒ¨åˆ†åº”è¯¥æ˜¯æå‰æ’å¥½åºçš„ã€‚ åœ¨æœ‰åºintæ•°ç»„ï¼ˆå…ƒç´ å­˜æ”¾åœ¨ä¸‹æ ‡1~nï¼‰ä¸­æŸ¥æ‰¾å¤§äºç­‰äºxçš„æœ€å°æ•´æ•°çš„ä¸‹æ ‡ï¼š int I = lower_bound(a + 1, a + 1 + n,x) â€“ a; åœ¨æœ‰åºvector&lt; int &gt; ä¸­æŸ¥æ‰¾å°äºç­‰äºxçš„æœ€å¤§æ•´æ•°ï¼ˆå‡è®¾ä¸€å®šå­˜åœ¨ï¼‰ï¼š int y = *--upper_bound(a.begin(), a.end(), x); stringå‡½æ•° stringçš„æ„é€ å‡½æ•°çš„å½¢å¼ #includeå¼•å…¥ç¬¬ä¸‰æ–¹åº“ï¼Œåº“ä¸­å¸¸ç”¨çš„æ–¹æ³•ï¼š string strï¼šç”Ÿæˆç©ºå­—ç¬¦ä¸² string s(str)ï¼šç”Ÿæˆå­—ç¬¦ä¸²ä¸ºstrçš„å¤åˆ¶å“ string s(str, strbegin,strlen)ï¼šå°†å­—ç¬¦ä¸²strä¸­ä»ä¸‹æ ‡strbeginå¼€å§‹ã€é•¿åº¦ä¸ºstrlençš„éƒ¨åˆ†ä½œä¸ºå­—ç¬¦ä¸²åˆå€¼ string s(cstr, char_len)ï¼šä»¥C_stringç±»å‹cstrçš„å‰char_lenä¸ªå­—ç¬¦ä¸²ä½œä¸ºå­—ç¬¦ä¸²sçš„åˆå€¼ string s(num ,c)ï¼šç”Ÿæˆnumä¸ªcå­—ç¬¦çš„å­—ç¬¦ä¸² string s(str, stridx)ï¼šå°†å­—ç¬¦ä¸²strä¸­ä»ä¸‹æ ‡stridxå¼€å§‹åˆ°å­—ç¬¦ä¸²ç»“æŸçš„ä½ç½®ä½œä¸ºå­—ç¬¦ä¸²åˆå€¼ stringçš„å¤§å°å’Œå®¹é‡ï¼š **size()**å’Œlength()ï¼šè¿”å›stringå¯¹è±¡çš„å­—ç¬¦ä¸ªæ•°ï¼Œä»–ä»¬æ‰§è¡Œæ•ˆæœç›¸åŒã€‚ max_size()ï¼šè¿”å›stringå¯¹è±¡æœ€å¤šåŒ…å«çš„å­—ç¬¦æ•°ï¼Œè¶…å‡ºä¼šæŠ›å‡ºlength_errorå¼‚å¸¸ capacity()ï¼šé‡æ–°åˆ†é…å†…å­˜ä¹‹å‰ï¼Œstringå¯¹è±¡èƒ½åŒ…å«çš„æœ€å¤§å­—ç¬¦æ•° stringçš„å­—ç¬¦ä¸²æ¯”è¾ƒï¼š C ++å­—ç¬¦ä¸²æ”¯æŒå¸¸è§çš„æ¯”è¾ƒæ“ä½œç¬¦ï¼ˆ&gt;,&gt;=,&lt;,&lt;=,==,!=ï¼‰ï¼Œç”šè‡³æ”¯æŒstringä¸C-stringçš„æ¯”è¾ƒã€‚åœ¨ä½¿ç”¨&gt;,&gt;=,&lt;,&lt;=è¿™äº›æ“ä½œç¬¦çš„æ—¶å€™ï¼Œæ ¹æ®â€œå½“å‰å­—ç¬¦ç‰¹æ€§â€å°†å­—ç¬¦æŒ‰å­—å…¸é¡ºåºè¿›è¡Œé€ä¸€å¾— æ¯”è¾ƒã€‚å­—å…¸æ’åºé å‰çš„å­—ç¬¦å°ï¼Œæ¯”è¾ƒçš„é¡ºåºæ˜¯ä»å‰å‘åæ¯”è¾ƒï¼Œé‡åˆ°ä¸ç›¸ç­‰çš„å­—ç¬¦å°±æŒ‰è¿™ä¸ªä½ç½®ä¸Šçš„ä¸¤ä¸ªå­—ç¬¦çš„æ¯”è¾ƒç»“æœç¡®å®šä¸¤ä¸ªå­—ç¬¦ä¸²çš„å¤§å°(å‰é¢å‡åé¢)ã€‚ å¦ä¸€ä¸ªåŠŸèƒ½å¼ºå¤§çš„æ¯”è¾ƒå‡½æ•°æ˜¯æˆå‘˜å‡½æ•°compare()ã€‚ä»–æ”¯æŒå¤šå‚æ•°å¤„ç†ï¼Œæ”¯æŒç”¨ç´¢å¼•å€¼å’Œé•¿åº¦å®šä½å­ä¸²æ¥è¿›è¡Œæ¯”è¾ƒã€‚ ä»–è¿”å›ä¸€ä¸ªæ•´æ•°æ¥è¡¨ç¤ºæ¯”è¾ƒç»“æœï¼Œè¿”å›å€¼æ„ä¹‰å¦‚ä¸‹ï¼š0ï¼šç›¸ç­‰ 1ï¼šå¤§äº -1ï¼šå°äº stringçš„æ’å…¥ï¼špush_back() å’Œ insert() push_back(â€˜æ’å…¥çš„å­—ç¬¦â€™)æ˜¯å°¾æ’å…¥æ³• insert(s.begin(),â€˜æ’å…¥çš„å­—ç¬¦â€™)æ˜¯ç‰¹æ®Šä½ç½®çš„æ’å…¥æ³• // æ–¹æ³•ä¸€ï¼šappend() string s1(&quot;abc&quot;); s1.append(&quot;def&quot;); cout&lt;&lt;&quot;s1:&quot;&lt;&lt;s1&lt;&lt;endl; // s1:abcdef // æ–¹æ³•äºŒï¼š+ æ“ä½œç¬¦ string s2 = &quot;abc&quot;; /*s2 += &quot;def&quot;;*/ string s3 = &quot;def&quot;; s2 += s3.c_str(); stringçš„éå†ï¼šå€ŸåŠ©è¿­ä»£å™¨ æˆ–è€… ä¸‹æ ‡æ³• // æ–¹æ³•ä¸€ï¼š ä¸‹æ ‡æ³• for( int i = 0; i &lt; s1.size() ; i++ ) { cout&lt;&lt;s1[i]; } cout&lt;&lt;endl; // æ–¹æ³•äºŒï¼šæ­£å‘è¿­ä»£å™¨ string::iterator iter = s1.begin(); for( ; iter &lt; s1.end() ; iter++) { cout&lt;&lt;*iter; } cout&lt;&lt;endl; // æ–¹æ³•ä¸‰ï¼šåå‘è¿­ä»£å™¨ string::reverse_iterator riter = s1.rbegin(); for( ; riter &lt; s1.rend() ; riter++) { cout&lt;&lt;*riter; } cout&lt;&lt;endl; stringçš„åˆ é™¤ï¼šerase() iterator erase(iterator p);//åˆ é™¤å­—ç¬¦ä¸²ä¸­pæ‰€æŒ‡çš„å­—ç¬¦ iterator erase(iterator first, iterator last);//åˆ é™¤å­—ç¬¦ä¸²ä¸­è¿­ä»£å™¨ åŒºé—´[first,last)ä¸Šæ‰€æœ‰å­—ç¬¦ stringçš„å­—ç¬¦æ›¿æ¢ï¼š string&amp; replace(size_t pos, size_t n, const char *s);//å°†å½“å‰å­—ç¬¦ä¸²ä»posç´¢å¼•å¼€å§‹çš„nä¸ªå­—ç¬¦ï¼Œæ›¿æ¢æˆå­—ç¬¦ä¸²s string&amp; replace(size_t pos, size_t n, size_t n1, char c); //å°†å½“å‰å­—ç¬¦ä¸²ä»posç´¢å¼•å¼€å§‹çš„nä¸ªå­—ç¬¦ï¼Œæ›¿æ¢æˆn1ä¸ªå­—ç¬¦c string&amp; replace(iterator i1, iterator i2, const char* s);//å°†å½“å‰å­—ç¬¦ä¸²[i1,i2)åŒºé—´ä¸­çš„å­—ç¬¦ä¸²æ›¿æ¢ä¸ºå­—ç¬¦ä¸²s stringçš„å¤§å°å†™è½¬æ¢ï¼štolower()å’Œtoupper()å‡½æ•° æˆ–è€… STLä¸­çš„transformç®—æ³• stringçš„æŸ¥æ‰¾ï¼šfind string s(&quot;I like C++ and Python.&quot;); // 1. æŸ¥æ‰¾ä¸€ä¸ªå­—ç¬¦ä¸² cout &lt;&lt; s.find(&quot;chicken&quot;) &lt;&lt; endl; // ç»“æœæ˜¯ï¼š9 // 2. ä»ä¸‹æ ‡ä¸º6å¼€å§‹æ‰¾å­—ç¬¦'i'ï¼Œè¿”å›æ‰¾åˆ°çš„ç¬¬ä¸€ä¸ªiçš„ä¸‹æ ‡ cout &lt;&lt; s.find('i',6) &lt;&lt; endl; // ç»“æœæ˜¯ï¼š11 // 3. ä»å­—ç¬¦ä¸²çš„æœ«å°¾å¼€å§‹æŸ¥æ‰¾å­—ç¬¦ä¸²ï¼Œè¿”å›çš„è¿˜æ˜¯é¦–å­—æ¯åœ¨å­—ç¬¦ä¸²ä¸­çš„ä¸‹æ ‡ cout &lt;&lt; s.rfind(&quot;chicken&quot;) &lt;&lt; endl; // ç»“æœæ˜¯ï¼š9 // 4. ä»å­—ç¬¦ä¸²çš„æœ«å°¾å¼€å§‹æŸ¥æ‰¾å­—ç¬¦ cout &lt;&lt; s.rfind('i') &lt;&lt; endl; // ç»“æœæ˜¯ï¼š18--å› ä¸ºæ˜¯ä»æœ«å°¾å¼€å§‹æŸ¥æ‰¾ï¼Œæ‰€ä»¥è¿”å›ç¬¬ä¸€æ¬¡æ‰¾åˆ°çš„å­—ç¬¦ stringçš„æ’åºï¼šsort(s.begin( ),s.end( )) string s = &quot;cdefba&quot;; sort(s.begin(),s.end()); stringçš„åˆ†å‰²/æˆªå–å­—ç¬¦ä¸²ï¼šstrtok() &amp; substr() string s1(&quot;0123456789&quot;); string s2 = s1.substr(2,5); // ç»“æœï¼š23456-----å‚æ•°5è¡¨ç¤ºï¼šæˆªå–çš„å­—ç¬¦ä¸²çš„é•¿åº¦ ------------------- char str[] = &quot;I,am,a,student; hello world!&quot;; const char *split = &quot;,; !&quot;; char *p2 = strtok(str,split); while( p2 != NULL ) { cout&lt;&lt;p2&lt;&lt;endl; p2 = strtok(NULL,split); } Cè¯­è¨€ä¸­çš„å­—ç¬¦ä¸²å¤„ç†å‡½æ•° strlen å‡½æ•°åŠŸèƒ½ï¼šè®¡ç®—å­—ç¬¦ä¸²str1çš„é•¿åº¦ è¿”å›å€¼ï¼šä¸€ä¸ªintå€¼ æ³¨æ„ï¼šå­—ç¬¦ä¸²çš„é•¿åº¦ä¸åŒ…æ‹¬å­—ç¬¦â€™\\0â€™ char str1[20] = &quot;We are csdn!&quot;; int size = strlen(str1); printf(&quot;%d\\n&quot;, size); //size = 12 strcpy å‡½æ•°åŠŸèƒ½ï¼šå°†å­—ç¬¦ä¸²str2å¤åˆ¶åˆ°å­—ç¬¦ä¸²str1ä¸­ï¼Œå¹¶è¦†ç›–str1åŸå§‹å­—ç¬¦ä¸²ï¼Œå¯ä»¥ç”¨æ¥ä¸ºå­—ç¬¦ä¸²å˜é‡èµ‹å€¼ è¿”å›å€¼ï¼šstr1 æ³¨æ„ï¼š1ï¼‰å­—ç¬¦ä¸²str2ä¼šè¦†ç›–str1ä¸­çš„å…¨éƒ¨å­—ç¬¦ï¼Œ2ï¼‰å­—ç¬¦ä¸²str2çš„é•¿åº¦ä¸èƒ½è¶…è¿‡str1 char str1[] = &quot;We are Chinese!&quot;; char str2[] = &quot;Hello!&quot;; strcpy_s(str1, str2); //str = Hello! strcat åŸå‹ï¼šstrcat(str1,str2); åŠŸèƒ½ï¼šå°†å­—ç¬¦ä¸²str2æ·»åŠ åˆ°å­—ç¬¦ä¸²str1çš„å°¾éƒ¨ï¼Œä¹Ÿå°±æ˜¯æ‹¼æ¥ä¸¤ä¸ªå­—ç¬¦ä¸² åŸå‹2ï¼šstrncat(str1,str2,n); åŠŸèƒ½2ï¼šå°†å­—ç¬¦ä¸²str2çš„å‰nä¸ªå­—ç¬¦æ·»åŠ åˆ°å­—ç¬¦ä¸²str1çš„å°¾éƒ¨ char str1[20] = &quot;We are csdn!&quot;; char str2[] = &quot;Hello!&quot;; strcat_s(str1, str2); printf(&quot;str1 = %s\\n&quot;, str1); //str1 = We are csdn!Hello! strcmp åŸå‹ï¼šstrcmp(str1,str2); åŠŸèƒ½ï¼šæ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œå¦‚æœä¸¤ä¸ªå­—ç¬¦ä¸²ç›¸ç­‰ï¼Œåˆ™è¿”å›0ï¼› è‹¥str1å¤§äºstr2ï¼ˆå¯¹äºå¤§äºçš„ç†è§£ï¼Œæ˜¯æŒ‡ä»ä¸¤ä¸ªå­—ç¬¦ä¸²çš„ç¬¬ä¸€ä¸ªå­—ç¬¦å¼€å§‹æ¯”è¾ƒï¼Œè‹¥ä¸¤ä¸ªå­—ç¬¦ç›¸åŒï¼Œåˆ™ç»§ç»­æ¯”è¾ƒï¼Œè‹¥å‘ç°ä¸¤ä¸ªå­—ç¬¦ä¸ç›¸ç­‰ï¼Œä¸”str1ä¸­è¯¥å­—ç¬¦çš„ASCIIç å¤§äºstr2ä¸­çš„ï¼Œåˆ™è¡¨ç¤ºstr1å¤§äºstr2ï¼‰ï¼Œè¿”å›ä¸€ä¸ªæ­£æ•°ï¼ˆè¿™ä¸ªæ­£æ•°ä¸ä¸€å®šæ˜¯1ï¼‰ï¼› è‹¥str1å°äºstr2ï¼Œè¿”å›ä¸€ä¸ªè´Ÿæ•°ï¼ˆä¸ä¸€å®šæ˜¯-1ï¼‰ï¼›è‹¥å­—ç¬¦ä¸²str1çš„é•¿åº¦å¤§äºstr2ï¼Œä¸”str2çš„å­—ç¬¦ä¸str1å‰é¢çš„å­—ç¬¦ç›¸åŒï¼Œåˆ™ä¹Ÿç›¸å¯¹äºstr1å¤§äºstr2å¤„ç† åŸå‹2ï¼šstrncmp(str1,str2,n); åŠŸèƒ½2ï¼šæ¯”è¾ƒä¸¤ä¸ªå­—ç¬¦ä¸²çš„å‰nä¸ªå­—ç¬¦ char str1[] = &quot;Wearecsdn!&quot;; char str2[] = &quot;Wearecsdn!&quot;; char str3[] = &quot;Wearea!&quot;; char str4[] = &quot;Wearef!&quot;; int cmp1 = strcmp(str1, str2); //cmp1=0 int cmp2 = strcmp(str1, str3); //cmp2=1 int cmp5 = strncmp(str1, str2, 5); //cmp5=0 int cmp6 = strncmp(str1, str3, 5); //cmp6=0 ç¨‹åºä¸­çš„ç§‘å­¦è®¡æ•°æ³• ä»Šå¤©å­¦cçœ‹åˆ°const int a=1e6+10ä¸æ˜¯å¾ˆç†è§£,åŸæ¥æ˜¯ç§‘å­¦è®¡æ•°æ³•çš„è¡¨ç¤ºå½¢å¼ã€‚ const int a=1e6+10=1000010ï¼›1âˆ—106+101*10^6+101âˆ—106+10 6.555e6+10=6555010ï¼›6.555âˆ—106+106.555*10^6+106.555âˆ—106+10 é¢å‘å¯¹è±¡ VS Code åŸºæœ¬é…ç½® ç¼–è¯‘C/C++ç¨‹åº é¦–å…ˆåœ¨è‡ªå·±çš„ç”µè„‘ä¸Šé…ç½®MinGw64ï¼Œä¹‹åå°†å…¶æ·»åŠ åˆ°ç¯å¢ƒå˜é‡å½“ä¸­å»ã€‚ ä¹‹åæ–°å»ºä¸€ä¸ªæ–‡ä»¶å¤¹ï¼Œæ³¨æ„è¦ç”¨è‹±æ–‡å‘½åï¼Œé€šè¿‡vs codeæ‰“å¼€ã€‚ æœ€åå†™ä¸€æ®µç¨‹åºï¼Œåœ¨è¿è¡Œé€‰é¡¹æ é‡Œé€‰æ‹©ä»¥éè°ƒè¯•æ¨¡å¼è¿è¡Œï¼Œç”Ÿæˆ.vs codeæ–‡ä»¶å¤¹ï¼Œé‡Œé¢åŒ…å«äº†launch.jsonå’Œtasks.jsonæ–‡ä»¶ã€‚ launch.jsonæ–‡ä»¶çš„é…ç½®ï¼š { // ä½¿ç”¨ IntelliSense äº†è§£ç›¸å…³å±æ€§ã€‚ // æ‚¬åœä»¥æŸ¥çœ‹ç°æœ‰å±æ€§çš„æè¿°ã€‚ // æ¬²äº†è§£æ›´å¤šä¿¡æ¯ï¼Œè¯·è®¿é—®: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;g++.exe - ç”Ÿæˆå’Œè°ƒè¯•æ´»åŠ¨æ–‡ä»¶&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${fileDirname}\\\\exe\\\\${fileBasenameNoExtension}.exe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;${fileDirname}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;E:\\\\mingw64\\\\bin\\\\gdb.exe&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;ä¸º gdb å¯ç”¨æ•´é½æ‰“å°&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true }, { &quot;description&quot;: &quot;å°†åæ±‡ç¼–é£æ ¼è®¾ç½®ä¸º Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true } ], &quot;preLaunchTask&quot;: &quot;C/C++: g++.exe ç”Ÿæˆæ´»åŠ¨æ–‡ä»¶&quot; } ] } tasks.jsonæ–‡ä»¶çš„é…ç½®ï¼š { &quot;tasks&quot;: [ { &quot;type&quot;: &quot;cppbuild&quot;, &quot;label&quot;: &quot;C/C++: g++.exe ç”Ÿæˆæ´»åŠ¨æ–‡ä»¶&quot;, &quot;command&quot;: &quot;E:\\\\mingw64\\\\bin\\\\g++.exe&quot;, &quot;args&quot;: [ &quot;-fdiagnostics-color=always&quot;, &quot;-g&quot;, &quot;${file}&quot;, &quot;-o&quot;, &quot;${fileDirname}\\\\exe\\\\${fileBasenameNoExtension}.exe&quot;, &quot;-fexec-charset=GBK&quot; ], &quot;options&quot;: { &quot;cwd&quot;: &quot;${fileDirname}&quot; }, &quot;problemMatcher&quot;: [ &quot;$gcc&quot; ], &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true }, &quot;detail&quot;: &quot;è°ƒè¯•å™¨ç”Ÿæˆçš„ä»»åŠ¡ã€‚&quot; } ], &quot;version&quot;: &quot;2.0.0&quot; } å¸¸è§é”™è¯¯ undefined reference to 'WinMain' collect2.exe: error: ld returned 1 exit status è§£å†³åŠæ³•ï¼šæ²¡æœ‰åœ¨c/cppæ–‡ä»¶ä¸­å†™å‡ºmainå‡½æ•°,è€Œä¸”mainåˆ«å†™é”™ï¼ï¼ ç¼–è¯‘Pythonç¨‹åº-jupyter lab ç»å…¸æ¦‚å¿µè¾¨æ ç¼–è¯‘å™¨æ˜¯å¯¹ä»£ç è¿›è¡Œç¼–è¯‘ï¼Œè½¬æ¢ä¸ºåŒ…å«åœ¨ç›®æ ‡æ–‡ä»¶ä¸­çš„æœºå™¨è¯­è¨€ç‰ˆæœ¬(å­—èŠ‚ç )ï¼Œç”Ÿæˆæ‰©å±•åä¸º.o/.objçš„ç›®æ ‡æ–‡ä»¶ï¼›è§£é‡Šå™¨æ˜¯ æ ‡è¯†ç¬¦å’Œå…³é”®å­— æ ‡è¯†ç¬¦ï¼šç¼–å†™ç¨‹åºæ—¶ä½¿ç”¨å­—ç¬¦é›†ä¸­çš„å­—ç¬¦ç»„åˆæˆä¸€ç³»åˆ—â€œå•è¯â€ä»£è¡¨å˜é‡ã€å¸¸é‡ã€å‡½æ•°ç­‰ã€‚ç”¨äºå£°æ˜çš„è¿™äº›â€œå•è¯â€ç§°ä¸ºæ ‡è¯†ç¬¦ã€‚ ç”¨æˆ·è‡ªå®šä¹‰çš„æ ‡è¯†ç¬¦ï¼šç”±ç¨‹åºå‘˜å®šä¹‰è¯´æ˜çš„æ ‡è¯†ç¬¦ï¼ŒåŒ…æ‹¬ç¨‹åºä¸­ä½¿ç”¨çš„å˜é‡åã€ç¬¦å·å¸¸é‡åã€å‡½æ•°åã€ç»“æ„ä½“ç±»å‹åã€å…±ç”¨ä½“ç±»å‹åç­‰ã€‚ è‡ªå®šä¹‰æ ‡è¯†ç¬¦çš„å®šä¹‰éµå¾ªè§„åˆ™ï¼š åªç”±è‹±æ–‡ã€æ•°å­—ã€æˆ– _ï¼ˆä¸‹åˆ’çº¿ï¼‰ ç»„æˆ ç¬¬ä¸€ä¸ªå­—ç¬¦åªèƒ½æ˜¯è‹±æ–‡å­—æ¯æˆ–ä¸‹åˆ’çº¿ï¼Œä¸èƒ½æ˜¯æ•°å­— å¤§å°å†™è‹±æ–‡å­—æ¯ä»£è¡¨ä¸åŒçš„å­—ç¬¦ ä¸èƒ½æ˜¯C/C++è¯­è¨€çš„å…³é”®å­— å…³é”®å­—ï¼šç³»ç»Ÿé¢„å®šè¯´æ˜çš„æ ‡è¯†ç¬¦ç§°ä¸ºå…³é”®å­— 1.æ•°æ®ç±»å‹å…³é”®å­— charã€intã€shortã€longã€floatã€doubleã€signedã€unsignedã€structã€unionã€enumã€void 2.å­˜å‚¨ç±»å‹å…³é”®å­— autoã€registerã€staticã€extern 3.æµç¨‹æ§åˆ¶å…³é”®å­— ifã€elseã€switchã€defaultã€caseã€whileã€doã€forã€breakã€continueã€returnã€goto 4.å…¶ä»–å…³é”®å­— sizeofã€typedefã€constã€volatile æ­£ç¡®æ ‡è¯†ç¬¦å‘½åï¼š smart _decision high3 Area ä¸æ­£ç¡®æ ‡è¯†ç¬¦å‘½åï¼š5smart(ä»¥æ•°å­—å¼€å¤´) Bomb?(å«æœ‰ç‰¹æ®Šå­—ç¬¦ï¼Ÿ) High.balance(æŠŠä¸‹åˆ’çº¿â€œ_â€ä¸â€œ.â€æ··æ·†) floatï¼ˆä¸èƒ½ç”¨Cè¯­è¨€ä¸­çš„å…³é”®å­—ï¼‰ å˜é‡çš„å£°æ˜å’Œå®šä¹‰ å£°æ˜çš„ä¸¤ç§æ–¹å¼ï¼š ä¸€ç§æ˜¯éœ€è¦å»ºç«‹å­˜å‚¨ç©ºé—´çš„ï¼š ä¾‹å¦‚ï¼šint a ;åœ¨å£°æ˜çš„æ—¶å€™å°±å·²ç»å»ºç«‹äº†å­˜å‚¨ç©ºé—´ã€‚è¿™ç§å£°æ˜æ˜¯â€å®šä¹‰æ€§å£°æ˜(defining declaration)â€ï¼Œå³æˆ‘ä»¬å¹³æ—¶æ‰€è¯´çš„â€œå®šä¹‰â€ã€‚ å¦ä¸€ç§æ˜¯ä¸éœ€è¦å»ºç«‹å­˜å‚¨ç©ºé—´çš„ï¼š åªæ˜¯å‘Šè¯‰ç¼–è¯‘å™¨æŸå˜é‡å·²ç»åœ¨åˆ«å¤„å®šä¹‰è¿‡äº†ã€‚ä¾‹å¦‚ï¼šextern int aã€‚å…¶ä¸­ï¼Œå˜é‡aæ˜¯åœ¨åˆ«å¤„å®šä¹‰çš„ã€‚è¿™ç§å£°æ˜æ˜¯â€å¼•ç”¨æ€§å£°æ˜(referncing declaration)â€ï¼Œå³æˆ‘ä»¬å¹³æ—¶æ‰€è¯´çš„â€œå£°æ˜â€ã€‚ ä¾‹å­ï¼š int a; //å®šä¹‰æ€§å£°æ˜ï¼Œåˆ†é…å­˜å‚¨ç©ºé—´ï¼Œåˆå€¼ä¸ç¡®å®š int b = 0; //å®šä¹‰æ€§å£°æ˜ï¼Œåˆ†é…å­˜å‚¨ç©ºé—´ï¼Œèµ‹åˆå€¼ extern int c; //å¼•ç”¨æ€§å£°æ˜ï¼Œä¸åˆ†é…å­˜å‚¨ç©ºé—´ï¼Œåªæ˜¯å‘Šè¯‰ç¼–è¯‘å™¨è¿™ä¸ªå˜é‡å·²ç»åœ¨åˆ«å¤„å®šä¹‰è¿‡äº† å‡½æ•°çš„å£°æ˜å’Œå®šä¹‰ å‡½æ•°çš„å®šä¹‰å’Œå£°æ˜ä¹Ÿæ˜¯ä¸€æ ·ï¼Œå®šä¹‰éœ€è¦åˆ†é…å­˜å‚¨ç©ºé—´ï¼›å£°æ˜åªæ˜¯å‘Šè¯‰ç¼–è¯‘å™¨è¿™ä¸ªå‡½æ•°å·²ç»åœ¨åˆ«å¤„å®šä¹‰è¿‡äº†ã€‚å‡½æ•°çš„å®šä¹‰å’Œå£°æ˜æ¯”è¾ƒå¥½åŒºåˆ†ã€‚æœ‰å‡½æ•°ä½“çš„å³ä¸ºå®šä¹‰ï¼Œä¸å¸¦å‡½æ•°ä½“å³ä¸ºå£°æ˜ã€‚ //å£°æ˜ double sqrt(double x); //å®šä¹‰ double sqrt(double x) { return x*x; } c++é›¶åŸºç¡€å…¥é—¨99é¢˜â€”â€”å¤œæ·±äººé™å†™ç®—æ³• 1.å‡½æ•°2235 ç»™ä½ ä¸¤ä¸ªæ•´æ•° num1 å’Œ num2ï¼Œè¿”å›è¿™ä¸¤ä¸ªæ•´æ•°çš„å’Œã€‚ class Solution { public: int sum(int num1, int num2) { return num1 + num2; } }; 2.åº“å‡½æ•°69 ç»™ä½ ä¸€ä¸ªéè´Ÿæ•´æ•° x ï¼Œè®¡ç®—å¹¶è¿”å› x çš„ ç®—æœ¯å¹³æ–¹æ ¹ ã€‚ ç”±äºè¿”å›ç±»å‹æ˜¯æ•´æ•°ï¼Œç»“æœåªä¿ç•™ æ•´æ•°éƒ¨åˆ† ï¼Œå°æ•°éƒ¨åˆ†å°†è¢« èˆå» ã€‚ æ³¨æ„ï¼šä¸å…è®¸ä½¿ç”¨ä»»ä½•å†…ç½®æŒ‡æ•°å‡½æ•°å’Œç®—ç¬¦ï¼Œä¾‹å¦‚ pow(x, 0.5) æˆ–è€… x ** 0.5 ã€‚ class Solution { public: int mySqrt(int x) { //åº“å‡½æ•°çš„ä½¿ç”¨ return (int)sqrt(x); } }; 7.29-7.30é”™è¯¯æ€»ç»“ä¸å¤ç›˜ï¼ˆå¼ºåŸºè®¡åˆ’ï¼‰ 1.æ•°ç»„çš„äºŒç»´éå†åˆå§‹å€¼çš„è®¾å®š(2006) for(int i = 0;i &lt; nums.size();i++){ for(int j = i;j &lt; nums.size();j++){ .......; } } 2.å†’æ³¡æ’åº int temp; for(int i = 0;i &lt; nums.size();i++){ for(int j = 0;j &lt; nums.size();j++){ if(nums[j] &gt; nums[j+1]){ temp = nums[j]; nums[j+1] = nums[j]; nums[j] = nums[j+1]; } } } 3.sumçš„ä½ç½®(1672) class Solution { public: int maximumWealth(vector&lt;vector&lt;int&gt;&gt;&amp; accounts) { int maxv = 0; //ä¸€ä¸ªæ˜¯æ”¾åœ¨è¿™é‡Œ //int sum = 0; for(int i =0;i &lt; accounts.size();i++){ //ä¸€ä¸ªæ˜¯æ”¾åœ¨è¿™é‡Œ int sum = 0; for(int j = 0;j &lt; accounts[i].size();j++){ sum += accounts[i][j]; } maxv = max(maxv,sum); } return maxv; } }; æ”¾åœ¨åˆå§‹æ±‚å¾—æ˜¯å…¨éƒ¨æ•°ç»„ä¸­æ¯è¡Œçš„å’Œï¼›æ”¾åœ¨åé¢æ±‚çš„æ˜¯äºŒç»´æ•°ç»„ä¸­å•ç‹¬è¡Œçš„å’Œã€‚ 4.äºŒåˆ†æŸ¥æ‰¾åº”ç”¨æ¡ä»¶æ˜¯â€”â€”æœ‰åºæ•°ç»„ ç»“åˆçŸ©é˜µä¸­å…ƒç´ çš„æœç´¢ /2å’Œ&gt;&gt;1çš„åŒºåˆ«ï¼šï¼ˆc++) 1.æ“ä½œå¯¹è±¡ç±»å‹ä¸åŒæ˜¯å³ç§»ç¬¦ç™¾å·ï¼Œå®ƒåœ¨æ“åº¦ä½œæ—¶åªå…è®¸æ•´æ•° /æ˜¯é™¤æ³•ï¼Œå®ƒå¯ä»¥æ“ä½œä¸åŒç±»å‹çš„æ•°æ®ï¼šæµ®ç‚¹æ•°é™¤æ³•æœ€ç»ˆç»“æœæ˜¯æµ®ç‚¹æ•°ï¼Œæ•´æ•°é™¤æ³•çš„æœ€ç»ˆç»“æœæ˜¯æ•´æ•°ã€‚ åªæœ‰å½“è¢«æ“ä½œæ•°æ•°æ®ç±»å‹ä¸ºçŸ¥å¤§äº0çš„æ•´æ•°æ—¶ï¼Œè¿ç®—é“ç»“æœæ‰æ˜¯å†…ç›¸åŒçš„ã€‚ 2.è¿ç®—æ•ˆç‡ä¸åŒ å³ç§»æ“ä½œé€šå¸¸æƒ…å†µä¸‹ï¼Œä¼šæ¯”æ•´æ•°é™¤æ³•é€Ÿåº¦å¿«ã€‚æ¶‰åŠå®¹åˆ°æµ®ç‚¹æ•°çš„é™¤æ³•é€Ÿåº¦æ˜¯æœ€æ…¢çš„ã€‚ 3.ä¼˜å…ˆçº§ä¸åŒ å³ç§»è¿ç®—çš„ä¼˜å…ˆçº§æ¯”é™¤æ³•ä½ï¼Œåœ¨åŒæ—¶å‚ä¸çš„è¿ç®—ä¸­ï¼Œå…ˆè®¡ç®—ä¹˜é™¤ï¼Œåè®¡ç®—å·¦ç§»æˆ–å³ç§» 8æœˆ-10é”™è¯¯æ€»ç»“ä¸å¤ç›˜ï¼ˆå¼ºåŸºè®¡åˆ’ï¼‰ åŠ æ·±å¯¹é€’å½’å‡½æ•°è°ƒç”¨çš„è¿‡ç¨‹ç†è§£ä¸å®æˆ˜ä¹¦å†™ï¼›åªæœ‰è¿‡ç¨‹æ¸…æ™°äº†ï¼Œæ‰èƒ½è·Ÿé«˜çš„è¿ç”¨é€’å½’å‡½æ•°å»æé«˜æ•ˆç‡ã€‚ scanfä¸scanf_så®‰å…¨æ€§é—®é¢˜ï¼š #define _CRT_SECURE_NO_WARNINGS-&gt;è§£é™¤å®‰å…¨éšæ‚£ åŒæ ·getsä¹Ÿä¸å†æ”¯æŒè€Œæ”¹ç”¨gets_s #include&lt;stdio.h&gt; //è¿›ç¨‹æ•°é‡-&gt;é¢˜ç›®ä¸­æ˜¯äº”ä¸ª void process(){ } void cpu(){ process(); func1(); func2(); func3(); func4(); func5(); } void func1(){ //x=æ“ä½œçš„å®ç° } void func2(){ //x++æ“ä½œçš„å®ç° } void func3(){ //x--æ“ä½œçš„å®ç° } void func4(){ //ï¼ï¼Ÿï¼Ÿæ“ä½œçš„å®ç° } void func5(){ //æ“ä½œçš„å®ç° } int main(){ cpu(); } ","link":"https://Mungeryang.github.io/post/cc-for-everyonr/"},{"title":"æµ‹è¯•æ–‡ç« ","content":"ä½ å¥½ï¼Œè¿™é‡Œæ˜¯æ¨æ¡‚æ·¼çš„åšå®¢ç½‘ç«™ï¼ ","link":"https://Mungeryang.github.io/post/ce-shi-wen-zhang/"},{"title":"æŒ‡å—","content":"ğŸ‘ æ¬¢è¿ä½¿ç”¨ Gridea ï¼ âœï¸ Gridea ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ... Github Gridea ä¸»é¡µ ç¤ºä¾‹ç½‘ç«™ ç‰¹æ€§ğŸ‘‡ ğŸ“ ä½ å¯ä»¥ä½¿ç”¨æœ€é…·çš„ Markdown è¯­æ³•ï¼Œè¿›è¡Œå¿«é€Ÿåˆ›ä½œ ğŸŒ‰ ä½ å¯ä»¥ç»™æ–‡ç« é…ä¸Šç²¾ç¾çš„å°é¢å›¾å’Œåœ¨æ–‡ç« ä»»æ„ä½ç½®æ’å…¥å›¾ç‰‡ ğŸ·ï¸ ä½ å¯ä»¥å¯¹æ–‡ç« è¿›è¡Œæ ‡ç­¾åˆ†ç»„ ğŸ“‹ ä½ å¯ä»¥è‡ªå®šä¹‰èœå•ï¼Œç”šè‡³å¯ä»¥åˆ›å»ºå¤–éƒ¨é“¾æ¥èœå• ğŸ’» ä½ å¯ä»¥åœ¨ Windowsï¼ŒMacOS æˆ– Linux è®¾å¤‡ä¸Šä½¿ç”¨æ­¤å®¢æˆ·ç«¯ ğŸŒ ä½ å¯ä»¥ä½¿ç”¨ ğ–¦ğ—‚ğ—ğ—ğ—ğ–» ğ–¯ğ–ºğ—€ğ–¾ğ—Œ æˆ– Coding Pages å‘ä¸–ç•Œå±•ç¤ºï¼Œæœªæ¥å°†æ”¯æŒæ›´å¤šå¹³å° ğŸ’¬ ä½ å¯ä»¥è¿›è¡Œç®€å•çš„é…ç½®ï¼Œæ¥å…¥ Gitalk æˆ– DisqusJS è¯„è®ºç³»ç»Ÿ ğŸ‡¬ğŸ‡§ ä½ å¯ä»¥ä½¿ç”¨ä¸­æ–‡ç®€ä½“æˆ–è‹±è¯­ ğŸŒ ä½ å¯ä»¥ä»»æ„ä½¿ç”¨åº”ç”¨å†…é»˜è®¤ä¸»é¢˜æˆ–ä»»æ„ç¬¬ä¸‰æ–¹ä¸»é¢˜ï¼Œå¼ºå¤§çš„ä¸»é¢˜è‡ªå®šä¹‰èƒ½åŠ› ğŸ–¥ ä½ å¯ä»¥è‡ªå®šä¹‰æºæ–‡ä»¶å¤¹ï¼Œåˆ©ç”¨ OneDriveã€ç™¾åº¦ç½‘ç›˜ã€iCloudã€Dropbox ç­‰è¿›è¡Œå¤šè®¾å¤‡åŒæ­¥ ğŸŒ± å½“ç„¶ Gridea è¿˜å¾ˆå¹´è½»ï¼Œæœ‰å¾ˆå¤šä¸è¶³ï¼Œä½†è¯·ç›¸ä¿¡ï¼Œå®ƒä¼šä¸åœå‘å‰ ğŸƒ æœªæ¥ï¼Œå®ƒä¸€å®šä¼šæˆä¸ºä½ ç¦»ä¸å¼€çš„ä¼™ä¼´ å°½æƒ…å‘æŒ¥ä½ çš„æ‰åå§ï¼ ğŸ˜˜ Enjoy~ ","link":"https://Mungeryang.github.io/post/hello-gridea/"}]}