{"posts":[{"title":"前路漫漫亦灿灿","content":" 2023年9月29日，下午14:50，故事开始了新的篇章。 从2023年2月15日离家返校，一直到10月1号，整整228天，家门未踏入一步。一直想带一个好的结果回家，经历磕磕绊绊，最终如愿以偿。 想说的东西，想表达的东西有好多，但却难以启齿、无从下笔。 回首这段岁月，感谢自己没有放弃自己，感谢暑假留校踏踏实实读书学习的沉淀。暑假留校两个月，自己在图书馆五楼靠窗户占了一整张桌子，五楼人烟稀少，八月份安安静静在那里度过了一个月充实的时光。早上八点半开馆准时到达，晚上再漆黑的五楼写读书笔记，如今再进入五楼，往事历历如过眼云烟般浮现在眼前。上一次有这种感觉，还是因为19年底口罩事情高三开学延期，20年初居家复习的岁月。这两段时光交织在一起，给我的反思就是，要想做成一件事情，首先要把自己调整成静音模式，踏踏实实忘我般的投入进去。想成事，不是每天炸炸呼呼，一天八条朋友圈，恨不能别人不知道我干啥。而是要沉淀、要安静、要忍耐、要坚持。 人性的弱点之一就是只看结果，不注重过程。你考上研了，考上公了，周围都是欢呼、赞美之词。&quot;牛逼、大佬、交给朋友吧...&quot;诸如此类的话，会让你沉迷享受，会让你飘飘然忘乎所以。但是，当你没考上，周围便是讥讽、嘲笑不绝于耳。&quot;他不行，他光玩，他就不是那块料...&quot;。所以，自强不息、厚德载物，永远都是法宝，让自己强大起来，让自己内心强大起来，才会在面对这些情况的时候，做到多一份的从容、淡定与坦然。 带着好结果回家过节，家人们由衷地为我感到高兴、自豪。感谢家人，没有家人的理解与支持，我没有勇气走好今天的路。 我的父亲杨海龙，1976年出生于河北省沧州市一个贫穷的普通家庭。小时候学习成绩不错，凭借自己的努力一直读到了高中毕业。中考成绩很好，但是因为家里穷要继续供给我二叔、三叔读书。于是，父亲放弃了去县里读高中的机会，选择了在镇上完成学业，很多年前，他仍然自嘲:“以我当年的成绩，要是去县里上，考过河北工业绰绰有余”。高中毕业后在我二爷家工厂里工作，然后和爷爷、叔叔们创业。 我的母亲刘秋菊，1978年出生于河北省沧州市一个贫穷的普通家庭。小的时候学习成绩一般，肯定没有我父亲学习好，想考中专，结果也是为了弟弟妹妹的学业而放弃了自己的梦想。初中毕业后进入农村信用社当会计，后来在我姥爷的厂子里当会计，一干就是半辈子。母亲是一个聪明的人，积极、阳光、热爱学习，她算账、算数没出过错，爱写读书笔记，有阅读习惯，这些都润物细无声般影响着我。 两个有着相同命运路径的人走到了一起，养育了我、培养了我。特别是，今年因为面试忙于各个城市奔波，报辅导机构，发paper。以上种种，当我需要钱的时候，老父亲总是那么斩钉截铁给我转好多钱，让我没有任何顾虑。钱是好东西，钱是干净的，脏的是人心。走正道，好好赚钱、多赚钱永远都是幸福的。 这些年，二叔的去世一直也是我前进的动力。我很少和外人去谈我二叔因为车祸去世的事情，我认为这是家族之殇。我作为家族中的长子长孙，在我17岁那年，他的死，使我对我的家庭、对我自己有了新的理解。挫折都是发人深省的，我庆幸自己没有被生活的重创打垮，我也庆幸，家里的老人没有因为生活的苦难而使他们丧失对生活的希望。在经历苦难之后，我看到的依然是他们积极的生活态度，没有怨天尤人、没有一蹶不振，永远都给子女树立了好的榜样。其实，这就是我遇到无数困难后，依然有勇气面对的底气来源。 今年还要感谢张宇(宇爹)，不确定的日子里一直在通过备考高数舒缓。激发了我对数学的热情，重塑了学科的理解。 下一个阶段要做的任务： 1.回去以后不要懈怠，可以适当休息，但是不要挥霍、不要浪费。坚持锻炼，保护身体，少熬夜，自律起来。 2.列一个书单，多读点书。 3.专业技术知识复习，代码多敲。 4.在研究领域深耕突破，纵向突破提升，考几个证书。 5.如果有机会去实习！ 6.重视英语、数学的学习。 没有轻舟已过万重山，唯有前路漫漫亦灿灿。 ","link":"https://Mungeryang.github.io/post/qian-lu-man-man-yi-can-can/"},{"title":"张宇|高等数学闭关修炼·18讲汇总","content":" 多多重复，百炼成钢 错误是金子，不纠是傻子。学数学纯粹点，别那么好面子 杨桂淼1^{1}1,刘贺2^{2}2 [1]杨桂淼：Hebei University,Information Management and Information Systems [2]刘贺：Qingdao Institute of Technology,Computer Science and Technology *以下公式皆为宇哥上课时强调的“考前记一记-喝前摇一摇”公式，这些公式或函数或算法平时不便于考生记忆而且考频相对较低(但是不代表不考)，所以逢考前，必须认真熟悉一遍。除以下特殊公式外，其余各种公式、各个基本函数及其图像性质都必须熟x(稔)于心，倒背如流,方可登峰造极，行云流水、令人拍案！❤️ 极坐标下你总是记不熟的函数及图像 笛卡尔心形线： r=a(1−cos⁡θ)r = a(1 - \\cos\\theta) r=a(1−cosθ) x{r=α(1+cos⁡θ),向右r=α(1−cos⁡θ),向左r=α(1+sin⁡θ),向上r=α(1−sin⁡θ),向下 x\\begin{cases}r= \\alpha(1+\\cos \\theta),&amp;\\text{向右}\\\\r= \\alpha(1-\\cos \\theta),&amp;\\text{向左}\\\\r= \\alpha(1+\\sin \\theta),&amp;\\text{向上}\\\\r= \\alpha(1-\\sin \\theta),&amp;\\text{向下}\\end{cases} x⎩⎪⎪⎪⎨⎪⎪⎪⎧​r=α(1+cosθ),r=α(1−cosθ),r=α(1+sinθ),r=α(1−sinθ),​向右向左向上向下​ 【默写区】 玫瑰线： r=asin⁡(nθ)r = a\\sin(n \\theta) r=asin(nθ) 【默写区】 阿基米德螺线： r=aθr = a\\theta r=aθ 【默写区】 伯努利双纽线： r=a2sin⁡(2θ)r=a^2 \\sin(2\\theta) r=a2sin(2θ) 【默写区】 摆线的参数方程： x=r⋅(θ−sin⁡θ) y=r⋅(1−cos⁡θ) x = r \\cdot (\\theta - \\sin \\theta) \\\\ y = r \\cdot (1 - \\cos \\theta) x=r⋅(θ−sinθ) y=r⋅(1−cosθ) 【默写区】 星行线的参数方程： x=a⋅cos⁡3(t)y=a⋅sin⁡3(t)x = a \\cdot \\cos^3(t) \\\\ y = a \\cdot \\sin^3(t) x=a⋅cos3(t)y=a⋅sin3(t) 【默写区】 反双曲正弦：y=ln(x+x2+1)y = ln(x + \\sqrt{x^2 + 1})y=ln(x+x2+1​) 【默写区】 双曲正弦：y=ex−e−x2y = \\frac{e^x - e^{-x}}{2}y=2ex−e−x​ 【默写区】 双曲余弦(悬链线)：y=ex+e−x2y = \\frac{e^x + e^{-x}}{2}y=2ex+e−x​ 【默写区】 另外 y=xxy=x^xy=xx 与 y=x1xy=x^{\\frac{1}{x}}y=xx1​ 考生也需牢记函数图像及性质 强化阶段要求新掌握的函数、数列极限 f(x)=(1+x)1xf\\left( x \\right) =\\left( 1+x \\right) ^{\\frac{1}{x}} f(x)=(1+x)x1​ f(x)单调减少 lim⁡x→0+f(x)=e\\underset{x\\rightarrow 0^+}{\\lim}f\\left( x \\right) =ex→0+lim​f(x)=e (1+x)1x−e∼−e2x(x→0+)\\left( 1+x \\right) ^{\\frac{1}{x}}-e\\sim -\\frac{e}{2}x\\left( x\\rightarrow 0^+ \\right)(1+x)x1​−e∼−2e​x(x→0+) xn=(1+1n)nx_n=\\left( 1+\\frac{1}{n} \\right) ^n xn​=(1+n1​)n xnx_nxn​单调增加 lim⁡n→∞xn=e\\underset{n\\rightarrow \\infty}{\\lim}x_n=en→∞lim​xn​=e (1+1n)n−e∼−e21n\\left( 1+\\frac{1}{n} \\right) ^n-e\\sim -\\frac{e}{2}\\frac{1}{n}(1+n1​)n−e∼−2e​n1​ 最装逼的脱帽、带帽法——放心没有很多人会灵活运用，但你可以！ 脱帽法： lim⁡x→⋅f(x)&gt;(&lt;)0⟹f(x)&gt;(&lt;)0\\underset{x\\rightarrow ·}{\\lim}f\\left( x \\right) \\underset{\\left( &lt; \\right)}{&gt;}0\\Longrightarrow f\\left( x \\right) \\underset{\\left( &lt; \\right)}{&gt;}0 x→⋅lim​f(x)(&lt;)&gt;​0⟹f(x)(&lt;)&gt;​0 【默写区】 带帽法： f(x)⩾(⩽)0⟹lim⁡x→⋅f(x)⩾(⩽)0f\\left( x \\right) \\underset{\\left( \\leqslant \\right)}{\\geqslant}0\\Longrightarrow \\underset{x\\rightarrow ·}{\\lim}f\\left( x \\right) \\underset{\\left( \\leqslant \\right)}{\\geqslant}0 f(x)(⩽)⩾​0⟹x→⋅lim​f(x)(⩽)⩾​0 【默写区】 火眼金睛，do you know? ∫−∞0e−tdt=1\\int_{- \\infty}^{0} e^{-t}dt = 1∫−∞0​e−tdt=1 高斯曲线：∫0+∞e−x2dx\\int_{0}^{+ \\infty} e^{-x^2}dx∫0+∞​e−x2dx=π2\\frac{\\sqrt π}{2}2π​​ ∫0xx2−t2dx=14πx2(几何意义)\\int_{0}^{x} \\sqrt{x^2 - t^2}dx = \\frac{1}{4}πx^2(几何意义)∫0x​x2−t2​dx=41​πx2(几何意义) 考研数学中对绝对值处理你熟练吗？——答：不熟练。立即推：复习到4点！ 去绝对值就意味着要分情况讨论。 放缩法 压缩映射 绝对值求极限 绝对值求导数(分段) 绝对值求积分 绝对值证明题综合 永远用不熟练的不等式 ∣a±b∣⩽∣a∣+∣b∣∣∣a∣−∣b∣∣⩽∣a−b∣∣∫abf(x)dx∣⩽∫ab∣f(x)∣dx∣ab∣⩽a2+b22∣a1±a2±⋅⋅⋅±an∣⩽∣a1∣+∣a2∣+⋅⋅⋅+∣an∣|a\\pm b|\\leqslant |a|+|b| \\\\ ||a|-|b||\\leqslant |a-b| \\\\ |\\int{_{a}^{b}f\\left( x \\right) dx}|\\leqslant \\int{_{a}^{b}|f\\left( x \\right) |dx} \\\\ |ab|\\leqslant \\frac{a^2+b^2}{2} \\\\ |a_1\\pm a_2\\pm ···\\pm a_n|\\leqslant |a_1|+|a_2|+···+|a_n| ∣a±b∣⩽∣a∣+∣b∣∣∣a∣−∣b∣∣⩽∣a−b∣∣∫ab​f(x)dx∣⩽∫ab​∣f(x)∣dx∣ab∣⩽2a2+b2​∣a1​±a2​±⋅⋅⋅±an​∣⩽∣a1​∣+∣a2​∣+⋅⋅⋅+∣an​∣ 【默写区】 带绝对值的极限 lim⁡x→⋅∣f(x)∣=0⟺lim⁡x→⋅f(x)=0\\underset{x\\rightarrow ·}{\\lim}|f\\left( x \\right) |=0\\Longleftrightarrow \\underset{x\\rightarrow ·}{\\lim}f\\left( x \\right) =0 x→⋅lim​∣f(x)∣=0⟺x→⋅lim​f(x)=0 【默写区】 一个特殊的求导公式(视绝对值而不见) (ln⁡∣x∣)′=1x\\left( \\ln |x| \\right)&#x27; =\\frac{1}{x} (ln∣x∣)′=x1​ 【默写区】 恶心的连续与间断 请讨论一下函数第一类间断点的个数 f(x)=(x2−x)∣x+1∣e1x∫1tt∣sin⁡t∣dtf\\left( x \\right) =\\frac{\\left( x^2-x \\right) |x+1|}{e^{\\frac{1}{x}}\\int{_{1}^{t}t|\\sin t|dt}} f(x)=ex1​∫1t​t∣sint∣dt(x2−x)∣x+1∣​ 作答区： 若f(x0)f(x_0)f(x0​)在 x0x_0x0​ 处可导，当f(x0)=0f(x_0)=0f(x0​)=0且f’(x0)=0f’(x_0)=0f’(x0​)=0时，∣f(x)∣|f(x)|∣f(x)∣在x0x_0x0​处可导吗？ Please prove: 拆分求导体现基本功 小试牛刀：f(x)=∫01∣t2−x2∣dt(x&gt;0)f\\left( x \\right) =\\int{_{0}^{1}|t^2-x^2|dt\\left( x&gt;0 \\right)}f(x)=∫01​∣t2−x2∣dt(x&gt;0),求f(x)f(x)f(x)的最小值 作答区：[自备草稿纸] 我觉着这个函数是一个万金油的例子(P49) f(x)={x24+x4sin⁡1x,x≠00,x=0f\\left( x \\right) =\\begin{cases} \\frac{x^2}{4}+x^4\\sin \\frac{1}{x},x\\ne 0\\\\ 0,x=0\\\\ \\end{cases} f(x)={4x2​+x4sinx1​,x​=00,x=0​ 请自行求出它的一阶导函数、二阶导函数。 求导区： 特别是，涉及到一些概念性问题，比如什么函数连续一阶导函数是否连续，类似这种讨论函数与其导函数的连续性与可导性问题，这个例子屡试不爽。 不能蛮干，要用巧劲的高阶导数(p39) 大展拳脚：已知函数f(x)=x21−x2f(x) = \\frac{x^2}{1 - x^2}f(x)=1−x2x2​,则f(x) = ___(n=1,2,3⋯ )(n=1,2,3\\cdots)(n=1,2,3⋯) 提醒：(1ax+b)(n)=(−1)nann!(ax+b)n+1(\\frac{1}{ax+b})^{(n)}=(-1)^n a^n \\frac{n!}{(ax+b)^{n+1}}(ax+b1​)(n)=(−1)nan(ax+b)n+1n!​ 作答区：[自备草稿纸] 你总是自信地认为背的很熟但是一下笔就写错的佩亚诺余项 在考研数学中，常常使用带佩亚诺余项的泰勒展开式来近似函数的值。 带佩亚诺余项的泰勒展开式（一阶）： f(x)≈f(a)+f′(a)(x−a)+R1(x)f(x) \\approx f(a) + f&#x27;(a)(x - a) + R_1(x) f(x)≈f(a)+f′(a)(x−a)+R1​(x) 【默写区】 其中，f(x) 是要近似的函数，a是展开点，R1(x) 是带佩亚诺余项的一阶余项，通常表示为： f(x)≈f(a)+f′(a)(x−a)+f′′(a)2!(x−a)2+R2(x)f(x) \\approx f(a) + f&#x27;(a)(x - a) + \\frac{f&#x27;&#x27;(a)}{2!}(x - a)^2 + R_2(x) f(x)≈f(a)+f′(a)(x−a)+2!f′′(a)​(x−a)2+R2​(x) 【默写区】 其中，f(x) 是要近似的函数，a是展开点，R2(x) 是带佩亚诺余项的二阶余项，通常表示为： R2(x)=f′′′(ξ)3!(x−a)3R_2(x) = \\frac{f&#x27;&#x27;&#x27;(\\xi)}{3!}(x - a)^3 R2​(x)=3!f′′′(ξ)​(x−a)3 【默写区】 最容易被冷落的中值定理 二重积分中值定理公式 ∬f(x,y)dσ=f(ξ,η)σ\\underset{}{\\iint{f\\left( x,y \\right) d\\sigma =}f\\left( \\xi ,\\eta \\right) \\sigma} ∬f(x,y)dσ=f(ξ,η)σ​ 【默写区】 推广的积分中值定理 ∫abf(x)g(x)dx=f(ξ)∫abg(x)dx\\int{_{a}^{b}f\\left( x \\right) g\\left( x \\right) dx=}f\\left( \\xi \\right) \\int{_{a}^{b}g\\left( x \\right) dx} ∫ab​f(x)g(x)dx=f(ξ)∫ab​g(x)dx 【默写区】 二元函数中的拉格朗日中值定理(类比一元) f(x,y)−f(0,0)=[f(x,y)−f(0,y)]+[f(0,y)−f(0,0)]=f′x(ξx,y)x+f′y(0,ηy)y\\quad f(x,y)-f(0,0)=[f(x,y)-f(0,y)]+[f(0,y)-f(0,0)]=f\\prime_x(\\xi_x,y)x+f\\prime_y(0,\\eta_y)yf(x,y)−f(0,0)=[f(x,y)−f(0,y)]+[f(0,y)−f(0,0)]=f′x​(ξx​,y)x+f′y​(0,ηy​)y 其中,f(0,0)=0,详见1000题P49第3题f(0,0)=0,详见1000题P_{49}第3题f(0,0)=0,详见1000题P49​第3题 【默写区】 随便转的旋转体体积 V=π(A2+B2)32∫ab[Ax+Bf(x)+C]2∣Af′(x)−B∣dxV=\\frac{\\pi}{\\left( A^2+B^2 \\right) ^{\\frac{3}{2}}}\\int{_{a}^{b}\\left[ Ax+Bf\\left( x \\right) +C \\right] ^2|Af&#x27;\\left( x \\right) -B|dx} V=(A2+B2)23​π​∫ab​[Ax+Bf(x)+C]2∣Af′(x)−B∣dx 空间曲线L:f(x),a⩽x⩽bL:f(x),a\\leqslant x\\leqslant bL:f(x),a⩽x⩽b且f(x)可导 定直线：L0:Ax+By+C=0L_0:Ax+By+C=0L0​:Ax+By+C=0 【默写区】 两个很不起眼的区间再现公式(P118、96) ∫0nTxf(x)dx=n2T2∫0Tf(x)dx(n=1,2,3⋅⋅⋅)∫aa+nTf(x)dx=n∫0Tf(x)dx\\int{_{0}^{nT}xf\\left( x \\right) dx=}\\frac{n^2T}{2}\\int{_{0}^{T}f\\left( x \\right) dx}\\left( n=1,2,3··· \\right) \\\\ \\int{_{a}^{a+nT}f\\left( x \\right) dx=}n\\int{_{0}^{T}f\\left( x \\right) dx} ∫0nT​xf(x)dx=2n2T​∫0T​f(x)dx(n=1,2,3⋅⋅⋅)∫aa+nT​f(x)dx=n∫0T​f(x)dx 【默写区】 迷人的敛散性尺度 ∫011xpdx{0&lt;p&lt;1,convergencep&gt;1,diverge\\int{_{0}^{1}}\\frac{1}{x^p}dx\\begin{cases} 0&lt;p&lt;1,convergence\\\\ p&gt;1,diverge\\\\ \\end{cases} ∫01​xp1​dx{0&lt;p&lt;1,convergencep&gt;1,diverge​ ∫01ln⁡xxpdx\\int{_{0}^{1}}\\frac{\\ln x}{x^p}dx∫01​xplnx​dx同理 【默写区】 ∫1+∞1xpdx{p⩽1,divergep&gt;1,convergence\\int{_{1}^{+\\infty}}\\frac{1}{x^p}dx\\begin{cases} p\\leqslant 1,diverge\\\\ p&gt;1,convergence\\\\ \\end{cases} ∫1+∞​xp1​dx{p⩽1,divergep&gt;1,convergence​ ∫1+∞ln⁡xxpdx\\int{_{1}^{+\\infty}}\\frac{\\ln x}{x^p}dx∫1+∞​xplnx​dx同理 【默写区】 曲率与曲率半径(仅数一、数二) 曲率k=y′′[1+(y′)2]32,曲率半径R=1kk=\\frac{y^{&#x27;&#x27;}}{[1+(y^\\prime)^2]^{\\frac{3}{2}}},曲率半径R=\\frac{1}{k}k=[1+(y′)2]23​y′′​,曲率半径R=k1​ 【默写区】 炒鸡唬人的重积分公式(数一) 转动惯量 Ix=∭(y2+z2)ρ(x,y,z) dx dy dzIy=∭(x2+z2)ρ(x,y,z) dx dy dzIz=∭(x2+y2)ρ(x,y,z) dx dy dzI_x = \\iiint (y^2 + z^2) \\rho(x, y, z) \\, dx \\, dy \\, dz \\\\ I_y = \\iiint (x^2 + z^2) \\rho(x, y, z) \\, dx \\, dy \\, dz \\\\ I_z = \\iiint (x^2 + y^2) \\rho(x, y, z) \\, dx \\, dy \\, dz Ix​=∭(y2+z2)ρ(x,y,z)dxdydzIy​=∭(x2+z2)ρ(x,y,z)dxdydzIz​=∭(x2+y2)ρ(x,y,z)dxdydz 【默写区】 重心(质心)与形心 xcm=1V∭xρ(x,y,z) dVycm=1V∭yρ(x,y,z) dVzcm=1V∭zρ(x,y,z) dVx_{\\text{cm}} = \\frac{1}{V} \\iiint x \\rho(x, y, z) \\, dV \\\\ y_{\\text{cm}} = \\frac{1}{V} \\iiint y \\rho(x, y, z) \\, dV \\\\ z_{\\text{cm}} = \\frac{1}{V} \\iiint z \\rho(x, y, z) \\, dV xcm​=V1​∭xρ(x,y,z)dVycm​=V1​∭yρ(x,y,z)dVzcm​=V1​∭zρ(x,y,z)dV 【默写区】 引力 Fx=Gm(x−x0)2∭(x−x0)r3ρ(x,y,z) dVFy=Gm(y−y0)2∭(y−y0)r3ρ(x,y,z) dVFz=Gm(z−z0)2∭(z−z0)r3ρ(x,y,z) dVr=(x−x0)2+(y−y0)2+(z−z0)2F_x = \\frac{G m}{(x - x_0)^2} \\iiint \\frac{(x - x_0)}{r^3} \\rho(x, y, z) \\, dV \\\\ F_y = \\frac{G m}{(y - y_0)^2} \\iiint \\frac{(y - y_0)}{r^3} \\rho(x, y, z) \\, dV \\\\ F_z = \\frac{G m}{(z - z_0)^2} \\iiint \\frac{(z - z_0)}{r^3} \\rho(x, y, z) \\, dV \\\\ r=\\sqrt{\\left( x-x_0 \\right) ^2+\\left( y-y_0 \\right) ^2+\\left( z-z_0 \\right) ^2} Fx​=(x−x0​)2Gm​∭r3(x−x0​)​ρ(x,y,z)dVFy​=(y−y0​)2Gm​∭r3(y−y0​)​ρ(x,y,z)dVFz​=(z−z0​)2Gm​∭r3(z−z0​)​ρ(x,y,z)dVr=(x−x0​)2+(y−y0​)2+(z−z0​)2​ 【默写区】 ​ 没有条件，创造条件 ​ 反反复复扎扎实实，念念不忘必有回响 ​ 【注】以上总结皆为本人强化阶段宇哥(爹)课上嘱托”考前记一记，喝前摇一摇“内容，加上我自己的归纳总结。所以例子全无答案，全部参考闭关修炼高等数学18讲内容，如有困难，请反复看书，吃透每一道经典例题！👊 未完待续……… 熟稔于心的公式汇总 ………🚩 ","link":"https://Mungeryang.github.io/post/zhang-yu-orgao-deng-shu-xue-bi-guan-xiu-lian-18-jiang-hui-zong/"},{"title":"2023暑假留校闭关修炼|书单与知识结构图","content":"书单 《程序是怎么跑起来的》——矢泽久雄 《网络是怎样连接的》——户根勤 《计算机是怎样跑起来的》——矢泽久雄 《图解人工智能》——多田智史、石井一夫 《征服C指针》——前桥和弥 《干法》——稻盛和夫 《数学之美》——吴军 《计算机网络》——谢希仁 《第二大脑》——涂子沛 《毛泽东选集5·静火版》——毛主席、静火 《明朝那些事儿1》——当年明月 《高等数学闭关修炼18讲》——张宇 《鸢尾花之书·线性代数》——生姜 《你还在背单词吗》——刘晓燕(背了1.5遍) 《新婚必读全书》——郎景和(北京协和) 《厚黑学》——李宗吾 《政治的人生》——王沪宁 《好好学习》——成甲 《天涯神贴》——无名氏 《运筹学》——胡运权 知识结构图 好好学习-成甲 运筹学 程序是怎样跑起来的 数据结构 计算机网络 ","link":"https://Mungeryang.github.io/post/2023-shu-jia/"},{"title":"数据结构与算法学习笔记","content":" 你陪了我多少年，花开花落，一路上起起跌跌。——江南 天下大事，必作于细——侯捷 写在前面： 2022.06.20漫长的暑假开始了，总要做些什么。做啥？——当然是做好本手儿（2022年高考学的词哈哈~） 付东来大哥的这本书是2022.03.26购入，那是大二下学期的开学后不久。一个学期囫囵吞枣的看了一遍，没有get到精髓部分，代码看着很明白，自己写着错误百出。于是计划利用好这个稍微漫长的暑假，认认真真学好数据结构与算法。 这份总结是杨桂淼©（作者本人）基于力扣平台的题目，参考付东来大哥的解题思路编写；东来大哥每道题都给出了基于Java的解题思路，但是目前阶段本人Java语言掌握一般。于是乎，借鉴东来大哥的思路，将题目全部运用python语言实现。随着本人的不断学习积累，完善后代码会全部开源到杨桂淼的GitHub仓库中，届时，欢迎各位大佬评阅斧正；欢迎各位志同道合的同志交流学习！ 本人秉持东来大哥的理念——致力于把算法讲清楚！ 引用教员的话：下定决心，排除万难，争取学明白！ 写在过程中： 行百里者半九十 2022.10月下旬以来，一边为了将来考研打算，一边在复习C语言基本知识点。决定下定决心把基本的数据结构复习温习。因为在前面的学习中我一直使用的是Python，也没有学号Python数据结构与算法，所以在刷题过程中遇到抽象数据结构与指针，我的理解是有问题的，而且有时候我本身就对某一句程序根本就是不理解。诚如程杰老师在大话数据结构中说是：讲解数据结构还的使用最干净最纯粹的通用计算机经典语言，虽然Python很灵动，正是这种灵动，在解析数据结构的时候显得不够严肃和“正统”，而程序员的基础必修课，必须一拳一脚的养成规范的动作习惯。 所以，我觉着这也是我走过的弯路。当前主流的编程语言，对于学生来说，接受程度最大的我认为无疑是Python语言。我一开始最初摸索的时候，也是使用的Python语言。但是学到后期，我发现，Python的灵动使我对算法的关键执行步骤理解起来并不是非常清晰。C语言相比于Python，没用那么多灵动性，如果再引入指针，大部分本科生是很讨厌的。但是，正是由于C语言的朴实，我才发现了数据结构与算法真正的魅力所在。(只可意会不可言传哈哈哈!)。所以，打好C语言的基础任何时候都需要！！！——2023.09.05补充 写在2022年终岁尾： 因为疫情，突如其来的寒假又开始了，这个假期主要干三件事：408,408，还TMD是408！ 当然数据结构还是接续学，算法题还是要继续刷。利用寒假巩固一下竞赛中的C++基础语法知识和算法提高。寒假刷题的语言全部转换到了C++上，后期看到语言的转变就不要感到差异。算法学习强推ACwing-闫学灿！ 写在2023年初： 2023开年——开始新一遍408数据结构与算法的总结复习，这一遍注重基础知识，特别是时间-空间复杂度的计算、程序设计大题代码的默写(细节)、各种算法的计算过程。 后面学的多了，东来大哥的书已经不能满足我得学习激情了,博览群书借鉴多位专家大佬的思想精华。 参考学习更多书目如下： [1]计算之魂.吴军 [2]算法导论.MIT [3]数据结构与算法.严蔚敏 [4]labuladong的算法小抄.付东来 [5]代码随想录.孙秀洋 [6]STL源码剖析.何捷 [7]大话数据结构.程杰(小白强推) [8]数据结构与算法习题集.严蔚敏 C++基础语法-&gt;竞赛相关 语法学习参考y神：ACwing-闫学灿！ C++中的数据类型 bool:true/false 1 bytes char:‘a’,‘c’,‘ ’,‘\\n’ 1 bytes int：−231−231−1-2^{31} - 2^{31}-1−231−231−1 4 bytes float: 1.23,2.51,2.35e2 6-7位有效数字单精度浮点型数据 4 bytes double(double flaot):15-16位双精度浮点型 8 bytes long long(long int):−263−263−1-2^{63} - 2^{63}-1−263−263−1 8 bytes long double:18-19位有效数字 16 bytes #include&lt;iostream&gt; #include&lt;cstdio&gt; using namespace std; int main(){ int a,b,c,d; int x; cin &gt;&gt; a; cin &gt;&gt; b; cin &gt;&gt; c; cin &gt;&gt; d; x = a*b-c*d; cout &lt;&lt; &quot;DIFERENCA = &quot; &lt;&lt; x &lt;&lt; endl; return 0; } C++中的格式化的输入输出 printf输出格式 注意：使用printf 时最好添加头文件 #include 。 Int、float、double、char等类型的输出格式： (1) Int：%d (2) Float: %f, 默认保留6位小数 (3) Double: %lf， 默认保留6位小数 (4) Char: %c, 回车也是一个字符，用’\\n’表示 在main函数内部，未初始化的数组中的元素是随机的。 绪论与基础概念 数据结构：是互相之间存在的一种或者多种特定关系的数据元素的集合。 数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及他们之间的关系和操作相关问题的学科。 程序设计=数据结构+算法 算法的五大特性 -&gt;大话数据结构-程杰 算法具有五个基本特性：输入、输出、有穷性、确定性和可行性。 输入输出： 输入和输出特性比较容易理解，算法具有零个或多个输入。算法至少有一个或多个输出，算法是一定需要输出的，不需要输出，你用这个算法干吗？输出的形式可以是打印输出，也可以是返回一个或多个值等。 有穷性 认识到一个问题的边界。有穷性：指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成。现实中经常会写出死循环的代码，这就是不满足有穷性。当然这里有穷的概念并不是纯数学意义的，而是在实际应用当中合理的、可以接受的“有边界”。 确定性 确定性：算法的每一步骤都具有确定的含义，不会出现二义性，相同的输入只能有唯一的输出结果。算法的每个步骤被精确定义而无歧义。 可行性 可行性：算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成。可行性意味着算法可以转换为程序上机运行，并得到正确的结果。 算法与时空复杂度 算法是解决特定问题的求解步骤描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或者多个操作。设计算法应该尽量满足时间效率高和存储量低的需求。 函数的渐进增长 给定两个函数f(n)f(n)f(n)和g(n)g(n)g(n),如果存在一个整数N,使得对于所有的n&gt;N,f(n)f(n)f(n)总是比g(n)g(n)g(n)大,那么我们说f(n)f(n)f(n)的增长渐进快于g(n)g(n)g(n)。 时间复杂度计算 一层循环 思路： 列出循环的趟数t及每轮循环i的变化值 找到t与i的关系 确定循环终止的条件 联立两个式子，解方程 写结果 两层循环 思路： 列出外层循环中i的变化范围 列出内层语句的执行次数 求和写出结果 基础结构的复盘与强化 备战考研呢，也算是复习一遍C语言基础，跟着王道龙哥过一遍C/C++基础。 单链表 单链表的增删改查 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; //在此程序中，*LinkList是变量的指针；LinkList为指针变量。 //单链表的增删改查 //线性表的链式表示就是单链表 #define Maxsize 50 #define InitSize 100 //定义一个整型类型的变量 typedef int ElemType; //单链表结构创建-8个字节 typedef struct LNode {//单链表的结构 ElemType data;//数据域 struct LNode* next;//指针域 }LNode,*LinkList; //LinkList为结构体指针等价于struct LNode* //别名LNode可以和上面保持一致 //头插法插入新的节点 //创建单链表-&gt;带有头结点 //头结点只需要头指针指向，啥也不存 LinkList CreatList1(LinkList &amp;L) { LNode* q; int x; L = (LinkList)malloc(sizeof(LNode));//带头结点的链表 L-&gt;next = NULL; scanf_s(&quot;%d&quot;, &amp;x); while (x != 9999) { q = (LinkList)malloc(sizeof(LNode)); q-&gt;data = x; q-&gt;next = L-&gt;next; L-&gt;next = q; scanf_s(&quot;%d&quot;, &amp;x); } return L; } //尾插法创建单链表 LinkList CreatList2(LinkList &amp;L) { int x; L = (LinkList)malloc(sizeof(LNode));//带头结点的链表 //在这里需要注意的是，r本身就是表尾节点,指向链表尾部 LNode* s, * r = L;//等价于LinkList s,r=L; scanf_s(&quot;%d&quot;, &amp;x); while (x != 9999) { s = (LinkList)malloc(sizeof(LNode)); s-&gt;data = x; r-&gt;next = s; r = s;//r指向新的表尾节点 scanf_s(&quot;%d&quot;, &amp;x); } r-&gt;next = NULL;//尾节点指针赋值为空 return L; } //查找节点 LNode* GetElem(LinkList L, int i) { int j = 1; //初始指向虚拟头结点的下一个节点 LNode* p = L-&gt;next; if (i == 0) { return L; } if (i &lt; 1) { return NULL; } //p-&gt;非空 while (p &amp;&amp; j &lt; i) { p = p-&gt;next; j++; } return p; } //任意两个节点之间插入节点 //第i个位置插入值为e的节点 bool InsertFrontList(LinkList L,int i,ElemType e) { LinkList p = GetElem(L,i - 1); if (NULL == p) { return false; } LinkList s = (LNode*)malloc(sizeof(LNode));//为新插入的节点申请内存空间 s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; return true; } bool InsertBackList(LinkList L,ElemType e) { //L = (LinkList)malloc(sizeof(LNode));//带头结点的链表 while (L-&gt;next != NULL) { L = L-&gt;next; } LNode* q; int x; scanf_s(&quot;%d&quot;, &amp;x); while (x != 9999) { q = (LinkList)malloc(sizeof(LNode)); q-&gt;data = x; L-&gt;next = q; q-&gt;next = NULL; scanf_s(&quot;%d&quot;, &amp;x); } return L; } //无论是中间插入还是删除，找到需要操作节点的前驱节点是关键 //删除第i个位置的节点 bool DeleteList(LinkList L,int i) { //找到要删除元素的前驱结点 LinkList p = GetElem(L, i - 1); LinkList q = p-&gt;next; if (p == NULL) { return false;//要删除的位置不存在 } p-&gt;next = q-&gt;next;//断链 free(q); q = NULL; return true; } void PrintList(LinkList L) { //头结点 L = L-&gt;next; while (L != NULL) { printf(&quot;%d\\t&quot;, L-&gt;data); L = L-&gt;next; } } //查找第几个元素 LinkList LocateElem(LinkList L, ElemType e) { int j = 1; LinkList p = L-&gt;next; while (p != NULL &amp;&amp; p-&gt;data != e) { p = p-&gt;next; j++; } return p; } int main() { //定义链表头,结构体指针类型 LinkList L; LinkList search;//用来存储拿到的某一个节点 LinkList search1; printf(&quot;请在下方输入单链表的值：（^_^大于5个元素且输入9999终止^_^）\\n&quot;); CreatList1(L); printf(&quot;头插法的结果为：&quot;); PrintList(L); search = GetElem(L, 2); if (search != NULL) { printf(&quot;\\n按序号查找成功！~\\n&quot;); printf(&quot;该位置的值为：%3d\\n&quot;, search-&gt;data); } search1 = LocateElem(L, 5); /* if (search1 != NULL) { printf(&quot;\\n按序号查找成功！~\\n&quot;); printf(&quot;该的值为：%3d&quot;, search-&gt;data); } */ InsertFrontList(L, 3, 30); PrintList(L); printf(&quot;\\n-----------\\n&quot;); printf(&quot;删除后的结果为：\\n&quot;); DeleteList(L, 3); PrintList(L); printf(&quot;\\n-----------\\n&quot;); printf(&quot;请在下方输入单链表的值：（^_^大于5个元素且输入9999终止^_^）\\n&quot;); CreatList2(L); printf(&quot;尾插法的结果为：&quot;); PrintList(L); return 0; } 栈和队列 栈的入栈出栈 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #define Maxsize 50 //堆栈的操作 //LIFO-&gt;后进先出的操作方式 //s.top就是用来指向数组下标的指针 typedef int ElemType; typedef struct { ElemType data[Maxsize];//数组 int top; }SqStack; //必须使用C++的引用，因为是从中函数传值进来，改变实参的值 void InitStack(SqStack &amp;S) { S.top = -1;//栈空 } //判断栈是否为空：因为不需要改变实参的值，所以不用加引用 bool StackEmpty(SqStack S) { if (S.top == -1) { return true; } return false; } //压栈操作 //需要改变实参中的栈数值，所以需要加入引用 bool Push(SqStack&amp; S, ElemType x) { //无论是栈还是队列、链表；在进行插入操作时，一定记得要首先判断是满 if (S.top == Maxsize - 1) { return false; } //压栈操作-&gt;先进性+操作 //栈内元素存放在一个数组当中 S.data[++S.top] = x; return true; } bool GetTop(SqStack S, ElemType&amp; x) { if (StackEmpty(S)) { return false; } x = S.data[S.top]; return true; } //出栈操作 bool Pop(SqStack &amp;S,ElemType x) { if (StackEmpty(S)) { return false; } //以下两句等价于x = S.data[S.top--]; x = S.data[S.top--]; //S.top--; return true; } int main() { SqStack S;//初始化 bool flag; ElemType m; InitStack(S); flag = StackEmpty(S); if (flag) { printf(&quot;栈是空的！\\n&quot;); } //元素压栈 Push(S, 3); Push(S, 4); Push(S, 5); Push(S, 6); flag = GetTop(S, m); if (flag) { printf(&quot;得到的栈顶元素为：%d\\n&quot;, m); } flag = Pop(S, 6); if (flag) { printf(&quot;弹出的元素为：%d\\n&quot;, m); } return 0; } 队列与循环队列 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; typedef int ElemType; typedef struct LinkNode { ElemType data; struct LinkNode* next; }LinkNode; typedef struct { struct LinkNode* front, * tail; }LinkQueue; bool InitQueue(LinkQueue &amp;Q) { Q.front = Q.tail = (LinkNode*)malloc(sizeof(LinkNode)); Q.front-&gt;next = NULL; return true; } //尾插法入队 void EnQueue(LinkQueue&amp; Q, ElemType x) { LinkNode *s = (LinkNode*)malloc(sizeof(LinkNode)); s-&gt;data = x; s-&gt;next = NULL; Q.tail-&gt;next = s; Q.tail = s; } //头插法删除 bool DeQueue(LinkQueue&amp; Q, ElemType&amp; x) { //判断队列是否为空 if (Q.front == Q.tail)return false; //队头出队节点 LinkNode* p = Q.front-&gt;next; x = p-&gt;data; Q.front-&gt;next = p-&gt;next; if (Q.tail == p) { Q.front = Q.tail; } free(p); return true; } int main(void) { LinkQueue Q; ElemType data; bool ret; InitQueue(Q); EnQueue(Q, 3); EnQueue(Q, 4); EnQueue(Q, 5); EnQueue(Q, 6); EnQueue(Q, 7); ret = DeQueue(Q, data); if (ret) { printf(&quot;出队成功！！！\\n&quot;); printf(&quot;出队元素为：%d\\n&quot;,data); } else { printf(&quot;出队失败~~\\n&quot;); } return 0; } ----------------------------------------------------------- //循环队列 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; //408常考的循环队列 #define Maxsize 5 typedef int ElemType; //循环队列的结构 typedef struct { ElemType data[Maxsize]; int front, tail; }SqQueue; //初始化函数 void InitQueue(SqQueue&amp; q) { q.front = q.tail = 0; } //判断是否为空 bool isEmpty(SqQueue q) { //队头指针==队尾指针 if (q.front == q.tail) { return true; } else { return false; } } //元素入队函数 bool EnQueue(SqQueue&amp; q, ElemType x) { //先判断队列是否满队 if ((q.tail + 1) % Maxsize == q.front) { return false; } q.data[q.tail + 1] = x; q.tail = (q.tail + 1) % Maxsize; return true; } int main() { SqQueue q; bool ret; ElemType m; InitQueue(q); EnQueue(q, 1); EnQueue(q, 2); EnQueue(q, 3); return 0; } 二叉树 层次建树与三种遍历方式 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; //层次建树 //树的结构体建立 typedef char BiElemType; typedef struct BiTNode { BiElemType root; struct BiTNode* left; struct BiTNode* right; }BiTNode,*BiTree; //层次队列 typedef struct tag { BiTree p;//树的某一个节点的地址 struct tag* pnext; }tag_t,*ptag_t; //前序遍历 void PreOrder(BiTree p) { if (p != NULL) { putchar(p-&gt;root); PreOrder(p-&gt;left); PreOrder(p-&gt;right); } } //中序遍历 void InOrder(BiTree p) { if (p != NULL) { InOrder(p-&gt;left); putchar(p-&gt;root); InOrder(p-&gt;right); } } //后序遍历 void LastOrder(BiTree p) { if (p != NULL) { LastOrder(p-&gt;left); LastOrder(p-&gt;right); putchar(p-&gt;root); } } int main(void) { BiTree pnew; int i, j, pos; char c; BiTree tree = NULL;//树根 //层次建树辅助队列 ptag_t phead = NULL, ptail = NULL, listnew = NULL, pcur = NULL; while (scanf_s(&quot;%c&quot;, &amp;c) != EOF) { if (c == '\\n') { break; } pnew = (BiTree)calloc(1, sizeof(BiTNode));//calloc申请空间并对空间进行初始化 pnew-&gt;root = c; listnew = (ptag_t)calloc(1, sizeof(tag_t)); listnew-&gt;p = pnew; if (tree == NULL) { tree = pnew; phead = listnew;//队列头 ptail = listnew;//队列尾 pcur = listnew; continue; } else { ptail-&gt;pnext = listnew;//新节点入队，尾插法 ptail = listnew; } if (pcur-&gt;p-&gt;left == NULL) { pcur-&gt;p-&gt;left = pnew;//把新节点放入到当前节点的左孩子 } else if (pcur-&gt;p-&gt;right == NULL) { pcur-&gt;p-&gt;right = pnew;//把新节点放入到当前节点的左孩子 pcur = pcur-&gt;pnext;//左右都放了节点后，pcur指向队列的下一个元素 } } printf(&quot;\\n-----------前序遍历---------\\n&quot;); PreOrder(tree); printf(&quot;\\n-----------中序遍历---------\\n&quot;); InOrder(tree); printf(&quot;\\n-----------后序遍历---------\\n&quot;); LastOrder(tree); return 0; } 思考 参考二叉树的后序遍历，如何利用栈实现递归与非递归的转换？ 首先二叉树的后序遍历过程是一个自底向上的回溯过程，也就是递归中归的过程。递归过程利用栈的数据结构，由递归的外层（递归栈的底层）到base case（递归栈的顶层）；每一个递归过程细节中都封装在了函数的内部，已实现递归重复调用。而对于非递归的转化，就是将封装过程打破，利用循环嵌套的流程去实现递归调用的过程。迭代循环是一个根据base case的自底向上过程。 介绍并熟练掌握了基础的数据结构，下面就开始真正的算法之旅喽~ 双指针技巧在链表与数组中的运用 双指针分类：1.快慢指针 2.左右指针 力扣中的对应题目如下： 数组： LeetCode 力扣 难度 5. Longest Palindromic Substring 5. 最长回文子串 🟠 26. Remove Duplicates from Sorted Array 26. 删除有序数组中的重复项 🟢 27. Remove Element 27. 移除元素 🟢 83. Remove Duplicates from Sorted List 83. 删除排序链表中的重复元素 🟢 167. Two Sum II - Input Array Is Sorted 167. 两数之和 II - 输入有序数组 🟢 283. Move Zeroes 283. 移动零 🟢 344. Reverse String 344. 反转字符串 🟢 在处理数组和链表相关问题时，双指针技巧是经常用到的，双指针技巧主要分为两类：左右指针和快慢指针。 所谓左右指针，就是两个指针相向而行或者相背而行；而所谓快慢指针，就是两个指针同向而行，一快一慢。 对于单链表来说，大部分技巧都属于快慢指针。 在数组中并没有真正意义上的指针，但我们可以把索引当做数组中的指针，这样也可以在数组中施展双指针技巧，本文先讲数组相关的双指针算法，再讲链表有关的双指针算法。 Array~快慢指针技巧 数组问题中比较常见的快慢指针技巧，是让你原地修改数组。 简单解释一下什么是原地修改： 如果不是原地修改的话，我们直接 new 一个 int[] 数组，把去重之后的元素放进这个新数组中，然后返回这个新数组即可。 但是现在题目让你原地删除，不允许 new 新数组，只能在原数组上操作，然后返回一个长度，这样就可以通过返回的长度和原始数组得到我们去重后的元素有哪些了。 由于数组已经排序，所以重复的元素一定连在一起，找出它们并不难。但如果毎找到一个重复元素就立即原地删除它，由于数组中删除元素涉及数据搬移，整个时间复杂度是会达到 O(N^2)。 高效解决这道题就要用到快慢指针技巧： 我们让慢指针 slow 走在后面，快指针 fast 走在前面探路，找到一个不重复的元素就赋值给 slow 并让 slow 前进一步。 这样，就保证了 nums[0..slow] 都是无重复的元素，当 fast 指针遍历完整个数组 nums 后，nums[0..slow] 就是整个数组去重之后的结果。 //Java实现 int removeDuplicates(int[] nums){ if (nums.length == 0) { return 0; } int slow = 0,fast = 0; while (fast &lt; nums.length) { if (nums[fast] != nums[slow]) { slow++; nums[slow] = nums[fast]; } fast++; } return slow + 1; } #python实现 class Solution(object): def removeDuplicates(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: int &quot;&quot;&quot; if(len(nums) == 0): return 0 #can't assign to literal的错误来源是slow=0，fast=0写在了一行中 #要么用逗号隔开，用么分成两行写 slow=0 fast=0 while(fast &lt; len(nums)): if(nums[fast] != nums[slow]): slow += 1 nums[slow] = nums[fast] fast += 1 return slow + 1 同理，将本题的思想用于链表去重的代码实现为： ListNode deleteDuplicates(ListNode head) { if (head == null) return null; ListNode slow = head, fast = head; while (fast != null) { if (fast.val != slow.val) { // nums[slow] = nums[fast]; slow.next = fast; // slow++; slow = slow.next; } // fast++ fast = fast.next; } // 断开与后面重复元素的连接 slow.next = null; return head; } 类似的，例如力扣中的移动零题目： 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 本质就是数组去重后将尾巴部分元素改为0 class Solution(object): def moveZeroes(self, nums): &quot;&quot;&quot; :type nums: List[int] :rtype: None Do not return anything, modify nums in-place instead. &quot;&quot;&quot; #老套路，设置快慢指针 slow=0 fast=0 #核心代码区，区分不同目标值的设置 while(fast &lt;len(nums)): if(nums[fast] != 0): nums[slow] = nums[fast] slow += 1 fast += 1 #与前面题唯一的不同点，是将数组去重后尾部元素修改为0，此处我用的for循环，有其他新方法欢迎大佬们修改提出意见 for i in range(slow,len(nums)): nums[i] = 0 数组移除元素 class Solution: def removeElement(self, nums: List[int], val: int) -&gt; int: slow,fast = 0,0 while(fast &lt; len(nums)): if(nums[fast] != val): nums[slow] = nums[fast] slow += 1 fast += 1 return slow 移除数组中的重复元素 class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: slow,fast = 0,0 while(fast &lt; len(nums)): if(nums[fast] != nums[slow]): slow += 1 nums[slow] = nums[fast] fast += 1 return slow + 1 去重的核心代码块 while(fast &lt;len(nums)): if(nums[fast] != 0): nums[slow] = nums[fast] slow += 1 fast += 1 对于核心代码块而言，在熟练使用的情况下要记牢，方便后序写程序是效率提高。 Array~左右指针技巧 二分查找算法 LeetCode 力扣 难度 34. Find First and Last Position of Element in Sorted Array 34. 在排序数组中查找元素的第一个和最后一个位置 🟠 704. Binary Search 704. 二分查找 🟢 首先介绍以下二分查找的代码框架： 其中 ... 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。 另外提前说明一下，计算 mid 时需要防止溢出，代码中 left + (right - left) / 2 就和 (left + right) / 2 的结果相同，但是有效防止了 left 和 right 太大，直接相加导致溢出的情况。 def binarySearch(int[] nums, int target) { #设置左右指针 int left = 0, right = ...; while(...) { #关键在mid值的设定与左右边界确定 int mid = left + (right - left) / 2; if (nums[mid] == target) { ... } else if (nums[mid] &lt; target) { left = ... } else if (nums[mid] &gt; target) { right = ... } } return ...; } 二分查找并不简单，Knuth 大佬（著有大部头《计算机程序设计》一书，无数程序员的圣经）都说二分查找：思路很简单，细节是魔鬼。二分查找真正的坑根本就不是那些有关于溢出的细节问题，而是在于到底要给 mid 加一还是减一，while 里到底用 &lt;= 还是 &lt;。 几个最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。 我们要深入细节，比如不等号是否应该带等号，mid 是否应该加一等等。分析这些细节的差异以及出现这些差异的原因，保证你能灵活准确地写出正确的二分查找算法。 大家写二分法经常写乱，主要是因为对区间的定义没有想清楚，区间的定义就是不变量。要在二分查找的过程中，保持不变量，就是在while寻找中每一次边界的处理都要坚持根据区间的定义来操作，这就是循环不变量规则。 写二分法，区间的定义一般为两种，左闭右闭即[left, right]，或者左闭右开即[left, right)。 从本书中学到了，在分析二分查找时，对于选择分支结构if-else很少使用，而是用else if 取代，这样可以展示二分查找的所有细节。 寻找一个数 这段代码可以解决力扣第 704 题「 二分查找」。 下面提出解决本题需要关注的细节： 搜索一个元素时，搜索区间两端闭；while条件带等号，否则需要打补丁。 if相等就返回，其他的是甭操心；mid必须加减一，因为区间两端闭。 while结束就凉凉，凄凄惨惨返-1. class Solution(object): def search(self, nums, target): &quot;&quot;&quot; :type nums: List[int] :type target: int :rtype: int &quot;&quot;&quot; left = 0 right = len(nums)-1 #易错点 while(left &lt;= right): mid = left + (right - left)/2 if(nums[mid] == target): return mid elif(nums[mid] &lt; target): #对于mid的操作时二分查找的一个难点。 left = mid + 1 elif(nums[mid] &gt; target): right = mid - 1 return -1 while(left &lt;= right)的终止条件是：left == right + 1-&gt;[right + 1,right]。 while(left &lt; right)的终止条件是：left == right -&gt;[left,right]。 寻找左侧边界 左侧边界是左闭右开的搜索区间：[left,right),因此需要注意while的条件是while(left&lt;right)。 right = len(nums) 寻找右侧边界 反转系列与回文 回文模板： bool isPalindrome(const string&amp; s,int start,int end){ for(int i = start,j = end;i &lt; j;i++,j--){ if(s[i] != s[j]){ return false; } } return true; 迭代反转单链表 # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def reverseList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; if head == None or head.next == None: return head pre = None tmp = None #切记理解终止条件 while(head != None): #迭代反转过程 tmp = head.next head.next = pre pre = head head = tmp return pre 递归反转单链表 # Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def reverseList(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; #特殊情况 if head == None or head.next == None: return head last = self.reverseList(head.next) head.next.next = head head.next = None return last 回文链表 #数组模拟 class Solution: def isPalindrome(self, head: ListNode) -&gt; bool: length = 0 tmp = head while tmp: #求链表长度 length += 1 tmp = tmp.next result = [0] * length tmp = head index = 0 while tmp: #链表元素加入数组 result[index] = tmp.val index += 1 tmp = tmp.next i, j = 0, length - 1 while i &lt; j: # 判断回文 if result[i] != result[j]: return False i += 1 j -= 1 return True #反转后半部分链表 class Solution: def isPalindrome(self, head: ListNode) -&gt; bool: if head == None or head.next == None: return True slow, fast = head, head while fast and fast.next: pre = slow slow = slow.next fast = fast.next.next pre.next = None # 分割链表 cur1 = head # 前半部分 cur2 = self.reverseList(slow) # 反转后半部分，总链表长度如果是奇数，cur2比cur1多一个节点 while cur1: if cur1.val != cur2.val: return False cur1 = cur1.next cur2 = cur2.next return True def reverseList(self, head: ListNode) -&gt; ListNode: cur = head pre = None while(cur!=None): temp = cur.next # 保存一下cur的下一个节点 cur.next = pre # 反转 pre = cur cur = temp return pre 反转整数 class Solution: def reverse(self, x: int) -&gt; int: if(x == 0): return 0 if(x &gt; 0): y = int(str(x)[::-1]) return y if -2147483648&lt;y&lt;2147483647 else 0 if(x &lt; 0): y = -int(str(abs(x))[::-1]) return y if -2147483648&lt;y&lt;2147483647 else 0 最长回文字符串 class Solution: def longestPalindrome(self, s: str) -&gt; str: res = ' ' for i in range(len(s)): start = max(0,i-len(res)-1) tmp = s[start : i+1] #分情况：s中含有字母的个数 if tmp == tmp[::-1]: res = tmp else: tmp = tmp[1:] if tmp == tmp[::-1]: res = tmp return res 反转字符串 class Solution: def reverseString(self, s: List[str]) -&gt; None: &quot;&quot;&quot; Do not return anything, modify s in-place instead. &quot;&quot;&quot; left, right = 0, len(s) - 1 # 该方法已经不需要判断奇偶数，经测试后时间空间复杂度比用 for i in range(right//2)更低 # 推荐该写法，更加通俗易懂 while left &lt; right: s[left], s[right] = s[right], s[left] left += 1 right -= 1 Linked List~双指针技巧 链表： LeetCode 力扣 难度 19. Remove Nth Node From End of List 19. 删除链表的倒数第 N 个结点 🟠 21. Merge Two Sorted Lists 21. 合并两个有序链表 🟢 23. Merge k Sorted Lists 23. 合并K个升序链表 🔴 86. Partition List 86. 分隔链表 🟠 141. Linked List Cycle 141. 环形链表 🟢 142. Linked List Cycle II 142. 环形链表 II 🟠 160. Intersection of Two Linked Lists 160. 相交链表 🟢 876. Middle of the Linked List 876. 链表的中间结点 🟢 解决问题： 本节的难点在于，目前无法突破在力扣中对于**「虚拟头结点」**的建立使用。所以代码先按东哥Java实现，努力突破难点后，全部更新为python代码。 设计链表-充分掌握 在链表类中实现这些功能： -get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 -addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 -addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 -addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。如果index小于0，则在头部插入节点。 -deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 # 单链表 class Node: def __init__(self, val): self.val = val self.next = None class MyLinkedList: def __init__(self): self._head = Node(0) # 虚拟头部节点 self._count = 0 # 添加的节点数 def get(self, index: int) -&gt; int: &quot;&quot;&quot; Get the value of the index-th node in the linked list. If the index is invalid, return -1. &quot;&quot;&quot; if 0 &lt;= index &lt; self._count: node = self._head for _ in range(index + 1): node = node.next return node.val else: return -1 def addAtHead(self, val: int) -&gt; None: &quot;&quot;&quot; Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. &quot;&quot;&quot; self.addAtIndex(0, val) def addAtTail(self, val: int) -&gt; None: &quot;&quot;&quot; Append a node of value val to the last element of the linked list. &quot;&quot;&quot; self.addAtIndex(self._count, val) def addAtIndex(self, index: int, val: int) -&gt; None: &quot;&quot;&quot; Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. &quot;&quot;&quot; if index &lt; 0: index = 0 elif index &gt; self._count: return # 计数累加 self._count += 1 add_node = Node(val) prev_node, current_node = None, self._head for _ in range(index + 1): prev_node, current_node = current_node, current_node.next else: prev_node.next, add_node.next = add_node, current_node def deleteAtIndex(self, index: int) -&gt; None: &quot;&quot;&quot; Delete the index-th node in the linked list, if the index is valid. &quot;&quot;&quot; if 0 &lt;= index &lt; self._count: # 计数-1 self._count -= 1 prev_node, current_node = None, self._head for _ in range(index + 1): prev_node, current_node = current_node, current_node.next else: prev_node.next, current_node.next = current_node.next, None # 双链表 # 相对于单链表, Node新增了prev属性 class Node: def __init__(self, val): self.val = val self.prev = None self.next = None class MyLinkedList: def __init__(self): self._head, self._tail = Node(0), Node(0) # 虚拟节点 self._head.next, self._tail.prev = self._tail, self._head self._count = 0 # 添加的节点数 def _get_node(self, index: int) -&gt; Node: # 当index小于_count//2时, 使用_head查找更快, 反之_tail更快 if index &gt;= self._count // 2: # 使用prev往前找 node = self._tail for _ in range(self._count - index): node = node.prev else: # 使用next往后找 node = self._head for _ in range(index + 1): node = node.next return node def get(self, index: int) -&gt; int: &quot;&quot;&quot; Get the value of the index-th node in the linked list. If the index is invalid, return -1. &quot;&quot;&quot; if 0 &lt;= index &lt; self._count: node = self._get_node(index) return node.val else: return -1 def addAtHead(self, val: int) -&gt; None: &quot;&quot;&quot; Add a node of value val before the first element of the linked list. After the insertion, the new node will be the first node of the linked list. &quot;&quot;&quot; self._update(self._head, self._head.next, val) def addAtTail(self, val: int) -&gt; None: &quot;&quot;&quot; Append a node of value val to the last element of the linked list. &quot;&quot;&quot; self._update(self._tail.prev, self._tail, val) def addAtIndex(self, index: int, val: int) -&gt; None: &quot;&quot;&quot; Add a node of value val before the index-th node in the linked list. If index equals to the length of linked list, the node will be appended to the end of linked list. If index is greater than the length, the node will not be inserted. &quot;&quot;&quot; if index &lt; 0: index = 0 elif index &gt; self._count: return node = self._get_node(index) self._update(node.prev, node, val) def _update(self, prev: Node, next: Node, val: int) -&gt; None: &quot;&quot;&quot; 更新节点 :param prev: 相对于更新的前一个节点 :param next: 相对于更新的后一个节点 :param val: 要添加的节点值 &quot;&quot;&quot; # 计数累加 self._count += 1 node = Node(val) prev.next, next.prev = node, node node.prev, node.next = prev, next def deleteAtIndex(self, index: int) -&gt; None: &quot;&quot;&quot; Delete the index-th node in the linked list, if the index is valid. &quot;&quot;&quot; if 0 &lt;= index &lt; self._count: node = self._get_node(index) # 计数-1 self._count -= 1 node.prev.next, node.next.prev = node.next, node.prev 代码随想录：carlsun-2 合并两个有序链表 这个算法的逻辑类似于拉拉链，两个需要合并的单链表，类似于拉链两侧的锯齿，指针 p 就好像拉链的拉索，将两个有序链表合并；过程与蛋白质的形成过程高度相似。（高中生物知识的复习） 运用的技巧：代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是 dummy 节点。如果不使用 dummy 虚拟节点，代码会复杂很多，而有了 dummy 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。 //java实现 class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { // 虚拟头结点 ListNode dummy = new ListNode(-1), p = dummy; ListNode p1 = l1, p2 = l2; while (p1 != null &amp;&amp; p2 != null) { // 比较 p1 和 p2 两个指针 // 将值较小的的节点接到 p 指针 if (p1.val &gt; p2.val) { p.next = p2; p2 = p2.next; } else { p.next = p1; p1 = p1.next; } // p 指针不断前进 p = p.next; } if (p1 != null) { p.next = p1; } if (p2 != null) { p.next = p2; } return dummy.next; } } 运用递归方法实现合并：程序的可读性降低，但代码更简洁——递归思想后序总结，需要掌握好！ # Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def mergeTwoLists(self, list1, list2): &quot;&quot;&quot; :type list1: Optional[ListNode] :type list2: Optional[ListNode] :rtype: Optional[ListNode] &quot;&quot;&quot; if not list1: return list2 if not list2: return list1 if(list1.val &lt;= list2.val): #递归核心 list1.next = self.mergeTwoLists(list1.next,list2) return list1 else: #递归核心 list2.next = self.mergeTwoLists(list1,list2.next) return list2 链表的分解 在合并两个有序链表时让你合二为一，而这里需要分解让你把原链表一分为二。具体来说，我们可以把原链表分成两个小链表，一个链表中的元素大小都小于 x，另一个链表中的元素都大于等于 x，最后再把这两条链表接到一起，就得到了题目想要的结果。 3、合并 k 个有序链表 合并 k 个有序链表的逻辑类似合并两个有序链表，难点在于，如何快速得到 k 个节点中的最小节点，接到结果链表上？ 这里我们就要用到 优先级队列（二叉堆） 这种数据结构，把链表节点放入一个最小堆，就可以每次获得 k 个节点中的最小节点： ListNode mergeKLists(ListNode[] lists) { if (lists.length == 0) return null; // 虚拟头结点 ListNode dummy = new ListNode(-1); ListNode p = dummy; // 优先级队列，最小堆 PriorityQueue&lt;ListNode&gt; pq = new PriorityQueue&lt;&gt;( lists.length, (a, b)-&gt;(a.val - b.val)); // 将 k 个链表的头结点加入最小堆 for (ListNode head : lists) { if (head != null) pq.add(head); } while (!pq.isEmpty()) { // 获取最小节点，接到结果链表中 ListNode node = pq.poll(); p.next = node; if (node.next != null) { pq.add(node.next); } // p 指针不断前进 p = p.next; } return dummy.next; } 这个算法是面试常考题，它的时间复杂度: 优先队列 pq 中的元素个数最多是 k，所以一次 poll 或者 add 方法的时间复杂度是 O(logk)；所有的链表节点都会被加入和弹出 pq，所以算法整体的时间复杂度是 O(Nlogk)，其中 k 是链表的条数，N 是这些链表的节点总数。 寻找单链表的中点 力扣第 876 题「 链表的中间结点」就是这个题目，问题的关键也在于我们无法直接得到单链表的长度 n，常规方法也是先遍历链表计算 n，再遍历一次得到第 n / 2 个节点，也就是中间节点。 如果想一次遍历就得到中间节点，也需要耍点小聪明，使用「快慢指针」的技巧： 我们让两个指针 slow 和 fast 分别指向链表头结点 head。 每当慢指针 slow 前进一步，快指针 fast 就前进两步，这样，当 fast 走到链表末尾时，slow 就指向了链表中点。 # Definition for singly-linked list. # class ListNode(object): # def __init__(self, val=0, next=None): # self.val = val # self.next = next class Solution(object): def middleNode(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: ListNode &quot;&quot;&quot; #快慢指针初始化指向 head slow = head fast = head while(fast != None and fast.next != None): slow = slow.next fast = fast.next.next return slow 寻找单链表的倒数第 k 个节点 以下是东哥文章中的详细解题思路： 从前往后寻找单链表的第 k 个节点很简单，一个 for 循环遍历过去就找到了，但是如何寻找从后往前数的第 k 个节点呢？ 那你可能说，假设链表有 n 个节点，倒数第 k 个节点就是正数第 n - k + 1 个节点，不也是一个 for 循环的事儿吗？ 是的，但是算法题一般只给你一个 ListNode 头结点代表一条单链表，你不能直接得出这条链表的长度 n，而需要先遍历一遍链表算出 n 的值，然后再遍历链表计算第 n - k + 1 个节点。 也就是说，这个解法需要遍历两次链表才能得到出倒数第 k 个节点 那么，我们能不能只遍历一次链表，就算出倒数第 k 个节点？可以做到的，如果是面试问到这道题，面试官肯定也是希望你给出只需遍历一次链表的解法。 这个解法就比较巧妙了，假设 k = 2，思路如下： 首先，我们先让一个指针 p1 指向链表的头节点 head，然后走 k 步： 现在的 p1，只要再走 n - k 步，就能走到链表末尾的空指针了对吧？ 趁这个时候，再用一个指针 p2 指向链表头节点 head： 接下来就很显然了，让 p1 和 p2 同时向前走，p1 走到链表末尾的空指针时前进了 n - k 步，p2 也从 head 开始前进了 n - k 步，停留在第 n - k + 1 个节点上，即恰好停链表的倒数第 k 个节点上： 这样，只遍历了一次链表，就获得了倒数第 k 个节点 p2。 东哥很详细地说了一大堆，其实简单总结起来就是：先利用for循环让快指针先走k步，在利用上题寻找中点思路即可解决。 # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def getKthFromEnd(self, head, k): &quot;&quot;&quot; :type head: ListNode :type k: int :rtype: ListNode &quot;&quot;&quot; slow = head fast = head #先让快指针fast向前走k步 for i in range(k): fast = fast.next #while(fast != None and fast.next != None)多加一个fast的next的结果为[3,4,5]与原题结果不符合;注意条件控制 while(fast != None): slow = slow.next fast = fast.next return slow 判断单链表是否包含环并找出环起点 经典问题的解决方案仍然是：快慢指针。每当慢指针 slow 前进一步，快指针 fast 就前进两步。 如果 fast 最终遇到空指针，说明链表中没有环；如果 fast 最终和 slow 相遇，那肯定是 fast 超过了 slow 一圈，说明链表中含有环。只需要把寻找链表中点的代码稍加修改就行了： # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def hasCycle(self, head): &quot;&quot;&quot; :type head: ListNode :rtype: bool &quot;&quot;&quot; slow = head fast = head #寻找中点的套路 while(fast != None and fast.next != None): #快指针前进两步 fast = head.next.next #慢指针前进一步 slow = head.next #当快指针比慢指针多走一圈时，相遇便成环 if(fast == slow): return True return False #不知道为啥这个代码总是运行超时，是时间复杂度太大吗？-2022.06.21 判断两个单链表是否相交并找出交点 如果用两个指针 p1 和 p2 分别在两条链表上前进，并不能同时走到公共节点，也就无法得到相交节点 c1。 解决这个问题的关键是，通过某些方式，让 p1 和 p2 能够同时到达相交节点 c1。 所以，我们可以让 p1 遍历完链表 A 之后开始遍历链表 B，让 p2 遍历完链表 B 之后开始遍历链表 A，这样相当于「逻辑上」两条链表接在了一起。 如果这样进行拼接，就可以让 p1 和 p2 同时进入公共部分，也就是同时到达相交节点 c1 # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None class Solution(object): def getIntersectionNode(self, headA, headB): &quot;&quot;&quot; :type head1, head1: ListNode :rtype: ListNode &quot;&quot;&quot; p1 = headA p2 = headB while(p1 != p2): #p1 走一步，如果走到 A 链表末尾，转到 B 链表 if(p1 == None): p1 = headB else: p1 = p1.next #p2 走一步，如果走到 B 链表末尾，转到 A 链表 if(p2 == None): p2 = headA else: p2 = p2.next return p1 滑动窗口 双指针运用最难得部分！ LeetCode 力扣 难度 3. Longest Substring Without Repeating Characters 3. 无重复字符的最长子串 🟠 438. Find All Anagrams in a String 438. 找到字符串中所有字母异位词 🟠 567. Permutation in String 567. 字符串的排列 🟠 76. Minimum Window Substring 76. 最小覆盖子串 🔴 - 剑指 Offer 48. 最长不含重复字符的子字符串 🟠 - 剑指 Offer II 014. 字符串中的变位词 🟠 - 剑指 Offer II 015. 字符串中的所有变位词 🟠 - 剑指 Offer II 016. 不含重复字符的最长子字符串 🟠 - 剑指 Offer II 017. 含有所有字符的最短字符串 🔴 题目特点： 最长/最短-&gt;子数组、子序列、子串 解决一类最难掌握的双指针技巧：滑动窗口技巧；这个算法技巧的思路非常简单，就是维护一个窗口，不断滑动，然后更新答案。 这个算法技巧的时间复杂度是 O(N)，比字符串暴力算法要高效得多。 其实困扰大家的，不是算法的思路，而是各种细节问题。比如说如何向窗口中添加新元素，如何缩小窗口，在窗口滑动的哪个阶段更新结果。即便你明白了这些细节，也容易出 bug，找 bug 还不知道怎么找，真的挺让人心烦的。 框架： /* 滑动窗口算法框架 */ void slidingWindow(string s) { unordered_map&lt;char, int&gt; window; int left = 0, right = 0; while (right &lt; s.size()) { // c 是将移入窗口的字符 char c = s[right]; // 增大窗口 right++; // 进行窗口内数据的一系列更新 ... /*** debug 输出的位置 ***/ printf(&quot;window: [%d, %d)\\n&quot;, left, right); /********************/ // 判断左侧窗口是否要收缩 while (window needs shrink) { // d 是将移出窗口的字符 char d = s[left]; // 缩小窗口 left++; // 进行窗口内数据的一系列更新 ... } } } 其中两处 ... 表示的更新窗口数据的地方，到时候你直接往里面填就行了；而且，这两个 ... 处的操作分别是扩大和缩小窗口的更新操作。 在处理字符串反面，c/c++要比Java有优势。 滑动窗口算法的思路： 1、我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引左闭右开区间 [left, right) 称为一个「窗口」。 PS：理论上你可以设计两端都开或者两端都闭的区间，但设计为左闭右开区间是最方便处理的。因为这样初始化 left = right = 0 时区间 [0, 0) 中没有元素，但只要让 right 向右移动（扩大）一位，区间 [0, 1) 就包含一个元素 0 了。如果你设置为两端都开的区间，那么让 right 向右移动一位后开区间 (0, 1) 仍然没有元素；如果你设置为两端都闭的区间，那么初始区间 [0, 0] 就包含了一个元素。这两种情况都会给边界处理带来不必要的麻烦。 2、我们先不断地增加 right 指针扩大窗口 [left, right)，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。 3、此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right)，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。 4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。 这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解，也就是最短的覆盖子串。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动，这就是「滑动窗口」这个名字的来历。 长度最小子数组 给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 class Solution(object): def minSubArrayLen(self, target, nums): &quot;&quot;&quot; :type target: int :type nums: List[int] :rtype: int &quot;&quot;&quot; #判断极端情况 if len(nums) == 0: return 0 #确定最值 res = len(nums) + 1 s = 0 #定义双指针 right = left = 0 #扩大窗口 while(right &lt; len(nums)): s = s + nums[right] right += 1 #比较目标值，扩大窗口的终止条件 while s &gt;= target: #righ-left为窗口内的元素 res = min(res,right-left) #从左侧缩小窗口 s = s - nums[left] left += 1 #所有元素的和小于target if res == len(nums)+1: return 0 #符合条件输出 else: return res 无重复字符的最长子串 class Solution(object): def lengthOfLongestSubstring(self, s): &quot;&quot;&quot; :type s: str :rtype: int &quot;&quot;&quot; #极端条件判断 if len(s) == 0: return 0 #定义所需变量 left = count = res = 0 #遍历列表的时间复杂度是O（n），遍历集合的时间复杂度是O（1） windows = set() #有指针依次向后遍历 for i in range(len(s)): #计数 count += 1 #右指针指向元素已经在窗口中，即出现重复元素 while s[i] in windows: #缩小窗口 windows.remove(s[left]) count -= 1 left += 1 #保留最值 res = max(res,count) #窗口右侧加入元素 windows.add(s[i]) #返回结果 return res 乘积小于K的子数组 class Solution(object): def numSubarrayProductLessThanK(self, nums, k): &quot;&quot;&quot; :type nums: List[int] :type k: int :rtype: int &quot;&quot;&quot; #特殊情况 if k &lt;= 1: return 0 #双指针 left = 0 right = 0 #记录器与计数器 res = 1 result = 0 #扩大窗口 while right &lt; len(nums): res *= nums[right] #缩小窗口 while res &gt;= k: res /= nums[left] left += 1 result += (right-left+1) right += 1 return result 最大连续1的个数 class Solution: def longestOnes(self, nums: List[int], k: int) -&gt; int: #设置双指针 left = 0 right = 0 #记录器和计数器 res = 0 count = 0 while right &lt; len(nums): #扩大窗口 if nums[right] == 0: count += 1 right += 1 #缩小窗口 if count &gt; k: if nums[left] == 0: count -= 1 left += 1 res = max(res,right - left) return res 二叉树 视频导学： 二叉树/递归的框架思维（纲领篇） 二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 回溯算法核心框架 和 动态规划核心框架。二叉树模型几乎是所有高级算法的基础，尤其是那么多人说对递归的理解不到位，更应该好好刷二叉树相关题目。 2022.08.28添加：对于递归函数书写的一些新的思考与启发 学习本部分主要是学会使用递归函数的书写逻辑： 再次温习一下之前学过的递归三部曲： 1.递归函数的参数和返回值的设置 比如在在写回溯函数时，函数参数需要自己去定义。此时就要考虑，那些参数是我需要的，那些参数是题目中已知的；自定义的这个函数的类型是什么：viod泛型？bool型？int型？ void traverse(参数1，参数2....){ } 2.终止条件 多数情况下就是遍历到树的根节点后开始返回； if(rooot == NULL){ return; } 3.递归的逻辑 在终止条件之后紧接着就是递归函数的调用；绝大多数递归的逻辑是前序逻辑，题目让干啥咱就干啥，而且递归的顺序一般就是先左子树后右子树，从上到下的DFS。 //前序操作（看题目要求） traverse(root-&gt;left,....); traverse(root-&gt;right,....); 对于大多数的算法，暴力解决是可以的；但是无数个for循环嵌套既浪费时间又浪费空间，当情况较复杂是，for循环嵌套必定会出错。而递归回溯函数的书写，就是让计算机自己去深处遍历迭代，空间时间都可节省，可谓是计算机思维的精髓之处。 树既有递归遍历又有迭代遍历，在迭代遍历时一定要注意while循环的终止条件，一般是当节点不为空时，终止循环while；即：while(!=root) 二叉树-纲领篇 LeetCode 力扣 难度 104. Maximum Depth of Binary Tree 104. 二叉树的最大深度 🟢 144. Binary Tree Preorder Traversal 144. 二叉树的前序遍历 🟢 543. Diameter of Binary Tree 543. 二叉树的直径 🟢 - 剑指 Offer 55 - I. 二叉树的深度 🟢 总的老说，二叉树的两种解决思路： 1.遍历-&gt;回溯问题-&gt;前序操作 2.分解-&gt;动规问题-&gt;后序操作 遇到一道二叉树的题目时的通用思考过程是： 1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现。 2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值。 3、无论使用哪一种思维模式，你都要明白二叉树的每一个节点需要做什么，需要在什么时候（前中后序）做。 二叉树的框架思维： void traverse(TreeNode root) { if (root == null) { return; } // 前序位置 traverse(root.left); // 中序位置 traverse(root.right); // 后序位置 以数组和链表为例，看遍历和分解的区别与联系： /* 迭代遍历数组 */ #void traverse(int[] arr) { #for (int i = 0; i &lt; arr.length; i++) { #} #} def traverse(int[] arr): for i in range(len(arr)): /* 递归遍历数组 */ #void traverse(int[] arr, int i) { #if (i == arr.length) { #return; #} #// 前序位置 #traverse(arr, i + 1); #// 后序位置 #} def traverse(int[] arr, int i): if (i == len(arr)): return // 前序位置 traverse(arr, i + 1); // 后序位置 /* 迭代遍历单链表 */ #void traverse(ListNode head) { #for (ListNode p = head; p != null; p = p.next) { #} #} def traverse(ListNode head): p = head while(p != None and p.next != None): p = p.next /* 递归遍历单链表 */ #void traverse(ListNode head) { #if (head == null) { #return; #} #// 前序位置 #traverse(head.next); #// 后序位置 #} def traverse(ListNode head): if (head == None): return // 前序位置 traverse(head.next); // 后序位置 递归三部曲： 递归函数的参数返回值 终止条件 递归的逻辑 二叉树的最大深度 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def maxDepth(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; #分解问题：先找左右子树的最大深度然后加一-动态规划思路(后序位置操作) #递归到根节点 if(root == None): return 0 leftmax = self.maxDepth(root.left) rightmax = self.maxDepth(root.right) #推到原二叉树的最大深度 return max(leftmax,rightmax) + 1 #回溯思路 class Solution { int depth = 0; int res = 0; public int maxDepth(TreeNode root) { traverse(root); return res; } // 遍历二叉树 void traverse(TreeNode root) { if (root == null) { return; } // 前序遍历位置 depth++; // 遍历的过程中记录最大深度 res = Math.max(res, depth); traverse(root.left); traverse(root.right); // 后序遍历位置 depth--; } } 二叉树最小深度 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def minDepth(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; if not root: return 0 if not root.left and not root.right: return 1 min_depth = 10**9 if root.left: min_depth = min(self.minDepth(root.left), min_depth) # 获得左子树的最小高度 if root.right: min_depth = min(self.minDepth(root.right), min_depth) # 获得右子树的最小高度 return min_depth + 1 二叉树的遍历 前序遍历 递归解法 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right #递归解法 class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: def preorder(root: TreeNode): if not root: return res.append(root.val) preorder(root.left) preorder(root.right) res = list() preorder(root) return res # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def preorderTraversal(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[int] &quot;&quot;&quot; #保存结果 res = [] #定义遍历函数 def traversal(root): #根节点判断 if root == None: return res.append(root.val) traversal(root.left) traversal(root.right) traversal(root) return res 迭代解法 class Solution: def preorderTraversal(self, root: TreeNode) -&gt; List[int]: res = list() if not root: return res stack = [] node = root while stack or node: while node: res.append(node.val) stack.append(node) node = node.left node = stack.pop() node = node.right return res 中序遍历 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def inorderTraversal(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[int] &quot;&quot;&quot; #保存结果 res = [] def traervsal(root): #根节点判断 if root == None: return #递归遍历 traervsal(root.left) #中序操作 res.append(root.val) traervsal(root.right) traervsal(root) return res 后序遍历 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def postorderTraversal(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[int] &quot;&quot;&quot; #保存结果 res = [] #定义遍历函数 def traversal(root): if root == None: return traversal(root.left) traversal(root.right) #后序操作 res.append(root.val) traversal(root) return res 二叉树的最大直径 后序遍历 # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def diameterOfBinaryTree(self, root: TreeNode) -&gt; int: self.ans = 1 def depth(node): # 访问到空节点了，返回0 if not node: return 0 # 左孩子为根的子树的深度 L = depth(node.left) # 右孩子为根的子树的深度 R = depth(node.right) # 计算d_node即L+R+1 并更新ans self.ans = max(self.ans, L + R + 1) # 返回该节点为根的子树的深度 return max(L, R) + 1 depth(root) return self.ans - 1 二叉树的层序遍历 层序遍历就是从左到右一层一层去遍历二叉树。需要借用一个辅助数据结构即队列来实现，队列先进先出，符合一层一层遍历的逻辑，而是用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上[1] 层序遍历 #层序遍历迭代法： # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def levelOrder(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[List[int]] &quot;&quot;&quot; results = [] if not root: return results from collections import deque que = deque([root]) while que: size = len(que) result = [] for _ in range(size): cur = que.popleft() result.append(cur.val) if cur.left: que.append(cur.left) if cur.right: que.append(cur.right) results.append(result) return results #层序遍历递归法 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def levelOrder(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[List[int]] &quot;&quot;&quot; res = [] def cengxu(root,depth): if not root: return [] if len(res) == depth: res.append([]) res[depth].append(root.val) if root.left: cengxu(root.left,depth+1) if root.right: cengxu(root.right,depth+1) cengxu(root,0) return res #[[3],[9,20],[15,7]]最后的结果是列表的嵌套 #自底向上层序遍历 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def levelOrderBottom(self, root: TreeNode) -&gt; List[List[int]]: #记录结果 res = [] #定义层序遍历函数 def cengxu(root,depth): #根节点判断 if not root: return None #一开始很不理解这一步 #观察结果:[[15,7],[9,20],[3]]；涉及到列表的嵌套 #每当深度加一,就要增加一个子列表 if len(res) == depth: res.append([]) res[depth].append(root.val) if root.left: cengxu(root.left,depth + 1) if root.right: cengxu(root.right,depth + 1) cengxu(root,0) return res[::-1] 二叉树的右视图 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def rightSideView(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[int] &quot;&quot;&quot; #结果记录 res = [] #定义层序遍历函数 def cengxu(root,depth): if not root: return None if len(res) == depth: res.append(root.val) #res[depth].append(root.val) #只去遍历右子树-准确来说是去遍历每个节点的右子树 if root.right: cengxu(root.right,depth + 1) if root.left: cengxu(root.left,depth + 1) cengxu(root,0) return res 计算二叉树每层节点的平均数 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def averageOfLevels(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[float] &quot;&quot;&quot; #保存结果 res = [] ans = [] #定义层序遍历函数 def cengxu(root,depth): if not root: return None if len(res) == depth: res.append([]) res[depth].append(root.val) #遍历左右子树 if root.left: cengxu(root.left,depth + 1) if root.right: cengxu(root.right,depth + 1) cengxu(root,0) for i in range(len(res)): sum1 = sum(res[i]) num = len(res[i]) ans.append(sum1 / num) return ans 二叉树-思路篇 层序遍历+栈就是后序遍历结果 刷完上面纲领篇幅的一些体会： 二叉树重要的部分：框架+细节；框架主要是对递归函数的书写，细节就是-前序遍历OR后序遍历-代码的摆放位置 LeetCode 力扣 难度 114. Flatten Binary Tree to Linked List 114. 二叉树展开为链表 🟠 116. Populating Next Right Pointers in Each Node 116. 填充每个节点的下一个右侧节点指针 🟠 226. Invert Binary Tree 226. 翻转二叉树 🟢 - 剑指 Offer 27. 二叉树的镜像 🟢 反转二叉树 反转的思想就是借助tmp指针进行左右节点的交换 分解问题思路： # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def invertTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; #判断根节点 if root == None: return #分解问题的思路 self.invertTree(root.left) self.invertTree(root.right) tmp = root.left root.left = root.right root.right = tmp return root 回溯思路： # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def invertTree(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: TreeNode &quot;&quot;&quot; self.traverse(root) return root def traverse(self, root): if root == None: return #前序位置 tmp = root.left root.left = root.right root.right = tmp #遍历框架，去遍历左右子树的节点 self.traverse(root.left) self.traverse(root.right) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* invertTree(TreeNode* root) { /* //终止节点判断 //从上到下递归遍历 if(root == NULL) return root; swap(root-&gt;left,root-&gt;right); invertTree(root-&gt;left); invertTree(root-&gt;right); return root; */ //迭代遍历 if(root == NULL) return root; stack&lt;TreeNode*&gt; st; st.push(root); while(!st.empty()){ TreeNode* node = st.top(); st.pop(); swap(node-&gt;left,node-&gt;right); if(node-&gt;right) st.push(node-&gt;right); if(node-&gt;left) st.push(node-&gt;left); } return root; } }; 对称二叉树 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def isSymmetric(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: bool &quot;&quot;&quot; if not root: return True return self.compare(root.left, root.right) def compare(self, left, right): #对称二叉树的条件 if left != None and right == None: return False elif left == None and right != None: return False elif left == None and right == None: return True elif left.val != right.val: return False #此时就是左右节点相同进入下一层遍历 ots = self.compare(left.left,right.right) ins = self.compare(left.right,right.left) isSymmetric = ots and ins return isSymmetric 填充每个节点的下一个右侧节点指针 前序遍历： 前序遍历时要定义一个traverse函数用于递归前序节点。 &quot;&quot;&quot; # Definition for a Node. class Node(object): def __init__(self, val=0, left=None, right=None, next=None): self.val = val self.left = left self.right = right self.next = next &quot;&quot;&quot; class Solution(object): def connect(self, root): &quot;&quot;&quot; :type root: Node :rtype: Node &quot;&quot;&quot; #根节点情况 if root == None: return self.traverse(root.left,root.right) return root def traverse(self,node1,node2): if node1 == None and node2 == None: return #连接传入的两个节点 node1.next = node2 #前序遍历 self.traverse(node1.left,node1.right) self.traverse(node2.left,node2.right) self.traverse(node1.right,node2.left) 将二叉树展开为链表 首先通过遍历寻求解题思路：发现遍历虽然得到了前序遍历结果但是无法把原来的二叉树拉平为一个链表 因此寻求分解问题的解决方法：先拉平左子树，在拉平右子树；最后将右子树嫁接到左子树上即可完成。 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def flatten(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: None Do not return anything, modify root in-place instead. &quot;&quot;&quot; #根节点操作 if root == None: return #拉平左右子树 self.flatten(root.left) self.flatten(root.right) #后序操作:分别将子树拉平为链表 l = root.left r = root.right #将左子树作为右子树 root.left = None root.right = l #将原先的右子树接到当前右子树的末端 p = root while(p.right != None): p = p.right p.right = r 左叶子之和 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def sumOfLeftLeaves(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: int &quot;&quot;&quot; #根节点判断 if not root: return 0 left_left_leaves_sum = self.sumOfLeftLeaves(root.left) # 左 right_left_leaves_sum = self.sumOfLeftLeaves(root.right) # 右 cur_val = 0 if root.left and not root.left.left and not root.left.right: cur_val = root.left.val # 中 return cur_val + left_left_leaves_sum + right_left_leaves_sum 二叉树-构造篇 每日一遍解题思路： 二叉树解题的思维模式分两类： 1、是否可以通过遍历一遍二叉树得到答案？如果可以，用一个 traverse 函数配合外部变量来实现，这叫「遍历」的思维模式。 2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。 无论使用哪种思维模式，你都需要思考： 如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做？其他的节点不用你操心，递归函数会帮你在所有节点上执行相同的操作。 二叉树的构造问题一般都是使用「分解问题」的思路：构造整棵树 = 根节点 + 构造左子树 + 构造右子树。 最大二叉树 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def constructMaximumBinaryTree(self, nums: List[int]) -&gt; TreeNode: if not nums: return None #先找到最大值与其对应的索引 根节点 maxvalue = max(nums) index = nums.index(maxvalue) #将最大值确定为父节点 根节点 root = TreeNode(maxvalue) #前序操作划分左右子树 构造左子树 + 构造右子树 left = nums[:index] right = nums[index + 1:] #递归遍历 root.left = self.constructMaximumBinaryTree(left) root.right = self.constructMaximumBinaryTree(right) return root 通过前序和中序遍历结果构造二叉树 我们肯定要想办法确定根节点的值，把根节点做出来，然后递归构造左右子树即可。 前序遍历和中序遍历的结果有什么特点： void traverse(TreeNode root) { // 前序遍历 preorder.add(root.val); traverse(root.left); traverse(root.right); } void traverse(TreeNode root) { traverse(root.left); // 中序遍历 inorder.add(root.val); traverse(root.right); 找到根节点是很简单的，前序遍历的第一个值 preorder[0] 就是根节点的值。 关键在于如何通过根节点的值，将 preorder 和 postorder 数组划分成两半，构造根节点的左右子树？ 换句话说，对于以下代码中的 ? 部分应该填入什么： /* 主函数 */ public TreeNode buildTree(int[] preorder, int[] inorder) { // 根据函数定义，用 preorder 和 inorder 构造二叉树 return build(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1); } /* build 函数的定义： 若前序遍历数组为 preorder[preStart..preEnd]， 中序遍历数组为 inorder[inStart..inEnd]， 构造二叉树，返回该二叉树的根节点 */ TreeNode build(int[] preorder, int preStart, int preEnd, int[] inorder, int inStart, int inEnd) { // root 节点对应的值就是前序遍历数组的第一个元素 int rootVal = preorder[preStart]; // rootVal 在中序遍历数组中的索引 int index = 0; for (int i = inStart; i &lt;= inEnd; i++) { if (inorder[i] == rootVal) { index = i; break; } } TreeNode root = new TreeNode(rootVal); // 递归构造左右子树 root.left = build(preorder, ?, ?, inorder, ?, ?); root.right = build(preorder, ?, ?, inorder, ?, ?); return root; } # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def buildTree(self, preorder, inorder): &quot;&quot;&quot; :type preorder: List[int] :type inorder: List[int] :rtype: TreeNode &quot;&quot;&quot; #树为空，进行递归终止 if not preorder: return None #找到并构造根节点 rootval = preorder[0] root = TreeNode(rootval) #从中序遍历切割 index = inorder.index(rootval) inleft = inorder[:index] inright = inorder[index + 1:] #重点：切割前序数组：注意子数组大小一定保持不变 preleft = preorder[1:1+len(inleft)] preright = preorder[len(inleft)+1:] #递归 root.left = self.buildTree(preleft,inleft) root.right = self.buildTree(preright,inright) return root 从中序与后序遍历序列构造二叉树 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def buildTree(self, inorder, postorder): &quot;&quot;&quot; :type inorder: List[int] :type postorder: List[int] :rtype: TreeNode &quot;&quot;&quot; #特殊情况判断 if not postorder: return None #找到并构建根节点 rootval = postorder[-1] root = TreeNode(rootval) #中序数组在确定位置并切割数组 index = inorder.index(rootval) inleft = inorder[:index] inright = inorder[index+1:] #重点是后序数组切割大小 poleft = postorder[:len(inleft)] poright = postorder[len(inleft):len(postorder)-1] #递归 root.left = self.buildTree(inleft,poleft) root.right = self.buildTree(inright,poright) return root 完全二叉树节点个数 class Solution: def countNodes(self, root: TreeNode) -&gt; int: return self.getNodesNum(root) def getNodesNum(self, cur): if not cur: return 0 leftNum = self.getNodesNum(cur.left) #左 rightNum = self.getNodesNum(cur.right) #右 treeNum = leftNum + rightNum + 1 #中 return treeNum #简化版 class Solution: def countNodes(self, root: TreeNode) -&gt; int: if not root: return 0 return 1 + self.countNodes(root.left) + self.countNodes(root.right) 平衡二叉树 # Definition for a binary tree node. # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution: def isBalanced(self, root: TreeNode) -&gt; bool: if self.get_height(root) != -1: return True else: return False def get_height(self, root: TreeNode) -&gt; int: # Base Case if not root: return 0 # 左 if (left_height := self.get_height(root.left)) == -1: return -1 # 右 if (right_height := self.get_height(root.right)) == -1: return -1 # 中 if abs(left_height - right_height) &gt; 1: return -1 else: return 1 + max(left_height, right_height) 二叉树的路径 # Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def binaryTreePaths(self, root): &quot;&quot;&quot; :type root: TreeNode :rtype: List[str] &quot;&quot;&quot; path = '' res = [] if not root: return res self.road(root,path,res) return res #定义遍历函数 def road(self,cur,path,res): #路径表示 path += str(cur.val) #叶子结点判断 if not cur.left and not cur.right: res.append(path) #递归左右子树 if cur.left: self.road(cur.left,path + '-&gt;',res) if cur.right: self.road(cur.right,path + '-&gt;',res) 二叉树减枝 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* pruneTree(TreeNode* root) { //判断空值 if(!root){ return nullptr; } //递归左右子树 root-&gt;left = pruneTree(root-&gt;left); root-&gt;right = pruneTree(root-&gt;right); //判断根节点 if(root-&gt;val == 0 &amp;&amp; !root-&gt;left &amp;&amp; !root-&gt;right){ return nullptr; } return root; } }; 最大二叉树 给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建: 创建一个根节点，其值为 nums 中的最大值。 递归地在最大值 左边 的 子数组前缀上 构建左子树。 递归地在最大值 右边 的 子数组后缀上 构建右子树。 返回 nums 构建的 最大二叉树 。 链接：https://leetcode.cn/problems/maximum-binary-tree /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) { TreeNode* node = new TreeNode(0); if (nums.size() == 1) { node-&gt;val = nums[0]; return node; } // 找到数组中最大的值和对应的下表 int maxValue = 0; int maxValueIndex = 0; for (int i = 0; i &lt; nums.size(); i++) { if (nums[i] &gt; maxValue) { maxValue = nums[i]; maxValueIndex = i; } } node-&gt;val = maxValue; // 最大值所在的下表左区间 构造左子树 if (maxValueIndex &gt; 0) { vector&lt;int&gt; newVec(nums.begin(), nums.begin() + maxValueIndex); node-&gt;left = constructMaximumBinaryTree(newVec); } // 最大值所在的下表右区间 构造右子树 if (maxValueIndex &lt; (nums.size() - 1)) { vector&lt;int&gt; newVec(nums.begin() + maxValueIndex + 1, nums.end()); node-&gt;right = constructMaximumBinaryTree(newVec); } return node; } }; //优化遍历代码 class Solution { private: // 在左闭右开区间[left, right)，构造二叉树 TreeNode* traversal(vector&lt;int&gt;&amp; nums, int left, int right) { if (left &gt;= right) return nullptr; // 分割点下表：maxValueIndex int maxValueIndex = left; for (int i = left + 1; i &lt; right; ++i) { if (nums[i] &gt; nums[maxValueIndex]) maxValueIndex = i; } TreeNode* root = new TreeNode(nums[maxValueIndex]); // 左闭右开：[left, maxValueIndex) root-&gt;left = traversal(nums, left, maxValueIndex); // 左闭右开：[maxValueIndex + 1, right) root-&gt;right = traversal(nums, maxValueIndex + 1, right); return root; } public: TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) { return traversal(nums, 0, nums.size()); } }; 合并二叉树 给你两棵二叉树： root1 和 root2 。 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。 返回合并后的二叉树。 注意: 合并过程必须从两个树的根节点 链接：https://leetcode.cn/problems/merge-two-binary-trees /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) { //终止条件 if(root1 == NULL) return root2; if(root2 == NULL) return root1; //单层递归的逻辑 root1-&gt;val += root2-&gt;val; root1-&gt;left = mergeTrees(root1-&gt;left,root2-&gt;left); root1-&gt;right = mergeTrees(root1-&gt;right,root2-&gt;right); return root1; } }; 二叉树-后序篇 后序遍历二叉树是一种自底向上的遍历过程；后序遍历思想在回溯算法中应用最为广泛，本质就是一棵树先从上到下不操作，一撸到底，然后从叶子结点开始，向上根节点回溯的过程；说白了也就是递归的逆过程。 为什么都是后序遍历呢？这是一个值得思考的问题。 用剪枝的思想，去类比问题。无论是寻找最大直径、最长相同路径还是最大路径和，本质上都是一个从树的底部向树的顶部（root）去剪枝优化的过程。其实剪枝说的不准确，但是剪枝的目的也是寻找最优路径的选取过程。始终记住，后序是因为自底向上寻找的思路，那么这些问题就可以总结出一个很好模板思路。 二叉树的最大直径 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ //后序遍历如何用？ //遍历函数怎么写？ //返回值是什么？ //终止条件是什么？ //单层遍历的逻辑是什么？ class Solution { private: //int ans = 1; //dfs深度优先 //函数定义的类型一定要和返回值密切相关。 int travseral(TreeNode* node){ //终止条件就是向下遍历到根节点 if(node == NULL){ return 0; } return max(travseral(node-&gt;left),travseral(node-&gt;right)) + 1; } public: int diameterOfBinaryTree(TreeNode* root) { if(root == NULL) return 0; //定义左右子树之间的最大值 int cur = travseral(root-&gt;left) + travseral(root-&gt;right); //diameterOfBinaryTree函数是返回左右子树自身的最大值 //最后返回的是左右子树、左子树自身、右子树自身三者之间的最大值 return max({cur,diameterOfBinaryTree(root-&gt;left),diameterOfBinaryTree(root-&gt;right)}); } }; 最长同值路径 给定一个二叉树的 root ，返回 最长的路径的长度 ，这个路径中的 每个节点具有相同值 。 这条路径可以经过也可以不经过根节点。 两个节点之间的路径长度 由它们之间的边数表示。 链接：https://leetcode.cn/problems/longest-univalue-path /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private: int res = 0; //遍历函数时什么、返回值是什么？ int dfs(TreeNode* root,int parentVal){ //终止条件 if(root == NULL){ return 0; } // 利用函数定义，计算左右子树值为 root.val 的最长树枝长度 int left = dfs(root-&gt;left,root-&gt;val); int right = dfs(root-&gt;right,root-&gt;val); //后序操作:直接返回左右子树最大路径之和 res = max(res, left + right); // 如果 root 本身和上级值不同，那么整棵子树都不可能有同值树枝 if(root-&gt;val != parentVal){ //注意返回值的设定 return 0; } // 实现函数的定义： // 以 root 为根的二叉树从 root 开始值为 parentVal 的最长树枝长度 // 等于左右子树的最长树枝长度的最大值加上 root 节点本身 return 1 + max(left,right); } public: int longestUnivaluePath(TreeNode* root) { if(root == NULL){ return 0; } dfs(root,root-&gt;val); return res; } }; 二叉树中最大路径和 路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。 路径和 是路径中各节点值的总和。 给你一个二叉树的根节点 root ，返回其 最大路径和 。 链接：https://leetcode.cn/problems/binary-tree-maximum-path-sum /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private: int ret = INT_MIN; //函数定义和返回值是什么？ // 定义：计算从根节点 root 为起点的最大单边路径和 int dfs(TreeNode* root){ //终止条件 if(root == NULL){ return 0; } int leftsum = max(0,dfs(root-&gt;left)); int rightsum = max(0,dfs(root-&gt;right)); // 后序遍历位置，顺便更新最大路径和 int pathsum = root-&gt;val + leftsum + rightsum; ret = max(ret,pathsum); // 实现函数定义，左右子树的最大单边路径和加上根节点的值 // 就是从根节点 root 为起点的最大单边路径和 return max(leftsum,rightsum) + root-&gt;val; } public: int maxPathSum(TreeNode* root) { if(root == NULL){ return 0; } dfs(root); return ret; } }; 二叉搜索树 二叉搜索树的基本概念： 二叉搜索树是一颗有序树，满足如下规则： 若它的左子树不空，则左子树上所有节点的值都小于它的根节点上的值。 若它的右子树不空，则右子树上所有节点的值都大于它的根节点上的值。 它的左右子树也分别书二叉排序树。 二叉搜索树的中序遍历是一个严格的递增序列。所有在遇到二叉搜索树的相关问题时，巧用中序遍历是解题的关键也是解决问题的快速方法。 中序遍历代码： void searchBST(TreeNode* cur){ if(cur == NULL) return; searchBST(root-&gt;left);//左 (中序操作) searchBST(root-&gt;right);//右 } 在解决二叉搜索树的最值问题时，递归可以采用两种基本的方式： 1.以数组为基本数据结构的方式 思路： 以数组为基本的存储方式中序遍历写起来较为直观 vector&lt;int&gt; res; void travser(TreeNode* root){ if(root == NULL) return; travser(root-&gt;left); res.push_back(root-&gt;val); travser(root-&gt;right); 操作是放在主函数中进行，在主函数利用for循环进行求解最值得问题；中序遍历的方法只是为了得到一个升序的数组，得以把一颗二叉排序树转化成一个单调递增的数组，以方便处理。 2.以单链表为基本数据结构的方式 思路： 单链表的方式需要设置两个节点指针：cur和pre，相当于一个头指针和一个尾指针；无论是在迭代还是在递归中，头尾指针的设定就是去摆脱在主函数中的二次for循环操作，而降低时间复杂度，在递归的过程中即实现操作的一步到位。 TreeNode* pur = NULL;//记录前一个节点 //TreeNode* cur = root; if(root == NULL) return true; //中序遍历思路 bool left = isValidBST(root-&gt;left); //相当于是中序遍历操作中在操作的判断 //运用头结点pur判断是否是一个递增的序列 if(pur != NULL &amp;&amp; pur-&gt;val &gt;= root-&gt;val) return false; pur = root; bool right = isValidBST(root-&gt;right); //相当于中序遍历多加了一个if判断操作 在二叉搜索树中寻找节点 给定二叉搜索树（BST）的根节点 root 和一个整数值 val。 你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。 链接：https://leetcode.cn/problems/search-in-a-binary-search-tree /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: //确定递归函数和参数设置 TreeNode* searchBST(TreeNode* root, int val) { //终止条件 if(root == NULL || root-&gt;val == val) return root; //因为二叉搜索树的节点大小是有规律的所以可以简化搜索 if(root-&gt;val &gt; val) return searchBST(root-&gt;left,val); if(root-&gt;val &lt; val) return searchBST(root-&gt;right,val); return NULL; } }; 验证二叉搜索树 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 有效 二叉搜索树定义如下： 节点的左子树只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 链接：https://leetcode.cn/problems/validate-binary-search-tree /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private: //思路：中序遍历构建一个递增的数组 vector&lt;int&gt; res; void travser(TreeNode* root){ if(root == NULL) return; travser(root-&gt;left); res.push_back(root-&gt;val); travser(root-&gt;right); } public: bool isValidBST(TreeNode* root) { res.clear(); travser(root); for(int i = 1;i &lt; res.size();i++){ if(res[i] &lt;= res[i - 1]){ return false; } } return true; } }; 改进： /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* pur = NULL;//记录前一个节点 //TreeNode* cur = root; bool isValidBST(TreeNode* root) { if(root == NULL) return true; //中序遍历思路 bool left = isValidBST(root-&gt;left); //相当于是中序遍历操作中在操作的判断 //运用头结点pur判断是否是一个递增的序列 if(pur != NULL &amp;&amp; pur-&gt;val &gt;= root-&gt;val) return false; pur = root; bool right = isValidBST(root-&gt;right); return left &amp;&amp; right; } }; 二叉搜索树的最小绝对差 给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。 差值是一个正数，其数值等于两值之差的绝对值。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private: vector&lt;int&gt; vec; void traversal(TreeNode* root) { if (root == NULL) return; traversal(root-&gt;left); vec.push_back(root-&gt;val); // 将二叉搜索树转换为有序数组 traversal(root-&gt;right); } public: int getMinimumDifference(TreeNode* root) { vec.clear(); traversal(root); if (vec.size() &lt; 2) return 0; int result = INT_MAX; for (int i = 1; i &lt; vec.size(); i++) { // 统计有序数组的最小差值 result = min(result, vec[i] - vec[i-1]); } return result; } }; //设置双节点的另一种做法 class Solution { private: int result = INT_MAX; TreeNode* pre; void traversal(TreeNode* cur) { if (cur == NULL) return; traversal(cur-&gt;left); // 左 if (pre != NULL){ // 中 result = min(result, cur-&gt;val - pre-&gt;val); } pre = cur; // 记录前一个 traversal(cur-&gt;right); // 右 } public: int getMinimumDifference(TreeNode* root) { traversal(root); return result; } }; 二叉搜索树中的众数 给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。 如果树中有不止一个众数，可以按 任意顺序 返回。 链接：https://leetcode.cn/problems/find-mode-in-binary-search-tree class Solution { private: int maxCount; // 最大频率 int count; // 统计频率 TreeNode* pre; vector&lt;int&gt; result; void searchBST(TreeNode* cur) { if (cur == NULL) return ; searchBST(cur-&gt;left); // 左 // 中 if (pre == NULL) { // 第一个节点 count = 1; } else if (pre-&gt;val == cur-&gt;val) { // 与前一个节点数值相同 count++; } else { // 与前一个节点数值不同 count = 1; } pre = cur; // 更新上一个节点 if (count == maxCount) { // 如果和最大值相同，放进result中 result.push_back(cur-&gt;val); } if (count &gt; maxCount) { // 如果计数大于最大值频率 maxCount = count; // 更新最大频率 result.clear(); // 很关键的一步，不要忘记清空result，之前result里的元素都失效了 result.push_back(cur-&gt;val); } searchBST(cur-&gt;right); // 右 return ; } public: vector&lt;int&gt; findMode(TreeNode* root) { count = 0; maxCount = 0; TreeNode* pre = NULL; // 记录前一个节点 result.clear(); searchBST(root); return result; } }; //迭代法 class Solution { public: vector&lt;int&gt; findMode(TreeNode* root) { stack&lt;TreeNode*&gt; st; TreeNode* cur = root; TreeNode* pre = NULL; int maxCount = 0; // 最大频率 int count = 0; // 统计频率 vector&lt;int&gt; result; while (cur != NULL || !st.empty()) { if (cur != NULL) { // 指针来访问节点，访问到最底层 st.push(cur); // 将访问的节点放进栈 cur = cur-&gt;left; // 左 } else { cur = st.top(); st.pop(); // 中 if (pre == NULL) { // 第一个节点 count = 1; } else if (pre-&gt;val == cur-&gt;val) { // 与前一个节点数值相同 count++; } else { // 与前一个节点数值不同 count = 1; } if (count == maxCount) { // 如果和最大值相同，放进result中 result.push_back(cur-&gt;val); } if (count &gt; maxCount) { // 如果计数大于最大值频率 maxCount = count; // 更新最大频率 result.clear(); // 很关键的一步，不要忘记清空result，之前result里的元素都失效了 result.push_back(cur-&gt;val); } pre = cur; cur = cur-&gt;right; // 右 } } return result; } }; 二叉树/搜索树的最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 链接：https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree //普通二叉树的最近祖先 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root == p || root == q || root == NULL){ return root; } //寻找公共祖先的思路是要通过自底向上的后序遍历判断公共祖先 TreeNode *left = lowestCommonAncestor(root-&gt;left,p,q); TreeNode *right = lowestCommonAncestor(root-&gt;right,p,q); //后序操作 if(left != NULL &amp;&amp; right != NULL) return root; if(left == NULL &amp;&amp; right != NULL) return right; else if(left != NULL &amp;&amp; right == NULL) return left; else{ return NULL; } } }; //二叉搜索树的最近祖先 //注意结合搜索区间进行判断 class Solution { private: TreeNode* traversal(TreeNode* cur, TreeNode* p, TreeNode* q) { if (cur == NULL) return cur; // 中 if (cur-&gt;val &gt; p-&gt;val &amp;&amp; cur-&gt;val &gt; q-&gt;val) { // 左 TreeNode* left = traversal(cur-&gt;left, p, q); if (left != NULL) { return left; } } if (cur-&gt;val &lt; p-&gt;val &amp;&amp; cur-&gt;val &lt; q-&gt;val) { // 右 TreeNode* right = traversal(cur-&gt;right, p, q); if (right != NULL) { return right; } } return cur; } public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { return traversal(root, p, q); } }; 图论算法 图论章节主要是涉及到了图的两种遍历方式-&gt;深度优先搜索和广度有优先搜索。 图的基本数据结构的实现 结构体是一个由程序员定义的数据类型，可以容纳许多不同的数据值。在过去，面向对象编程的应用尚未普及之前，程序员通常使用这些从逻辑上连接在一起的数据组合到一个单元中。一旦结构体类型被声明并且其数据成员被标识，即可创建该类型的多个变量，就像可以为同一个类创建多个对象一样。 声明结构体的方式和声明类的方式大致相同，其区别如下： 使用关键字 struct 而不是关键字 class。 尽管结构体可以包含成员函数，但它们很少这样做。所以，通常情况下结构体声明只会声明成员变量。 结构体声明通常不包括 public 或 private 的访问修饰符。 类成员默认情况是私有的，而结构体的成员则默认为 public。程序员通常希望它们保持公开，只需使用默认值即可。 以下是一个结构体声明的示例，该结构体将 5 个变量绑定在一起，保存了员工的工资单数据。这个特殊结构体的名称是 PayRoll。请注意，它以大写字母开头，这和类名使用大写字母开头的约定一样。另外还要注意，与类声明一样，在结构体声明的大括号后面必须有一个分号。 struct PayRoll { int empNumber; string name; double hours,payRate,grossPay; }; 结构体 当定义结构体变量时，可以通过两种方式初始化它：使用初始化列表或构造函数。 初始化列表 初始化结构体变量成员的最简单的方法是使用初始化列表。初始化列表是用于初始化一组内存位置的值列表。列表中的项目用逗号分隔并用大括号括起来。 例如，假设已经声明了以下 Date 结构体： struct Date{ int day, month, year; }; 定义和初始化 Date 变量的方式是：先指定变量名，后接赋值运算符和初始化列表，如下所示： Date birthday = {23, 8, 1983}; 该声明定义 birthday 是一个 Date 结构体的变量，大括号内的值按顺序分配给其成员。 BFS广度优先搜索 二叉树的广度优先搜索-&gt;二叉树的层序遍历；而讲到层序遍历，又可以把解题思路分成两种：递归法、迭代法。 这是主要写迭代法，因为相比于递归法的层序遍历，迭代法的BFS算法是最能体现出BFS思路的方法。 需要用到的数据结构：队列-&gt;准确的说是指针队列. 下面咱们就手撸一个BFS算法： #include&lt;iostream&gt; #include&lt;queue&gt; #include&lt;stdlib.h&gt; #include&lt;vector&gt; using namespace std; struct TreeNode{ int val; TreeNode* left; TreeNode* right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} }; int BFS(TreeNode * root){ if(root == NULL) return 0; //终止条件判断 queue&lt;TreeNode*&gt; que; //创建队列 que.push(root); //将根节点入队 int sum = 0;//设置记录信号 while(!que.empty()){ sum = 0;//每次循环之前归零，记录单层的和 int sz = que.size();//求出队列长度 for(int i = 0;i &lt; sz;i++){ //for循环依次对每层求和 TreeNode* cur = que.front();//取对头元素为初始指针节点 que.pop(); sum += cur-&gt;val; if(cur-&gt;left != NULL){ que.push(cur-&gt;left); } if(cur-&gt;right != NULL){ que.push(cur-&gt;right); } } } return sum; } 广度优先搜索——本质上是二叉树的层序遍历（力扣102题） 运用的数据结构是队列和数组；运用数组保存最后的结果，运用队列去模拟层序遍历的过程。 class Solution { public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) { queue&lt;TreeNode*&gt; que; if (root != NULL) que.push(root); vector&lt;vector&lt;int&gt;&gt; result; while (!que.empty()) { int size = que.size(); vector&lt;int&gt; vec; // 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的 for (int i = 0; i &lt; size; i++) { TreeNode* node = que.front(); que.pop(); vec.push_back(node-&gt;val); if (node-&gt;left) que.push(node-&gt;left); if (node-&gt;right) que.push(node-&gt;right); } result.push_back(vec); } return result; } }; DFS深度优先搜索 深度优先搜索，顾名思义就是一条道路走到底；类比一棵树的话，就是从上到下先序遍历一棵树。深度优先，得到的一定先是树的深度（高度）。因为其通常和回溯算法相结合使用，所以其重要性不可估量。学会DFS就是学会使用其暴力搜索的功能，学会聪明的穷举。避免高强度的多循环嵌套for循环，既浪费时间又浪费空间；那为什么暴力搜索也需要花费大量时间但是还有它存在的道理呢？我认为，存在即合理，很多时候DFS算法存在确实是有他的优势的。最起码，DFS就是利用递归思维去书写程序的一个好模板。虽然本质上和for循环差别不大，但是，一旦问题规模变大，for循环承担不了大工程时，多层循环很容易把人绕懵而且时间复杂度是呈现n方量级增加。这时，DFS的递归遍历就节省了很大的空间复杂度（时间复杂度虽然不敢保证），避免了高强度的循环嵌套，使得程序得以运行出结果。同样，穷举与暴力是程序设计最本源的思路，计算机解决问题最开始的方法就是穷举，人们只是掌握了方法，让计算机学会去聪明的穷举。综上，这是我理解的DFS存在的现实意义与其重要性。 DPS算法的设计分析 在学习书写DFS前一定要学会书写树的遍历（递归遍历） res.append(root.val) preorder(root.left) preorder(root.right) 理解了树的递归遍历之后，才能书写出DFS递归的逻辑。最本质的还是要理解递归的逻辑~ DFS书写套路： 1.定义存放结果变量 vector&lt;vector&lt;int&gt;&gt; res;//存放最终结果 vector&lt;int&gt; path;//存放路径 2.回溯函数的框架书写与参数的确定 void backtrack(参数......) 3.递归过程中搜索的逻辑 DFS算法与回溯算法的关系 DFS算法书写的模板套路 DFS的算法套路书写关键在于正确理解递归函数的参数调用与终止条件的确立。 回溯算法 回溯铺垫:二叉树的所有路径 ** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { private: void traversal(TreeNode* cur,vector&lt;int&gt; &amp;path,vector&lt;string&gt; &amp;res){ path.push_back(cur-&gt;val); //到达叶子结点 if(cur-&gt;left == NULL &amp;&amp; cur-&gt;right == NULL){ string spath; for(int i = 0;i &lt; path.size() - 1;i++){ spath += to_string(path[i]); spath += &quot;-&gt;&quot;; } spath += to_string(path[path.size() - 1]); res.push_back(spath); return; } if(cur-&gt;left){ traversal(cur-&gt;left,path,res); path.pop_back();//回溯 } if(cur-&gt;right){ traversal(cur-&gt;right,path,res); path.pop_back();//回溯 } } public: vector&lt;string&gt; binaryTreePaths(TreeNode* root) { vector&lt;string&gt; res; vector&lt;int&gt; path; if(root == NULL) return res; traversal(root,path,res); return res; } }; 回溯算法和我们常说的 DFS 算法非常类似，本质上就是一种暴力穷举算法。回溯算法和 DFS 算法的细微差别是：回溯算法是在遍历「树枝」，DFS 算法是在遍历「节点」。 回溯算法解决从上到下一次遍历整颗树，在其模板中，运用for循环去横向遍历——做选择；利用递归（回溯函数）去纵向遍历——路径。 路径、选择、终止条件 #东哥模板 result = [] def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 //卡哥模板 void backtrack(参数){ if(终止条件){ 存放结果; return; } for(选择:本层集合中的元素){ 处理节点; backtrack(路径，选择); 回溯,撤销结果; } } 回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作: def backtrack(...): for 选择 in 选择列表: 做选择 backtrack(...) 撤销选择 写 backtrack 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集。 回溯法中的参数不是一次性就可以完全确定下来，一般先写逻辑，需要什么参数就可以填写什么参数。 无论是排列、组合还是子集问题，简单说无非就是让你从序列 nums 中以给定规则取若干元素，主要有以下几种变体： 形式一、元素无重不可复选，即 nums 中的元素都是唯一的，每个元素最多只能被使用一次，这也是最基本的形式。 以组合为例，如果输入 nums = [2,3,6,7]，和为 7 的组合应该只有 [7]。 /* 组合/子集问题回溯算法框架 */ void backtrack(int[] nums, int start) { // 回溯算法标准框架 for (int i = start; i &lt; nums.length; i++) { // 做选择 track.addLast(nums[i]); // 注意参数 backtrack(nums, i + 1); // 撤销选择 track.removeLast(); } } /* 排列问题回溯算法框架 */ void backtrack(int[] nums) { for (int i = 0; i &lt; nums.length; i++) { // 剪枝逻辑 if (used[i]) { continue; } // 做选择 used[i] = true; track.addLast(nums[i]); backtrack(nums); // 撤销选择 track.removeLast(); used[i] = false; } } 形式二、元素可重不可复选，即 nums 中的元素可以存在重复，每个元素最多只能被使用一次。 以组合为例，如果输入 nums = [2,5,2,1,2]，和为 7 的组合应该有两种 [2,2,2,1] 和 [5,2]。 Arrays.sort(nums); /* 组合/子集问题回溯算法框架 */ void backtrack(int[] nums, int start) { // 回溯算法标准框架 for (int i = start; i &lt; nums.length; i++) { // 剪枝逻辑，跳过值相同的相邻树枝 if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) { continue; } // 做选择 track.addLast(nums[i]); // 注意参数 backtrack(nums, i + 1); // 撤销选择 track.removeLast(); } } Arrays.sort(nums); /* 排列问题回溯算法框架 */ void backtrack(int[] nums) { for (int i = 0; i &lt; nums.length; i++) { // 剪枝逻辑 if (used[i]) { continue; } // 剪枝逻辑，固定相同的元素在排列中的相对位置 if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) { continue; } // 做选择 used[i] = true; track.addLast(nums[i]); backtrack(nums); // 撤销选择 track.removeLast(); used[i] = false; } } 形式三、元素无重可复选，即 nums 中的元素都是唯一的，每个元素可以被使用若干次。 上面用组合问题举的例子，但排列、组合、子集问题都可以有这三种基本形式，所以共有 9 种变化。 除此之外，题目也可以再添加各种限制条件，比如让你求和为 target 且元素个数为 k 的组合，那这么一来又可以衍生出一堆变体，怪不得面试笔试中经常考到排列组合这种基本题型。 /* 组合/子集问题回溯算法框架 */ void backtrack(int[] nums, int start) { // 回溯算法标准框架 for (int i = start; i &lt; nums.length; i++) { // 做选择 track.addLast(nums[i]); // 注意参数 backtrack(nums, i); // 撤销选择 track.removeLast(); } } /* 排列问题回溯算法框架 */ void backtrack(int[] nums) { for (int i = 0; i &lt; nums.length; i++) { // 做选择 track.addLast(nums[i]); backtrack(nums); // 撤销选择 track.removeLast(); } } 但无论形式怎么变化，其本质就是穷举所有解，而这些解呈现树形结构，所以合理使用回溯算法框架，稍改代码框架即可把这些问题一网打尽。 排列问题 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 class Solution { public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; void backtrack(vector&lt;int&gt;&amp; nums,vector&lt;bool&gt;&amp; used){ //此时找到说明找到了一组 if(path.size() == nums.size()){ res.push_back(path); return; } for(int i = 0;i &lt; nums.size();i++){ if(used[i] == true) continue;//说明path中已经收集到了该元素 used[i] = true; path.push_back(nums[i]); backtrack(nums,used); path.pop_back(); used[i] = false; } } vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) { res.clear(); path.clear(); vector&lt;bool&gt; used(nums.size(),false); backtrack(nums,used); return res; } }; 216.组合总数|| 找出所有相加之和为 n 的 k 个数的组合，且满足下列条件： 只使用数字1到9，每个数字 最多使用一次 返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。 class Solution { private: //设置二维结果数组与路劲数组 vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; void backtrack(int tarSum,int k,int sum,int startIndex){ //此时找到了一组 if(path.size() == k){ if(sum == tarSum) res.push_back(path); return; } //单层递归的逻辑 for(int i = startIndex;i &lt;= 9;i++){ sum += i; path.push_back(i); //注意参数的取值是i+1，调整下一层递归的startIndex backtrack(tarSum,k,sum,i + 1); sum -= i;//回溯 path.pop_back();//回溯 } } public: vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) { res.clear(); path.clear(); backtrack(n,k,0,1); return res; } }; 组合总和 39： 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。 candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 target 的不同组合数少于 150个。 class Solution { private: //定义全局变量存放结果 vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; void backtrack(vector&lt;int&gt;&amp; candidates,int target,int sum,int startIndex){ if(sum &gt; target){ return; } if(sum == target){ res.push_back(path); return; } for(int i = startIndex;i &lt;candidates.size();i++){ sum += candidates[i]; path.push_back(candidates[i]); //不需要i+1，表示可以从自身开始取 backtrack(candidates,target,sum,i); sum -= candidates[i]; path.pop_back(); } } public: vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) { path.clear(); res.clear(); backtrack(candidates,target,0,0); return res; } }; 40： 给定一个候选人编号的集合 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用 一次 。 注意：解集不能包含重复的组合。 注意本题与前一题的主要区别在于，本题中的candidates中存在重复的元素，在回溯过程中，同一层的遍历要注意避免重复元素的使用。 增加了used数组来判断重复元素的使用次数，从而避免重复元素的使用情况。 class Solution { private: //定义全局变量 //本题的区别在于，candidates中存在重复元素，要想办法进行去重 vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; void backtrack(vector&lt;int&gt;&amp; candidates, int target,int sum,int startIndex,vector&lt;bool&gt;&amp; used){ if(sum &gt; target){ return; } if(sum == target){ res.push_back(path); return; } for(int i = startIndex;i &lt; candidates.size() &amp;&amp; sum + candidates[i] &lt;= target;i++){ if(i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; used[i - 1] == false){ continue; } sum += candidates[i]; path.push_back(candidates[i]); used[i] = true; backtrack(candidates,target,sum,i + 1,used); used[i] = false; sum -= candidates[i]; path.pop_back(); } } public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) { vector&lt;bool&gt; used(candidates.size(),false); path.clear(); res.clear(); sort(candidates.begin(),candidates.end()); backtrack(candidates,target,0,0,used); return res; } }; 子集问题 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 class Solution { private: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; void backtrack(vector&lt;int&gt;&amp; nums,int startIndex){ res.push_back(path);//收集子集要放在终止条件上面否则会漏掉 if(startIndex &gt;= nums.size()){ return; } for(int i = startIndex;i &lt; nums.size();i++){ path.push_back(nums[i]); backtrack(nums,i + 1); path.pop_back(); } } public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) { path.clear(); res.clear(); backtrack(nums,0); return res; } }; num中存在可重复元素时的情况时同样采用used数组进行重复避免。 换句话说，我们通过保证元素之间的相对顺序不变来防止出现重复的子集。 含有重复元素时一定要注意在最后主函数中先对题给集合先进行排序。 class Solution { private: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; void backtrack(vector&lt;int&gt;&amp; nums,int startIndex,vector&lt;bool&gt;&amp; used){ res.push_back(path); if(startIndex &gt;= nums.size()){ return; } for(int i = startIndex;i &lt; nums.size();i++){ if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; used[i - 1] == false){ continue; } path.push_back(nums[i]); used[i] = true; backtrack(nums,i + 1,used); used[i] = false; path.pop_back(); } } public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) { vector&lt;bool&gt; used(nums.size(),false); res.clear(); path.clear(); //去重要排序 sort(nums.begin(),nums.end()); backtrack(nums, 0, used); return res; } }; N皇后 按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。 n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。 贪心算法 动态规划 动态规划的核心设计思想是数学归纳法，相信大家对数学归纳法都不陌生，高中就学过，而且思路很简单。比如我们想证明一个数学结论，那么我们先假设这个结论在 k &lt; n 时成立，然后根据这个假设，想办法推导证明出 k = n 的时候此结论也成立。如果能够证明出来，那么就说明这个结论对于 k 等于任何数都成立。 类似的，我们设计动态规划算法，不是需要一个 dp 数组吗？我们可以假设 dp[0...i-1] 都已经被算出来了，然后问自己：怎么通过这些结果算出 dp[i]？这也是标准的动态规划中的逆序解法。 首先要定义清楚 dp 数组的含义，即 dp[i] 的值到底代表着什么？ 动态规划基础 -&gt;利用子问题的最优解去求解全局最优解;善于利用二位表寻找思路。 动态规划问题的一般形式就是求最值，动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多。既然是要求最值，核心问题是什么呢？求解动态规划的核心问题是穷举。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。但是，穷举所有可行解其实并不是一件容易的事，需要你熟练掌握递归思维，只有列出正确的「状态转移方程」，才能正确地穷举。因此，写出状态转移方程的一般思路是： 明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义。 在**明确「选择」的思考是就体现出来“树”**的影子，可以画出树形结构来辅助思考最优解的路径 针对每道题应该有的思考： 确定dp数组以及下标的含义 dp[i]的定义为：第i个数的斐波那契数值是dp[i] 确定递推公式 为什么这是⼀道⾮常简单的⼊⻔题⽬呢？ 因为题⽬已经把递推公式直接给我们了：状态转移⽅程 dp[i] = dp[i - 1] + dp[i - 2]; dp数组如何初始化 对于前提所需元素如何进行赋值；例如爬楼梯与斐波那契数列中dp[0]与dp[1]的赋值 确定遍历顺序 从递归公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，dp[i]是依赖 dp[i - 1] 和 dp[i - 2]，那么遍历的顺序 ⼀定是从前到后遍历的 举例推导dp数组 动态规划书写框架 1.确定base case 2.穷举所有结果 3.状态转移 摆脱编程的黑盒状态：题目在于精；需要注意：每道题中dp[]数组及其下标的含义、递推公式、dp数组如何初始化、遍历顺序、打印dp数组。 动态规划的难点本来就在于寻找正确的状态转移方程，设计动态规划的通用技巧：数学归纳思想。 # 自顶向下递归的动态规划 def dp(状态1, 状态2, ...): for 选择 in 所有可能的选择: # 此时的状态已经因为做了选择而改变 result = 求最值(result, dp(状态1, 状态2, ...)) return result # 自底向上迭代的动态规划 # 初始化 base case dp[0][0][...] = base case # 进行状态转移 for 状态1 in 状态1的所有取值： for 状态2 in 状态2的所有取值： for ... dp[状态1][状态2][...] = 求最值(选择1，选择2...) 斐波那契数列 斐波那契数列这道题⽬是⾮常基础的题⽬，通常⽤ F(n) 表示，形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后⾯的每⼀项 数字都是前⾯两项数字的和。 class Solution { public: int fib(int N) { if (N &lt;= 1) return N; vector&lt;int&gt; dp(N + 1); dp[0] = 0; dp[1] = 1; for (int i = 2; i &lt;= N; i++) { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[N]; } }; -&gt;时间复杂度：O(n) -&gt;空间复杂度：O(n) 改进： class Solution { public: int fib(int N) { if (N &lt;= 1) return N; int dp[2]; dp[0] = 0; dp[1] = 1; for (int i = 2; i &lt;= N; i++) { int sum = dp[0] + dp[1]; dp[0] = dp[1]; dp[1] = sum; } return dp[1]; } }; -&gt;时间复杂度：O(n) -&gt;空间复杂度：O(1) 爬楼梯 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 确定dp数组以及下标的含义 dp[i]： 爬到第i层楼梯，有dp[i]种方法 2.确定递推公式 如果可以推出dp[i]呢？ 从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。 首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。 还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。 那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！ 所以dp[i] = dp[i - 1] + dp[i - 2] 。 在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。 这体现出确定dp数组以及下标的含义的重要性！ 3.dp数组如何初始化 在回顾一下dp[i]的定义：爬到第i层楼梯，有dp[i]中方法。 那么i为0，dp[i]应该是多少呢，这个可以有很多解释，但都基本是直接奔着答案去解释的。 例如强行安慰自己爬到第0层，也有一种方法，什么都不做也就是一种方法即：dp[0] = 1，相当于直接站在楼顶。 但总有点牵强的成分。 那还这么理解呢：我就认为跑到第0层，方法就是0啊，一步只能走一个台阶或者两个台阶，然而楼层是0，直接站楼顶上了，就是不用方法，dp[0]就应该是0. 其实这么争论下去没有意义，大部分解释说dp[0]应该为1的理由其实是因为dp[0]=1的话在递推的过程中i从2开始遍历本题就能过，然后就往结果上靠去解释dp[0] = 1。 从dp数组定义的角度上来说，dp[0] = 0 也能说得通。 需要注意的是：题目中说了n是一个正整数，题目根本就没说n有为0的情况。 所以本题其实就不应该讨论dp[0]的初始化！ 我相信dp[1] = 1，dp[2] = 2，这个初始化大家应该都没有争议的。 所以我的原则是：不考虑dp[0]如果初始化，只初始化dp[1] = 1，dp[2] = 2，然后从i = 3开始递推，这样才符合dp[i]的定义。 4.确定遍历顺序 从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的 5.举例推导dp数组 class Solution { public: int climbStairs(int n) { //1.dp[i]含义：达到第i阶台阶的方法数量为dp[i] //2.确定递推公式dp[i] = dp[i-1] + dp[i-2] //3.初始化:dp[0] = 1/0;dp[1] = 1,dp[2] = 2 if(n &lt;= 1) return n; //vector&lt;int&gt; dp(n + 1); int dp[n + 1]; dp[1] = 1; dp[2] = 2; for(int i = 3;i &lt;= n;i++){ dp[i] = dp[i-1] + dp[i-2]; } return dp[n]; } }; 空间复杂度优化 class Solution { public: int climbStairs(int n) { if (n &lt;= 1) return n; int dp[3]; dp[1] = 1; dp[2] = 2; for (int i = 3; i &lt;= n; i++) { int sum = dp[1] + dp[2]; dp[1] = dp[2]; dp[2] = sum; } return dp[2]; } }; 使用最小花费爬楼梯 数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。 每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。 请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。 每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯. dp[i]的定义：到达第i个台阶所花费的最少体力为dp[i]。dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];注意这里为什么是加cost[i]，而不是cost[i-1],cost[i-2]之类的，因为题目中说了：每当你爬上一个阶梯你都要花费对应的体力值. class Solution { public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) { vector&lt;int&gt; dp(cost.size()); dp[0] = cost[0]; dp[1] = cost[1]; for (int i = 2; i &lt; cost.size(); i++) { dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]; } // 注意最后一步可以理解为不用花费，所以取倒数第一步，第二步的最少值 return min(dp[cost.size() - 1], dp[cost.size() - 2]); } }; 优化空间复杂度 class Solution { public: int minCostClimbingStairs(vector&lt;int&gt;&amp; cost) { int dp0 = cost[0]; int dp1 = cost[1]; for (int i = 2; i &lt; cost.size(); i++) { int dpi = min(dp0, dp1) + cost[i]; dp0 = dp1; // 记录一下前两位 dp1 = dpi; } return min(dp0, dp1); } }; 两种思路 第一种思路模板是一个一维的 dp 数组 int n = array.length; int[] dp = new int[n]; for (int i = 1; i &lt; n; i++) { for (int j = 0; j &lt; i; j++) { dp[i] = 最值(dp[i], dp[j] + ...) } } 比如我们写过的 最长递增子序列 和 最大子数组和 都是这个思路。 在这个思路中 dp 数组的定义是： 在子数组 arr[0..i] 中，我们要求的子序列（最长递增子序列）的长度是 dp[i]。 class Solution { public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) { //定义dp数组并初始化 vector&lt;int&gt; dp(nums.size(),1); //以nums[i]结尾的子序列长度 for(int i = 0;i &lt; nums.size();i++){ for(int j = 0;j &lt; i;j++){ if(nums[i] &gt; nums[j]){ dp[i] = max(dp[i],dp[j]+1); } } } //寻找dp数组中的最大值 int res = 0; for(int j = 0;j &lt; dp.size();j++){ res = max(res,dp[j]); } return res; } }; 第二种思路模板是一个二维的 dp 数组 int n = arr.length; int[][] dp = new dp[n][n]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { if (arr[i] == arr[j]) dp[i][j] = dp[i][j] + ... else dp[i][j] = 最值(...) } } -&gt;涉及两个字符串/数组的场景，dp 数组的定义如下： 在子数组 arr1[0..i] 和子数组 arr2[0..j] 中，我们要求的子序列长度为 dp[i][j]。 -&gt;只涉及一个字符串/数组的场景，dp 数组的定义如下： 在子数组 array[i..j] 中，我们要求的子序列的长度为 dp[i][j]。 未完待续...... ","link":"https://Mungeryang.github.io/post/shu-ju-jie-gou/"},{"title":"任正非文集|我的父亲母亲","content":" 逝者已经逝去，活着的还要前行 这是我一生中最大的憾事——如果8日上午我真给母亲打了电话，拖延她一两分钟出门，也许她就躲过了这场灾难…… 上世纪末最后一天，我总算良心发现，在公务结束之后，买了一张从北京去昆明的机票，去看看妈妈。买好机票后，我没有给她电话，我知道一打电话她一下午都会忙碌，不管多晚到达，都会给我做一些我小时候喜欢吃的东西。直到飞机起飞，我才告诉她，让她不要告诉别人，不要车来接，我自己坐出租车回家，目的就是好好陪陪她。前几年我每年也去看看妈妈，但一下飞机就给办事处接走了，说这个客户很重要，要拜见一下，那个客户很重要，要陪他们吃顿饭，忙来忙去，忙到上飞机时回家取行李，与父母匆匆一别。妈妈盼星星、盼月亮，盼盼唠唠家常，一次又一次的落空。他们总是说你工作重要，先工作，先工作。 由于我3日要赶回北京，随胡锦涛副主席访问伊朗，在昆明我只能呆一天。这次在昆明给妈妈说了去年11月份我随吴邦国副总理访问非洲时，吴邦国副总理在科威特与我谈了半小时话的内容。首长说了这次我随访是他亲自点的名，目的有三个：1、鼓励和肯定华为，并让随行的各部部长也正面地认识和了解华为；2、了解一下我们公司的运行与管理机制，看看对别的企业有无帮助；3、看看政府对华为开拓国际市场是否能给予一些帮助。妈妈听了十分高兴，说“政府信任就好，只要企业干得好，其他都会随时间的证实而过去的。” 最近这两年，网上、媒体中对华为有一些内容，也是毁誉参半，妈妈是经过“文革”痛苦煎熬过的，对荣誉不感兴趣，对一些不了解我们真实情况的文章却十分忧心。我说了，我们不是上市公司，不需要公示社会，主要是对政府负责，对企业的有效运行负责。我们去年交税20亿多，2001年要交40多亿的税。各级政府对我们都信任。我们不能在媒体上去辩论，这样会引起争论，国家纸太贵，为我们这样一个小公司争论太浪费。为我们这样一个小公司，去干扰国家的宣传重点，我们也承担不了这么大责任。他们主要是不了解，我们也没有介绍，了解就好了。妈妈舒了一口气，理解了我的沉默。这次我还与母亲约好，今年春节我不工作，哪儿也不去，与几个弟妹陪她到海南过春节，好好聊一聊，痛痛快快聊一聊。以前，我节假日多为出国，因中国过节，外国这时不过节，正好多一些时间工作，这次我是彻底想明白了，要陪陪妈妈，我这一生还没有好好陪过她。没想到终成泡影。 8号那天，圆满结束对伊朗的访问，我们刚把胡副主席送上飞机，就接到纪平的电话，说我母亲上午10时左右，从菜市场出来，提着两小包菜，被汽车撞成重伤，孙总已前往昆明组织抢救。由于相隔千万里，伊朗的通信太差，真使人心急火燎。飞机要多次中转才能回来，在巴林转机要呆6.5个小时，真是心如煎熬，又遇巴林雷雨，飞机又延误两个小时，到曼谷时又再晚了十分钟，没有及时赶上回昆明的飞机，直到深夜才赶到昆明。 回到昆明，就知道妈妈不行了，她的头部全部给撞坏了，当时的心跳、呼吸全是靠药物和机器维持，之所以在电话上不告诉我，是怕我在旅途中出事。我看见妈妈一声不响地安详地躺在病床上，不用操劳、烦心，好像她一生也没有这么休息过。 我真后悔没有在伊朗给母亲一个电话。7日胡副主席接见我们8个随行的企业负责人，我汇报了两、三分钟，说到我是华为公司的时候，胡副主席伸出4个指头，说四个公司之一。我本想把这个好消息告诉妈妈，说中央首长还知道我们华为。但我没打，因为以前不管我在国内、国外给我母亲打电话时，她都唠叨：“你又出差了”，“非非你的身体还不如我好呢”，“非非你的皱纹比妈妈还多呢”，“非非你走路还不如我呢，你这么年纪轻轻就这么多病”，“非非，糖尿病参加宴会多了，坏得更快呢，你的心脏又不好”。我想伊朗条件这么差，我一打电话，妈妈又唠叨，反正过不了几天就见面了，就没有打。而这是我一生中最大的憾事。由于时差，我只能在中国时间8日上午一早打，告诉她这个喜讯，如果我真打了,拖延她一、两分钟出门，也许妈妈就躲过了这场灾难。这种悔恨的心情，真是难以形容。 我看了妈妈最后一眼后，妈妈溘然去世。1995年我父亲也是因为在昆明街头的小摊上，买了一瓶塑料包装的软饮料喝后，拉肚子，一直到全身衰竭去世。 爸爸任摩逊，尽职尽责一生，充其量可以说是一个乡村教育家。妈妈程远昭，是一个陪伴父亲在贫困山区与穷孩子厮混了一生的一个普通得不能再普通的园丁。 爸爸是穿着土改工作队的棉衣，随解放军剿匪部队一同进入贵州少数民族山区去筹建一所民族中学。一头扎进去就是几十年，他培养的学生不少成为党和国家的高级干部，有些还是中央院校的校级领导，而父亲还是那么位卑言微。 爷爷是浙江浦江县的一个做火腿的大师傅，爸爸的兄弟姊妹都没有读过书。由于爷爷的良心发现，也由于爸爸的执着要求，爸爸才读了书。爸爸在北京上大学期间，也是一个热血青年，参加学生运动，进行抗日演讲，反对侵华的田中奏章，还参加过共青团。由于爷爷、奶奶相继病逝，爸爸差一年没有读完大学，辍学回家。时日，正值国共合作开始，全国掀起抗日高潮，父亲在同乡会的介绍下，到广州一个同乡当厂长的国民党军工厂做会计员。由于战争的逼近，工厂又迁到广西融水，后又迁到贵州桐梓。在广西融水期间，爸爸与几个朋友在业余时间，开了一个生活书店，卖革命书籍，又组织一个“七·七”读书会，后来这个读书会中有几十人走上了革命前线，有相当多的人解放后成为党和国家的高级干部。粉碎“四人帮”后，融水重写党史时，还把爸爸邀请过去。 爸爸这段历史，是文革中受磨难最大的一件事情。身在国民党的兵工厂，而又积极宣传抗日，同意共产党的观点，而又没有与共产党地下组织联系。你为什么？这就成了一部分人的疑点。在文革时期，如何解释得清楚。他们总想挖出一条隐藏得很深的大鱼，爸爸受尽了百般的折磨。 妈妈其实只有高中文化程度，她要陪伴父亲，忍受各种屈辱，成为父亲的挡风墙,又要照顾我们兄妹七人，放下粉笔就要和煤球为伍，买菜、做饭、洗衣……又要自修文化，完成自己的教学任务，她最后被评为中学的高级教师。她的学生中，不少是省、地级干部及优秀的技术专家，他们都对母亲的教学责任心印象深刻。妈妈这么低的文化水平，自学成才，各种艰辛，只有她自己知道。 父母虽然较早参加革命，但他们的非无产阶级血统，要融入无产阶级的革命队伍，取得信任，并不是一件容易的事情。他们不可能像普通农民、工人那样政治纯洁。他们是生活在一个复杂的社会中，这个社会又是多元化组成的，不可能只有一种纯洁的物质。历次政治运动中，他们都向党交心，他们思想改造的困难程度要比别人大得多，所受的内心煎熬也非他人所能理解。他们把一生任何一个细节都写得极其详尽，希望组织审查。他们去世后，我请同学去帮助复印父母的档案，同学们看了父母向党交心的材料，都被他们的真情感动得泪流满面。终其一生，他们都是追随革命的，不一定算得上中坚分子，但无愧于党和人民。父亲终在1958年国家吸收一批高级知识分子入党时，入了党。当时向党交心，不像今天这样信息发达，那时，反对个别党员，有可能被说成反党。我们亲眼看到父母的谨小慎微、忘我地拼其全力工作，无暇顾及我们，就如我拼死工作，无暇孝敬他们一样。他们对党和国家、对事业的忠诚，已经历史可鉴。我今天要忏悔的，是我没有抽时间陪陪他们，送送他们。 回想起来，革命的中坚分子在一个社会中是少的，他们能以革命的名义，无私无畏地工作，他们是国家与社会的栋梁。为了选拔这些人，多增加一些审查成本是值得的。而像父母这样追随革命，或拥护革命，或不反对革命的人是多的，他们比不革命好，社会应认同他们，给以机会。不必要求他们那么纯洁，花上这么多精力去审查他们，高标准要求他们，他们达不到也痛苦,而是要精神文明与物质文明一同来支撑，以物质文明来巩固精神文明，以一种机制来促使他们主观上为提高生存质量，客观上是促进革命，充分发挥他们贡献的积极性。我主持华为工作后，我们对待员工，包括辞职的员工都是宽松的，我们只选拔有敬业精神、献身精神、有责任心、使命感的员工进入干部队伍，只对高级干部严格要求。这也是亲历亲见了父母的思想改造的过程，而形成了我宽容的品格。 我与父母相处的青少年时代，印象最深的就是渡过三年自然灾害的困难时期。今天想来还历历在目。 我们兄妹七个，加上父母共九人。全靠父母微薄的工资来生活，毫无其他来源。本来生活就十分困难，儿女一天天在长大，衣服一天天在变短，而且都要读书，开支很大，每个学期每人交2-3元的学费，到交费时，妈妈每次都发愁。与勉强可以用工资来解决基本生活的家庭相比，我家的困难就更大。我经常看到妈妈月底就到处向人借3-5元钱度饥荒，而且常常走了几家都未必借到。直到高中毕业我没有穿过衬衣。有同学看到很热的天，我穿着厚厚的外衣，说让我向妈妈要一件衬衣，我不敢，因为我知道做不到。我上大学时妈妈一次送我两件衬衣，我真想哭，因为，我有了，弟妹们就会更难了。我家当时是2-3人合用一条被盖，而且破旧的被单下面铺的是稻草。“文革”造反派抄家时，以为一个高级知识分子、专科学校的校长家，不知有多富，结果都惊住了。上大学我要拿走一条被子，就更困难了，因为那时还实行布票、棉花票管制，最少的一年，每人只发0.5米布票。没有被单，妈妈捡了毕业学生丢弃的几床破被单缝缝补补，洗干净，这条被单就在重庆陪我渡过了五年的大学生活。 父母的不自私，那时的处境可以明鉴。我那时14-15岁，是老大，其他一个比一个小，而且不懂事。他们完全可以偷偷地多吃一口粮食，可他们谁也没有这么做。爸爸有时还有机会参加会议，适当改善一下生活。而妈妈那么卑微，不仅要同别的人一样工作，而且还要负担七个孩子的培养、生活。煮饭、洗衣、修煤灶……什么都干，消耗这么大，自己却从不多吃一口。我们家当时是每餐实行严格分饭制，控制所有人欲望的配给制，保证人人都能活下来。不是这样，总会有一个、两个弟妹活不到今天。我真正能理解活下去这句话的含义。 我高三快高考时，有时在家复习功课，实在饿得受不了了，用米糠和菜合一下，烙着吃，被爸爸碰上几次，他心疼了。其实那时我家穷得连一个可上锁的柜子都没有，粮食是用瓦缸装着，我也不敢去随便抓一把，否则也有一、两个弟妹活不到今天。（我的不自私也是从父母身上学到的，华为今天这么成功，与我不自私有一点关系。）后三个月，妈妈经常早上塞给我一个小小的玉米饼，要我安心复习功课，我能考上大学，小玉米饼功劳巨大。如果不是这样，也许我也进不了华为这样的公司，社会上多了一名养猪能手，或街边多了一名能工巧匠而已。这个小小的玉米饼，是从父母与弟妹的口中抠出来的，我无以报答他们。 1997年我国的高等教育制度改革，开始向学生收费，而配套的助学贷款又没跟上，华为集团向教育部捐献了2500万元寒门学子基金。 父亲一生谨小慎微，自知地位不高，从不乱发言而埋头在学问中，可在“文革”横扫一切牛鬼蛇神的运动中，他还是被揪出来，反动学术权威、走资派、历史有问题的人……万劫难逃。他最早被关进牛棚。 1967年重庆武斗激烈时，我扒火车回家。因为没有票，还在火车上挨过上海造反队的打，我说我补票也不行，硬把我推下火车。也挨过车站人员的打，回家还不敢直接在父母工作的城市下车，而在前一站青太坡下车，步行十几里回去。半夜回到家，父母见我回来了，来不及心疼，让我明早一早就走，怕人知道，受牵连，影响我的前途。爸爸脱下他的一双旧皮鞋给我，第二天一早我就走了，临走，父亲说了几句话：“记住知识就是力量，别人不学，你要学，不要随大流。”“以后有能力要帮助弟妹。”背负着这种重托，我在重庆枪林弹雨的环境下，将樊映川的高等数学习题集从头到尾做了两遍，学习了许多逻辑、哲学。还自学了三门外语，当时已到可以阅读大学课本的程度，终因我不是语言天才，加之在军队服务时用不上，20多年荒废，完全忘光了。我当年穿走爸爸的皮鞋，没念及爸爸那时是做苦工的，泥里水里，冰冷潮湿，他更需要鞋子。现在回忆起来，感觉自己太自私了。 “文革”中，我家的经济状况，陷入了比自然灾害时期还困难的境地。中央文革为了从经济上打垮走资派，下文控制他们的人均标准生活费不得高于15元。而且各级造反派层层加码，真正到手的平均10元左右。我有同学在街道办事处工作，介绍弟妹们到河里挖砂子，修铁路抬土方……，弟妹们在我结婚时，大家集在一起，送了我100元。这都是他们在冰冷的河水中筛砂，修铁路时冒着在土方塌方中被掩埋的危险……挣来的。那时的生活艰苦还能忍受，心痛比身痛要严重得多，由于父亲受审查的背景影响，弟妹们一次又一次的入学录取被否定，那个年代对他们的损失就是没有机会接受高等教育。除了我大学读了三年就开始文化大革命外，其他弟妹有些高中、初中、高小、初小都没读完，他们后来适应人生的技能，都是自学来的。从现在的回顾来看，物质的艰苦生活以及心灵的磨难是我们后来人生的一种成熟的宝贵财富。 “文革”对国家是一场灾难，但对我们是一次人生的洗礼，使我政治上成熟起来，不再是单纯的一个书呆子。我虽然也参加了轰轰烈烈的红卫兵运动，但我始终不是红卫兵，这也是一个奇观。因为父亲受审的影响，哪一派也不批准我参加红卫兵。后来我入伍后，也是因为父亲问题，一直没有通过入党申请，直到粉碎“四人帮”以后。 1976年10月，中央一举粉碎了“四人帮”，使我们得到了翻身解放。我一下子成了奖励“暴发户”。“文革”中，无论我如何努力，一切立功、受奖的机会均与我无缘。在我领导的集体中，战士们立三等功、二等功、集体二等功，几乎每年都大批涌出，而唯我这个领导者，从未受过嘉奖。我已习惯了我不应得奖的平静生活，这也是我今天不争荣誉的心理素质培养。粉碎“四人帮”以后，生活翻了个个儿，因为我两次填补过国家空白，又有技术发明创造，合乎那时的时代需要，突然一下子“标兵、功臣……”部队与地方的奖励排山倒海式地压过来。我这人也热不起来，许多奖品都是别人去代领回来的，我又分给了大家。 1978年3月我出席了全国科学大会，6000人的代表中，仅有150多人在35岁以下，我33 岁。我也是军队代表中少有的非党人士。在兵种党委的直接关怀下，部队未等我父亲平反，就直接去为查清我父亲的历史进行外调，否定了一些不实之词，并把他们的调查结论，寄给我父亲所在的地方组织。我终于入了党。后来又出席了党的第十二次全国代表大会。父亲把我与党中央领导合影的照片，做了一个大大的镜框，挂在墙上，全家都引以自豪。 我父亲也在粉碎“四人帮”后不久平反。由于那时百废待兴，党组织需要尽快恢复一些重点中学，提高高考的升学率，让他去做校长。“文革”前他是一个专科学校的校长。他不计较升降，不计较得失，只认为有了一种工作机会，全身心地投进去了，很快就把教学质量抓起来了，升学率达到了90%多，成为远近闻名的学校。他直到1984年75岁才退休。他说，他总算赶上了一个尾巴，干了一点事。他希望我们珍惜时光，好好干。至此，我们就各忙各的，互相关心不了了。我为老一辈的政治品行自豪，他们从牛棚中放出来，一恢复组织生活，都拼命地工作。他们不以物喜，不以己悲，不计荣辱，爱国爱党，忠于事业的精神值得我们这一代人、下一代人、下下一代人学习。生活中不可能没有挫折，但一个人为人民奋斗的意志不能动摇。 我有幸在罗瑞卿同志逝世前三个月，有机会聆听了他为全国科学大会军队代表的讲话，说未来十几年是一个难得的和平时期，我们要抓紧全力投入经济建设。我那时年轻，缺少政治头脑，并不明白其含意。过了两、三年大裁军，我们整个兵种全部被裁掉，我才理解了什么叫预见性的领导。 转入地方后，不适应商品经济，也无驾驭它的能力，一开始我在一个电子公司当经理也栽过跟斗，被人骗过。后来也是无处可以就业，才被迫创建华为的。华为的前几年是在十分艰难困苦的条件下起步的。这时父母、侄子与我住在一间十几平方米的小房里，在阳台上做饭。他们处处为我担心，生活也十分节省。攒一些钱说是为了将来救我。（听妹妹说，母亲去世前两个月，还与妹妹说，她存有几万元，以后留着救哥哥，他总不会永远都好。母亲在被车撞时，她身上只装了几十元钱，又未带任何证件，是作为无名氏被110抢救的。中午吃饭时，妹妹、妹夫才发现她未回来，四处寻找，才知道遇车祸。可怜天下父母心，一个母亲的心有多纯。）当时在广东卖鱼虾，一死就十分便宜，父母他们专门买死鱼、死虾吃，说这比内地还新鲜呢！晚上出去买菜与西瓜，因为卖不掉的菜，便宜一些。我也无暇顾及他们的生活，以致母亲糖尿病严重我还不知道，是邻居告诉我的。华为有了规模发展后，管理转换的压力十分巨大，我不仅照顾不了父母，而且连自己也照顾不了，我的身体也是那一段时间累垮的。我父母这时才转去昆明我妹妹处定居。我也因此理解了要奋斗就会有牺牲，华为的成功，使我失去了孝敬父母的机会与责任，也消蚀了自己的健康。 回顾我自己已走过的历史，扪心自问，我一生无愧于祖国、无愧于人民，无愧于事业与员工，无愧于朋友，唯一有愧的是对不起父母，没条件时没有照顾他们，有条件时也没有照顾他们。 爸爸妈妈，千声万声呼唤您们，千声万声唤不回。 逝者已经逝去，活着的还要前行。 此篇文章是任正非先生怀念父母的真情流露。反映了一个普通青年，在国内大环境、大变革下的进取之路。没有伤痕累累，何来皮糙肉厚，自古英雄多磨难！ ","link":"https://Mungeryang.github.io/post/ren-zheng-fei-wen-ji-one/"},{"title":" C/C++  FOR EVERYONE  ","content":" 加州大学圣克鲁兹分校;杨桂淼&copy; 心水总结&trade; 你来的太晚了，但我转念一想，你来的又太及时了。———董宇辉 运算符优先级 优先级 运算符 名称或含义 使用形式 结合方向 说明 1 [ ] 数组下标 数组名[常量表达式] 左到右 – () 圆括号 (表达式）/函数名(形参表) – . 成员选择（对象） 对象.成员名 – -&gt; 成员选择（指针） 对象指针-&gt;成员名 – 2 - 负号运算符 -表达式 右到左 单目运算符 ~ 按位取反运算符 ~表达式 ++ 自增运算符 ++变量名/变量名++ – 自减运算符 –变量名/变量名– ***** 取值运算符 *指针变量 &amp; 取地址运算符 &amp;变量名 ! 逻辑非运算符 !表达式 (类型) 强制类型转换 (数据类型)表达式 – sizeof 长度运算符 sizeof(表达式) – 3 / 除 表达式/表达式 左到右 双目运算符 ***** 乘 表达式*表达式 % 余数（取模） 整型表达式%整型表达式 4 + 加 表达式+表达式 左到右 双目运算符 - 减 表达式-表达式 5 &lt;&lt; 左移 变量&lt;&lt;表达式 左到右 双目运算符 &gt;&gt; 右移 变量&gt;&gt;表达式 6 &gt; 大于 表达式&gt;表达式 左到右 双目运算符 &gt;= 大于等于 表达式&gt;=表达式 &lt; 小于 表达式&lt;表达式 &lt;= 小于等于 表达式&lt;=表达式 7 == 等于 表达式==表达式 左到右 双目运算符 ！= 不等于 表达式!= 表达式 8 &amp; 按位与 表达式&amp;表达式 左到右 双目运算符 9 ^ 按位异或 表达式^表达式 左到右 双目运算符 10 | 按位或 表达式|表达式 左到右 双目运算符 11 &amp;&amp; 逻辑与 表达式&amp;&amp;表达式 左到右 双目运算符 12 || 逻辑或 表达式||表达式 左到右 双目运算符 13 ? : 条件运算符 表达式1?表达式2: 表达式3 右到左 三目运算符 14 = 赋值运算符 变量=表达式 右到左 – /= 除后赋值 变量/=表达式 – *= 乘后赋值 变量*=表达式 – %= 取模后赋值 变量%=表达式 – += 加后赋值 变量+=表达式 – -= 减后赋值 变量-=表达式 – &lt;&lt;= 左移后赋值 变量&lt;&lt;=表达式 – &gt;&gt;= 右移后赋值 变量&gt;&gt;=表达式 – &amp;= 按位与后赋值 变量&amp;=表达式 – ^= 按位异或后赋值 变量^=表达式 – |= 按位或后赋值 变量|=表达式 – 15 ， 逗号运算符 表达式,表达式,… 左到右 – 所以在定义并使用结构体指针的时候，不像调用普通的结构体那样struct.attribute,而是struct-&gt;attribute；就是因为运算符的优先级不同。 Different from stdio.h and standard.io Standard I/O. The pre-process command brings in both printf and now scanf. Scanf is a basic routine for doing input. By default, most cases we will come from our keyboard. PI.C In our case, standard input is defaulted to the computer keyboard. Here we see another directive. It's called a defined directive. The define directive does an interesting thing. In our case, standard input is defaulted to the computer keyboard. Here we see another directive. It's called a defined directive. The define directive does an interesting thing.we want this to be documentation.we introduce a program, which is main. We begin with what's called the open brace for a compound statement. The first statement is a declaration statement. #include&lt;stdio.h&gt; //define后面不加分号 #define PI 3.1415926 int main(void){ double area = 0.0,radius = 0.0; printf(&quot;please input the radiuse:\\n&quot;); scanf(&quot;%lf&quot;, &amp;radius); area = PI * radius * radius; printf(&quot;area = %f&quot;,area); return 0; } Introduction Output is a very important component of programming. stdio.h we see stdio.h, and the .h is an extension that intent that means a header file, and that means that in this file which will be included automatically with our program. So it's called pre-processor because it happens before the C code is compiled. So extra code gets added, and that code is the code that we're going to need for doing printf. Without it the printf would be undeclared. Code process int is a keyword meaning that the program returns an integer Void is a keyword that would if it's used as a data type means it's an undefined data type, or in this case it means that the argument list is empty. scanf if you don't fully understand it, the scanf, which gets us input.In this case, we want to look for the address of that variable, and addresses location in memory. Then here we do the computation. scanf() is found in &lt;stdio.h&gt;;The &amp; sign means “store at the location of variable&quot;. So it's very important, in your expressions, to know what domain you're in. By domain, I mean things like integer and double, because that's going to tell you what the arithmetic is being done in, and that arithmetic can affect the meaning of an operator, like divide. Divide can be an integer divide, if everything is integer, or it can be a floating point divided, if one of the arguments is floating point. 在学习C语言时，常常会发现有的scanf()里需要&amp;，而有的不需要。 当scanf函数后面接收的是一个地址的时候，此时不需要加“&amp;”-&gt;例如传入数组 当sacnf函数后面接收的不是一个地址、而是实际变量的时候，此时需要加“&amp;”-&gt;例如传入单一变量 printf输出格式控制：printf(“%([flags ] [width ] [.prec ] [hIL ])type”,var); 对于格式字符串：以 %号开头，用于定义每个数据的输出格式： d 以十进制形式输出 带 符号整数（正数不输出符号） ld 输出长整型数 o 以八进制形式输出 无 符号整数（不输出前缀0） x,X 以十六进制形式输出 无 符号整数（不输出前缀0x） u 以十进制形式输出 无 符号整数 f 以小数形式输出单、双精度实数 lf 按long double类型输出 e,E 以指数形式输出单、双精度实数 g,G 按数据精度以%f或%e中较短的输出宽度输出单、双精度实数 c 输出单个字符 s 输出字符串 % [对齐方式] [输出最小宽度] 整数类型。对齐方式用默认为右对齐，若为&quot;-&quot;负号，则为左对齐；输出最小宽度n，若实际位数小于n，则补以空格或0。 % [输出最小宽度] [ . 精度] 实数类型 最小宽度n，包括整数，小数点及小数部分的总位数，默认右对齐，前加负号为左对齐；精度m，若实际位数大于m，则四舍五入截去超过部分，一般实数默认输出6位。 版权声明：本文为CSDN博主「亲亲Friends」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/u014261408/article/details/90139849 版权声明：本文为CSDN博主「亲亲Friends」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 Lexical Elements and Data Types Character sets and tokens A token can be an identifier main is a legal identifier A token can be punctuation such as ; A token can be an operator such as + or / Comments It's important for documentation and readability. In order to be able to maintain or modify the program and understand its use, we want the program to be literate. So we could let say, add some more comments if we want, let me add some other comments here. keywords The table below lists all keywords reserved by the C language. When the current programming language is C or C++, these keywords cannot be abbreviated, used as variable names, or used as any other type of identifiers. auto else long switch break enum register typedef case extern return union char float short unsigned const for signed void continue goto sizeof volatile default if static while do int struct _Packed double keywords identifiers 23 my_dna is not an identifier because the first character of that sequence is a digit, so that's not allowed. So digit is not allowed anywhere but in the first character. Underscores and alphabet are allowed anywhere including the first characters. when you want something that's for counting, you can use i, j, and k. Also you frequently can use n as another underscored integer, those would all be good choices. expression -&gt;自增自减的运算逻辑 a = 5 b = 7 ++a + b++ = 13 short, long, and unsigned. Short it means use less data. Long means you use more, a bigger range. So short can mean a smaller range typically, you're using fewer bytes. If it was 2.0 divided by 3 or 2.0 divided by 3.0 or 2 divided by 3.0 where one of the arguments or both the arguments are double then indeed it would be in the floating point type. You would have a type of floater doubles and your result would be 0.666. So this mistake gets made often when you are thinking you want to do something like average over some integer data and you forget that dividing can be either an integer operation or a floating point operation, you can get a mistake. List of Escape Sequences in C Escape Sequence Meaning \\a Alarm or Beep \\b Backspace \\f Form Feed \\n New Line \\r Carriage Return \\t Tab (Horizontal) \\v Vertical Tab \\ Backslash ' Single Quote &quot; Double Quote ? Question Mark \\nnn octal number \\xhh hexadecimal number \\0 Null int types On your typical modern machine, an int is stored in 32-bits. That's 32 zeros and ones and to see even worthwhile especially if you're going to go into computer science to learn how to work in binary. Now, when you're working with an end stored in 32-bits. Then what you can represent is limited and it's limited to plus or minus two billion, and I've written it out here explicitly. You can go positively up to 2,147, 436, 647 and your smallest number, your largest negative number, another way to put it is a 2,147,483,648. It's not symmetric because of the fancy way people represent integers on the machine. It's called a two's complement representation. Typically, the first bit is in fact the bit that affects how you interpret the sign. Short it means use less data. Long means you use more, a bigger range. So short can mean a smaller range typically, you're using fewer bytes. You'll see in a second when I write an example that from my machine short is two bytes, ordinary, int is four bytes as we've already said, and then long will be eight bytes. We can also use u or U and l or L to specify the type of an integer constant as an unsigned long int. 89ul - is of type unsigned long int. Unsigned Integers (often called &quot;uints&quot;) are just like integers (whole numbers) but have the property that they don't have a + or - sign associated with them. Thus they are always non-negative (zero or positive). We use uint's when we know the value we are counting will always be non-negative. For example, if we are counting the number of players in a game, we could use a uint because there will always be 0 or more players. The format specifiers are used in C for input and output purposes. Using this concept the compiler can understand that what type of data is in a variable during taking input using the scanf() function and printing using printf() function. Here is a list of format specifiers. Format Specifier Type %c Character %d Signed integer %e or %E Scientific notation of floats %f Float values %g or %G Similar as %e or %E %hi Signed integer (short) %hu Unsigned Integer (short) %i Unsigned integer %l or %ld or %li Long %lf Double %Lf Long double %lu Unsigned int or unsigned long %lli or %lld Long long %llu Unsigned long long %o Octal representation %p Pointer %s String %u Unsigned int %x or %X Hexadecimal representation %n Prints nothing %% Prints % character Flow of control and simple functions The conditional statement if and if-else 在处理0/1逻辑运算时，if与while语句的简写等价表达： if(a)与if(a!=0)等价；while(a)表示当a!=0时执行循环，其等价于while(a!=0) if(!a)与if(a==0)等价；while(!a)表示当a=0时执行循环，其等价于while(a==0) when the first argument evaluates false, we needn't evaluate the second argument. So we avoid evaluating the second argument. That's called short circuit evaluation. true table: T F T T F F F F You should get out of it how to use an if-else. By the way, a simpler kind of statement is just an if, and the if-statement, you have if expression and then you execute the statement if it's true. So if you have an expression that evaluates to zero, then you omit the statement. Indeed you could have turned that if-else into two if-statements, but that would be not as elegant and also somewhat inefficient because you would be evaluating the relation speed less than 65 twice. The iterative statement while What we do is recheck first to see if the expression is zero. If the expression is zero, the statement is not done. It's omitted and we just skip to whatever is next. We can think of that as false. Though really in C false is zero and true is non-zero. However, if the expression is non-zero, then we execute the statement that's sitting under the while. Then, we repeat. We go back and ask is the expression is zero we continue. That just keeps going until we see the expression is zero. 函数原型：int getchar(void); 返回类型为int,参数为void 头文件：#include&lt;stdio.h&gt; 返回值：getchar返回的是字符的ASCII码值（整数）。getchar在读取结束或者失败的时候，会返回EOF。(EOF意思是end of file,本质上是-1） 读取方式：只能输入字符型,输入时遇到回车键才从缓冲区依次提取字符。 结束输入的方式：以Enter结束输入（空格不结束），接受空格符。 舍弃回车符的方法：以Enter结束输入时，接受空格，会舍弃最后的回车符。 -&gt;while ((ch=getchar()) != 'EOF') getchar先读取一个字符放到ch里面去，如果这个字符不等于EOF，就进入循环，打印这个字符。当getchar读到文件末尾或者结束时，它会返回一个EOF，此时结束循环。 The while loop expression while((c = getchar()) != EOF) is used to read a char from the input until it sees the special value defined EOF. EOF，为End Of File的缩写，通常在文本的最后存在此字符表示资料结束。C语言中，EOF常被作为文件结束的标志。还有很多文件处理函数处错误后的返回值也是EOF，因此常被用来判断调用一个函数是否成功。 The for statement and its while analog Keyword for expression 1; expression two ; and then expression 3. e1 is most typically used as an initializer, just like in our simple example. e2 is typically, well, that's always the terminating condition. So if it's going to work and it's going to be over a finite number of times, then this f determinate, that's where you can make some interesting mistakes, and get what's called an infinite loop. So this has to be tested. e3 is typically, again, this all typical, the typical use is either increment or decrement. So the terminating condition frequently involves mostly an integer, expression of variable and then incrementing that integer or decrementing it leads to a termination condition. think about i++ and ++i. #include &lt;stdio.h&gt; int main() { int i=5,j; j=i++; printf (&quot;\\nafter postfix increment i=%d j=%d&quot;, i,j); i=5; j=++i; printf (&quot;\\n after prefix increment i=%d j=%d&quot;,i,j); return 0; } the output is: after postfix increment i=6 j=5 after prefix increment i=6 j=6 oddball operators-conditional and comma 二目/三目运算的逻辑： c = (a &lt; b)? a:b means: if a &lt; b: c = a else c = a -&gt;express? expr1:expre2 #include&lt;stdio.h&gt; int main(void){ int speed; printf(&quot;Enter a speed as a integer:&quot;); scanf(&quot;%d&quot;,&amp;speed); speed = (speed &lt;= 65) ? (65):(speed &lt;= 70) ? (70):(90); switch (speed) { case 65: //TODO printf(&quot;safe&quot;); break; case 70: //TODO printf(&quot;little dangerous&quot;); break; case 90: printf(&quot;very dangerous&quot;); break; default: //TODO printf(&quot;incorrect speed&quot;); break; } return 0; } Break and continue and switch break与continue的的用法以及区别： 当它们用在循环语句做循环体时，break用于立即退出本层循环，而continue仅仅结束本次循环（本次循环体内不执continue语句后的其它语句，但下一次循环还会继续执行。 如果有多层循环时，break只会跳出本层循环，不会跳出其他层的循环 break可用于switch语句，表示跳出整个switch语句块，而continue则不能单独的用于switch语句。但是continue可以用于循环内部的switch语句 In a switch statement, basically you switched on an integral expression. So simple one might be the integer i, and then you have a bunch of cases and those cases can,Be critical cases where you want to do different things depending on some small value of i. what you're looking at syntactically is switch an integral expression, it can't be floating point, it must be integral. But it could be something like a short or a long in, or ASCII value for character.If there is no default, then you just don't do anything and you leave. Switch多路选择结构，常用语三个及以上问题的多选方案。 switch (speed) { case 65: //TODO printf(&quot;safe&quot;); break; case 70: //TODO printf(&quot;little dangerous&quot;); break; case 90: printf(&quot;very dangerous&quot;); break; default: //TODO printf(&quot;incorrect speed&quot;); break; } functions, recursion, arrays, and pointers types of functions Functions are important because they are crucial to the reuse of code.They're especially crucial if they exist in libraries. Libraries like standardio.h, standardlive.h, these are universally useful libraries, and we don't have to rewrite them. So we have to understand how to use them. Our syntax for a function. We have a types such as int or void. We have a function name, and the function name is a form of documentation like printf, or rand, or main. Then we have a parameter list. Then you have the body of the function, which is typically this bracing close what we call block. The block starts with a bunch of declarations if needed, and then a bunch of executable statements. void The function does not need any return statement int The function can return any value,the function exits at the end of its compound statement/block definition. return A return statement is a flow of control keyword return, and we've already seen it. At the end of a function in main, what it's meaning is that main returns of value zero, but where does return it to? Main is the program that you're executing, it returns it to the operating system, and it's used by the operating system sometimes to figure out whether if there was an error in the program. So return of zero means the program finished in an expected or orderly way, a normal exit. people generally when they're returning expression even if they don't need to, because of clarity stylistically they do use parenthesization. Storage class 详解四种存储变量 auto:This is the default storage class for all the variables declared inside a function or a block. Hence, the keyword auto is rarely used while writing programs in C language. Auto variables can be only accessed within the block/function they have been declared and not outside them (which defines their scope). Of course, these can be accessed within nested blocks within the parent block/function in which the auto variable was declared. However, they can be accessed outside their scope as well using the concept of pointers given here by pointing to the very exact memory location where the variables reside. They are assigned a garbage value by default whenever they are declared. 在函数体中声明则只能在当前函数体中使用,在main函数以及其他函数外声明即为全局变量 **extern:**Extern storage class simply tells us that the variable is defined elsewhere and not within the same block where it is used. Basically, the value is assigned to it in a different block and this can be overwritten/changed in a different block as well. So an extern variable is nothing but a global variable initialized with a legal value where it is declared in order to be used elsewhere. It can be accessed within any function/block. Also, a normal global variable can be made extern as well by placing the ‘extern’ keyword before its declaration/definition in any function/block. This basically signifies that we are not initializing a new variable but instead we are using/accessing the global variable only. The main purpose of using extern variables is that they can be accessed between two different files which are part of a large program. For more information on how extern variables work, have a look at this link. 如果一个文件调用另一个文件中的变量，则在调用文件中需要使用extern声明变量 static:This storage class is used to declare static variables which are popularly used while writing programs in C language. Static variables have the property of preserving their value even after they are out of their scope! Hence, static variables preserve the value of their last use in their scope. So we can say that they are initialized only once and exist till the termination of the program. Thus, no new memory is allocated because they are not re-declared. Their scope is local to the function to which they were defined. Global static variables can be accessed anywhere in the program. By default, they are assigned the value 0 by the compiler.静态变量如果没有被初始化，则自动初始化为0。静态变量只能够初始化一次 **register:**This storage class declares register variables that have the same functionality as that of the auto variables. The only difference is that the compiler tries to store these variables in the register of the microprocessor if a free registration is available. This makes the use of register variables to be much faster than that of the variables stored in the memory during the runtime of the program. If a free registration is not available, these are then stored in the memory only. Usually few variables which are to be accessed very frequently in a program are declared with the register keyword which improves the running time of the program. An important and interesting point to be noted here is that we cannot obtain the address of a register variable using pointers. 声明为register的变量在由内存调入到CPU寄存器后，则常驻在CPU的寄存器中 recursion-&gt;递归 In the recursive case, we have a test to see if we're what we're going to call the base case.So if we're at the base case, n equals zero and we're going to print blastoff. If we're not at the base case, then we have to do the recursion. Pointers and Arrays 认真学好指针！ array Int data square bracket, a hundred square bracket, semicolon. So as with normal declaration is a types this could be any of the standard types like double long char and identifier that should indicate what we're processing. //数组创建：int是数组类型；arr是名字；100是数组长度 int arr[100]; //string数组 char str[] = &quot;abc&quot;; Wi-Ki: Recursion (adjective: recursive) occurs when a thing is defined in terms of itself or of its type. Recursion is used in a variety of disciplines ranging from linguistics to logic. The most common application of recursion is in mathematics and computer science, where a function being defined is applied within its own definition. While this apparently defines an infinite number of instances (function values), it is often done in such a way that no infinite loop or infinite chain of references (&quot;crock recursion&quot;) can occur. #include&lt;stdio.h&gt; int main(void){ const int SIZE = 5; int grades[5] = {78, 57, 85, 99, 66}; double sum = 0.0; double ave = 0.0; printf(&quot;my scores are:\\n&quot;); for(int i = 0;i &lt; SIZE;i++){ sum += grades[i]; } printf(&quot;sum=%lf\\n&quot;,sum); ave = sum / SIZE; printf(&quot;ave=%lf\\n&quot;,ave); return 0; } pointers-传说中的指针 简而言之，指针只有两大重要作用：传递和偏移。 Exactly how is an array stored in memory? What we have to understand is an array has a place where it's stored and it starts at what's called its base address. That's because we want a bunch of elements. 理解指针就要理解数组在计算机中的存储原理和地址的含义 we have to have a place to start, and then it runs contiguously through as much memory as is needed. That gets allocated automatically in this case by the compiler. The array has a very strong relationship with another data type called a pointer. A simple data type like an integer, when we say integer a inside a block, it means create a variable in memory. So when we think of a variable, we think of its name. That's how we use it in the code but we think it has a location and memory, and inside that location is some stored value interpreted as an integer. So an address calculation for an array in C, base address plus the offset, the index times the size required, the size in bytes required to store that individual datatype. But if you just want to be a simple programmer, it may be enough to just understand that indexing works for you. But really to get to the next level, you want to really understand the notion of address. If we tried to print the value of P, we would get some address. If we were to dereference it, star is a dereferencing. If we were to dereference P, the value there would be the integer value。 Very important that you get to understand pointer, variable, memory address. 函数 值传递VS引用传递 call--by-value 按值调用 call by reference 引用调用 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; int SumArr(int A[]){ int i,sum = 0; int size = sizeof(A)/sizeof(A[0]); printf(&quot;Subfunc - size of A =%d,size of A[0] = %d\\n&quot;,sizeof(A),sizeof(A[0])); for(i = 0;i &lt; size;i++){ sum += A[i]; } } int main(void){ int A[] = {1,2,3,4,5}; int size = sizeof(A)/sizeof(A[0]); int total = SumArr(A); printf(&quot;the sum = %d\\n&quot;,total); printf(&quot;mian - size of A =%d,size of A[0] = %d\\n&quot;,sizeof(A),sizeof(A[0])); return 0; } 在子函数中，只是拷贝的主函数中数组的首地址，而不是把主函数中所有的数组元素传入到子函数的数组中。无论是传入普通类型还是指针类型。 When using a reference declaration in a function header to simulate call-by-reference, it means the referenced variable in the calling environment can be changed. Keep in mind this is what scanf() does. Unlike many programming languages an array name in C is just a pointer to a base address and there is no way to know its size. 了解一下变量类型在数组中所占有的内存大小： types size int 4-bytes char 1-bytes float 4-bytes int main{ int a =5; int *p; p = &amp;a;//p就是a的地址 printf(&quot;%p&quot;,p);//指针变量 printf(&quot;%p&quot;,&amp;a);//a的地址 printf(&quot;%p&quot;,&amp;p);//指针p的地址-“地址的地址” printf(&quot;%d&quot;,*p);//指针的解引用-Dereference } 指针的偏移 int arr[] = {12,23,34}; int *p = arr; printf(&quot;%p\\n&quot;,&amp;arr[1]); printf(&quot;%p\\n&quot;,arr+1); printf(&quot;%p\\n&quot;,&amp;arr+1);//&amp;arr+1是跳过了整个数组去寻值 printf(&quot;%p\\n&quot;,p+1); printf(&quot;%d\\n&quot;,p[1]); printf(&quot;%d&quot;,*(p+2)); 动态内存申请 引入**#include&lt;stdlib.h&gt;，头文件；调用malloc**申请内存。 数组一开始定义就确定好了，数组是放在栈空间。C语言数组长度固定是因为其固定在整型、浮点型、字符型、数组变量的栈空间中，而占空间的大小是在编译时确定好的，如果栈空间不确定，那就要存放在堆空间。 栈空间-&gt;教室大小/长度固定 堆空间-&gt;长度不固定 必须先申请内存在进行操作！！！！！ LinkList CreatList2(LinkList &amp;L){ //必须先申请内存在进行操作 int x; L = (LinkList)malloc(sizeof(LNode)); LNode *s; LNode *r = L;//等价于LinkList r=L; //L = (LinkList)malloc(sizeof(LNode)); scanf(&quot;%d&quot;,&amp;x); while(x != 9999){ s = (LinkList)malloc(sizeof(LNode)); s-&gt;data = x; r-&gt;next = s; r = s; scanf(&quot;%d&quot;,&amp;x); } r-&gt;next = NULL; return L; } 您比如说这个尾插法，我一开始是这么写的： int x; //L = (LinkList)malloc(sizeof(LNode)); LNode *s; LNode *r = L;//等价于LinkList r=L; L = (LinkList)malloc(sizeof(LNode)); 程序的执行顺序是从上到下的，切记；所以内存后申请总是爆错。 修改顺序后，立马就对了： int x; L = (LinkList)malloc(sizeof(LNode)); LNode *s; LNode *r = L;//等价于LinkList r=L x.malloc必须写在前面，血的教训啊!😢 C语言中C++的引用 在严蔚敏老师的《数据结构》一书中，伪代码给出的是使用C++的方式，所以在编译器中创建文件时，一定要把文件后缀改成.cpp文件而不是.c文件。 在参数传递与调用的过程中，体现出来了C++对于参数传递和调用的便捷性。 void change(int &amp;a){ a = a + 1; } int main(){ int i = 10; change(i); printf(&quot;i = %d&quot;,i); return 0; } -&gt;为什么我们需要在形参的地方使用C++的引用？ 在子函数中去改变对应的形参赋值后，子函数结束后，对应主函数的实参就发生了变化。 如果没有使用引用，那么在子函数中给形参赋值；子函数结束后，主函数中的实参不会发生变化。 其实说白了就是，你在子函数中要不要改变实参的值-&gt;看实际需求，如果调用的子函数就是用来去改变实参的，那么就必须加上引用，否则，就不需要加引用，形参就是一个辅助变量。借助形参，去实现函数功能。 如果不理解，任何情况下都加上&amp; 结构体定义时的小细节区别对比-typedef 结构体定义前加与不加typedef的区别是在调用结构体的时候发现的。 首先对于不同方式创建结构体： //定义typedef结构体 typedef struct student{ int ID; char name[10]; char sex; }stu; //定义无typedef结构体 struct student{ int ID; char name[10]; char sex; }stu; 两种创建方式虽然功能上大体一致，但是对于stu这个别名的使用上确有这千差万别。 首先对于typedef定义的结构体来说，stu是可以在主函数中去实例化一个对象的。定义了结构体类型student和student的类别名stu stu s; s.ID = 1; s.name = 'ss'; s.sex = 'M'; 这样书写完全没问题；但是如果创建ADT之前不加typedef，这样创建就会报错。不加typedef,stu就是一个单纯的实例化对象了，只能在主函数去使用属性，而不能再去实例化其他变量。定义了结构体类型student和student的对象实例stu stu.ID = 1; stu.name = 'ss'; stu.sex = 'M'; stu s会报错。 结构也是一种数据类型, 可以使用结构变量, 因此像其它类型的变量一样, 在使用结构变量时要先对其定义。 定义结构变量的一般格式为: struct 结构名 { 类型 变量名; 类型 变量名; ... } 结构变量; 结构名是结构的标识符不是变量名。 另一种常用格式为: typedef struct 结构名 { 类型 变量名; 类型 变量名; ... } 结构别名; 另外注意: 在C中，struct不能包含函数。在C++中，对struct进行了扩展，可以包含函数。 文件类型关系 只有.h文件的Package可以是接口或模板(template)的定义； 只有.cpp文件的Package可以是一个程序的入口。 简单讲，一个Package就是由同名的.h和.cpp文件组成。当然可以少其中任意一个文件。 .cpp是C++文件的扩展名，.cpp主要是进行函数定义的，类中函数的声明和调用是在.h中的，.h文件主要是把函数进行封装，在写很多代码的时候，用上.h有很好的作用，这时候我们只要给对方公司*.h文件就行了，这样既提供了必要的信息，又保护了我们的核心代码。在.cpp中对.h文件进行调用时，要用#include.xxxh。建议按照**.h *.cpp配对分开写。 .cpp内用于： 函数实现（包括全局函数（默认）、静态函数） 全局变量、静态变量定义 静态函数声明，静态变量声明.h内用于 h内用于： 全局函数声明，注意静态函数不包括在内。 全局变量声明，无静态变量。 版权声明：本文为CSDN博主「菜鸟程序员小黄」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/m0_55671922/article/details/115552516 逻辑结构与存储结构 数据存储的逻辑结构有：集合结构、链式结构、树状结构、图结构 存储结构有：顺序存储和链式存储 线性表 特点： 元素个数是有限的 表中数据的数据类型全部相同-&gt;每个元素占有相同的内存空间 所有元素逻辑上是连续的，排序有先后顺序 线性表是独立于数据结构的逻辑结构不是存储结构，不要轻易把数组和链表与线性表混淆。 优点： 可以随机存取表中的任意一个元素，存储密度高，每个元素只存取数据元素 缺点： 插入和删除时需要移动大量元素，变化较大，难以确定存储空间大小；需要分配连续的存储空间，不够灵活。 单链表 单链表的增删改查 重点掌握单链表的头插法与尾插法的插入思路。 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; //在此程序中，*LinkList是变量的指针；LinkList为指针变量。 //单链表的增删改查 //线性表的链式表示就是单链表 #define Maxsize 50 #define InitSize 100 //定义一个整型类型的变量 typedef int ElemType; //单链表结构创建-8个字节 typedef struct LNode {//单链表的结构 ElemType data;//数据域 struct LNode* next;//指针域 }LNode,*LinkList; //LinkList为结构体指针等价于struct LNode* //别名LNode可以和上面保持一致 //头插法插入新的节点 //创建单链表-&gt;带有头结点 //头结点只需要头指针指向，啥也不存 LinkList CreatList1(LinkList &amp;L) { LNode* q; int x; L = (LinkList)malloc(sizeof(LNode));//带头结点的链表 L-&gt;next = NULL; scanf_s(&quot;%d&quot;, &amp;x); while (x != 9999) { q = (LinkList)malloc(sizeof(LNode)); q-&gt;data = x; q-&gt;next = L-&gt;next; L-&gt;next = q; scanf_s(&quot;%d&quot;, &amp;x); } return L; } //尾插法创建单链表 LinkList CreatList2(LinkList &amp;L) { int x; L = (LinkList)malloc(sizeof(LNode));//带头结点的链表 //在这里需要注意的是，r本身就是表尾节点,指向链表尾部 LNode* s, * r = L;//等价于LinkList s,r=L; scanf_s(&quot;%d&quot;, &amp;x); while (x != 9999) { s = (LinkList)malloc(sizeof(LNode)); s-&gt;data = x; r-&gt;next = s; r = s;//r指向新的表尾节点 scanf_s(&quot;%d&quot;, &amp;x); } r-&gt;next = NULL;//尾节点指针赋值为空 return L; } //查找节点 LNode* GetElem(LinkList L, int i) { int j = 1; //初始指向虚拟头结点的下一个节点 LNode* p = L-&gt;next; if (i == 0) { return L; } if (i &lt; 1) { return NULL; } //p-&gt;非空 while (p &amp;&amp; j &lt; i) { p = p-&gt;next; j++; } return p; } //任意两个节点之间插入节点 //第i个位置插入值为e的节点 bool InsertFrontList(LinkList L,int i,ElemType e) { LinkList p = GetElem(L,i - 1); if (NULL == p) { return false; } LinkList s = (LNode*)malloc(sizeof(LNode));//为新插入的节点申请内存空间 s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; return true; } bool InsertBackList(LinkList L,ElemType e) { //L = (LinkList)malloc(sizeof(LNode));//带头结点的链表 while (L-&gt;next != NULL) { L = L-&gt;next; } LNode* q; int x; scanf_s(&quot;%d&quot;, &amp;x); while (x != 9999) { q = (LinkList)malloc(sizeof(LNode)); q-&gt;data = x; L-&gt;next = q; q-&gt;next = NULL; scanf_s(&quot;%d&quot;, &amp;x); } return L; } //无论是中间插入还是删除，找到需要操作节点的前驱节点是关键 //删除第i个位置的节点 bool DeleteList(LinkList L,int i) { //找到要删除元素的前驱结点 LinkList p = GetElem(L, i - 1); LinkList q = p-&gt;next; if (p == NULL) { return false;//要删除的位置不存在 } p-&gt;next = q-&gt;next;//断链 free(q); q = NULL; return true; } void PrintList(LinkList L) { //头结点 L = L-&gt;next; while (L != NULL) { printf(&quot;%d\\t&quot;, L-&gt;data); L = L-&gt;next; } } //查找第几个元素 LinkList LocateElem(LinkList L, ElemType e) { int j = 1; LinkList p = L-&gt;next; while (p != NULL &amp;&amp; p-&gt;data != e) { p = p-&gt;next; j++; } return p; } int main() { //定义链表头,结构体指针类型 LinkList L; LinkList search;//用来存储拿到的某一个节点 LinkList search1; printf(&quot;请在下方输入单链表的值：（^_^大于5个元素且输入9999终止^_^）\\n&quot;); CreatList1(L); printf(&quot;头插法的结果为：&quot;); PrintList(L); search = GetElem(L, 2); if (search != NULL) { printf(&quot;\\n按序号查找成功！~\\n&quot;); printf(&quot;该位置的值为：%3d\\n&quot;, search-&gt;data); } search1 = LocateElem(L, 5); /* if (search1 != NULL) { printf(&quot;\\n按序号查找成功！~\\n&quot;); printf(&quot;该的值为：%3d&quot;, search-&gt;data); } */ InsertFrontList(L, 3, 30); PrintList(L); printf(&quot;\\n-----------\\n&quot;); printf(&quot;删除后的结果为：\\n&quot;); DeleteList(L, 3); PrintList(L); printf(&quot;\\n-----------\\n&quot;); printf(&quot;请在下方输入单链表的值：（^_^大于5个元素且输入9999终止^_^）\\n&quot;); CreatList2(L); printf(&quot;尾插法的结果为：&quot;); PrintList(L); return 0; } 栈 只允许在一端进行插入或者删除的线性表，栈顶（top）。后进先出-&gt;LIFO 两种重要的计算机思维 两种重要的编程思维在日常练习中极其重要，对于计算思维的培养是决定一个程序员能走多远的关键所在。在平时的编程练习时要注重对于两种思维的培养与训练。 递归-逆向思考 分治-化繁为简 对于分治算法的理解水平和应用的得心应手的程度，是衡量一个程序眼计算素养的标尺。这一关无法突破就无法成为一个四级工程师。 对于分治算法理解的三个层次： 了解皮毛，解决一些算法习题 灵活运用计算思维，解决大问题 掌握精髓，解决以前从未解决的问题 分治算法的步骤描述： 将复杂的问题分成若干个简单的子问题进行解决。-&gt;分割 解决每一个子问题，若果子问题很大继续递归分解。-&gt;解决 对子问题的结果进行合并。-&gt;合并 for循环的几种书写方法 下标循环 for(int i = 0;i &lt; nums.size();i++){ //操作 ...... } 如果事先声明了索引下标，则不需要在for循环中进行下标的初始化。 int i = 0; for(;i &lt; nums.size();i++){ //操作 ...... } 死循环形式 for(;;){ //操作 ...... } 迭代器循环 vector&lt;char&gt;myvector(arc,arc+23); vector&lt;char&gt;::iterator iter; //for循环遍历 vector 容器 for (iter = myvector.begin(); iter != myvector.end(); ++iter) { cout &lt;&lt; *iter; } for(auto ite : array) C++ 11 标准中，除沿用前面介绍的用法外，为 for 循环添加了新的语法格式 旧格式的 for 循环可以指定循环的范围 而 C++11 标准增加的 for 循环，只会逐个遍历 expression 参数处指定序列中的每个元素 **for(auto a:b)**中b为一个容器或者数组，效果是利用a遍历并获得b容器中的每一个值，但是a无法影响到b容器中的元素。 **for(auto &amp;a:b)**中加了引用符号，可以对容器中的内容进行赋值，即可通过对a赋值来做到容器b的内容填充。 1、数组 int array[] = {1, 2, 3, 4, 5}; for(auto e : array) cout &lt;&lt; e &lt;&lt; endl; 等价于 for(int i = 0; i &lt; 5; i++) cout &lt;&lt; array[i]&lt;&lt;endl; 2、字符串 string str = &quot;hello world&quot;; for(auto ch : str) cout &lt;&lt; ch &lt;&lt;endl; 等价于 for(int i = 0; i &lt;str.size(); i++) cout &lt;&lt; str[i] &lt;&lt;endl; 3、vector vector&lt;int&gt; m_v = {1, 2, 3, 4}; for(auto e : m_v) cout &lt;&lt; e &lt;&lt;endl; 等价于 for(int i = 0; i &lt; m_v.size(); i++) cout &lt;&lt;v[i]&lt;&lt;endl; 4、map map&lt;int,string&gt; m = {{1, &quot;abc&quot;}, {2, &quot;bca&quot;}, {3, &quot;cab&quot;}}; for(auto e : m) cout &lt;&lt;e.first&lt;&lt;&quot; &quot;&lt;&lt; e.second&lt;&lt;endl; 等价于 for(map&lt;int, string&gt;::iterator it = m.begin();it != m.end(); it++) cout &lt;&lt;it-&gt;first&lt;&lt;&quot; &quot;&lt;&lt;it-&gt;second&lt;&lt;endl; ———————————————— 版权声明：本文为CSDN博主「A阿哲」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/zhanghaizhe/article/details/103460084 基本的语法 最近写c++代码是收到了一个疑惑？就是语句中带有？（问号）是语句理解不好 其实语句中带有问号的c++语句，是if-else if-else的简便方式 该操作符是三元的，其一般形式为： EXP1? EXP2: EXP3 EXP1，EXP2和EXP3是表达式，注意冒号的用法和位置。 这个写法和Python中的匿名函数相似。 给Python的匿名函数举一个例子: lambda x : x*2 C++匿名函数 所谓匿名函数，其实类似于python中的lambda函数，其实就是没有名字的函数。使用匿名函数，可以免去函数的声明和定义。这样匿名函数仅在调用函数的时候才会创建函数对象，而调用结束后立即释放，所以匿名函数比非匿名函数更节省空间。 数据类型 1、预定义类型 整型 c++有四种整型类型：short、int、long、long long，每种都有signed(有符号，默认)、unsigned(无符号)两种分类，有符号整数既可以表示非负整数，又可以表示负整数；但是，无符号整数不能表示负数，只能表示非负整数。 ● short至少16位 ● int至少与short一样长 ● long至少32位，且至少与int一样长 ● long long至少64位，且至少与long一样长 字符型 类型 含义 该类型数据所占的最小比特位数 char 字符 8位（即可表示28个字符） wchar_t 宽字符 16位 char16_t Unicode字符 16位 char32_t Unicode字符 32位 布尔型 布尔类型(bool)是C++新增的一种基本数据类型，就是将int型定义为bool型，将int型的0和1两个值分别定义为bool类型的两个值true和false。 浮点型 类型 说明 double 64位双精度浮点型 float 32位单精度浮点型 空类型 关键字void定义的类型，不能用于普通变量的声明和普通的操作，只能用于指针型变量，函数返回值和函数参数。 指针类型 指针，用来描述内存地址，并通过提供指针操作来实现与内存相关的程序功能。&lt;类型&gt;* &lt;指针变量&gt;; 其中&lt;类型&gt;决定了指向的内存空间的大小。 指针变量也是一种变量，有着自己的内存空间，该空间上存储的是另一个变量的内存空间。 2、自定义数据类型 数组类型 数组类型是一种有固定多个同类型的元素按一定次序所构成的数据类型。 2.1、一维数组类型 int dp[5] 2.2、二维数组类型 int dp[2] [3] 结构体数据类型 1、结构体 结构体是由一系列具有相同类型或者不同类型的数据构成的数据集合。 struct 名称{ 数据类型 变量名1； 数据类型 变量名2； .... 数据类型 变量名n； }结构体变量名; 结构体数组: struct Info{ int age; char name[32]; }info[SIZE]; 枚举类型 枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓&quot;枚举&quot;是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。 enum 枚举名{ 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数] } 枚举变量; 函数 定义函数 在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分： **返回类型：**一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。 **函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。 **参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。 **函数主体：**函数主体包含一组定义函数执行任务的语句。 一个函数就是一个功能，一般把一个大型程序划分为若干个程序模块。无论把函数分为多少个程序模块，其中只能有一个main函数，程序总是从main函数开始执行的。c++继承了c语言中面向函数的语言特性，在其之上又加入了面向对象的函数设计思想。学会设计并使用函数。 主函数写的很简单，它的作用就是调用各个子函数，程序的各部分功能是由各个子函数组合实现的，主函数相当于总调度。 函数分类 （1）系统函数，即库函数 由编译系统提供的函数，可以直接通过头文件调用；这就是为什么在调用函数时必须在程序最前面添加#include&lt;&gt;的原因。 （2）用户自定义的函数 （1无参函数 调用时不必给出参数 （2有参函数 在调用函数时要给出必要的参数。 类型名 函数名（形式参数列表） { **声明部分;** **执行语句;** } 函数参数 如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。在定义函数时，函数名后面括号中的变量名称为形式参数；在主函数中调用函数时，函数名后面括号中的参数为实际参数。 形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。 调用类型 描述 传值调用 该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 指针调用 该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 引用调用 该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数 函数返回值 通过函数的调用使得主函数得到一个确定的函数值，这就是函数的返回值。 调用函数与递归调用 创建 C++ 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。 当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。 在调用一个函数过程中又出现直接或者间接调用函数本身，称为函数递归调用。 指针参数调用 要想改变主调函数中的值，必须传入函数的地址，而且必须通过*+地址去赋值，无论在这个变量时什么类型的。 void f(int *p){ //被调用的时候得到了某个变量的地址 } int main(){ int i = 0; f(&amp;i); //传递地址类型的参数 } 在函数里面可以通过这个指针访问外面这个i 注：在传递数组长度sizeof时，必须在main函数中传递。如果利用指针传递参数，那么子函数中返回的sizeof返回的是int*a的长度而不是int a[ ]的长度； int *a是首地址即 a[0]的sizeof。 Lambda 函数与表达式 C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。 Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。 C++ 数学运算 在 C++ 中，除了可以创建各种函数，还包含了各种有用的函数供您使用。这些函数写在标准 C 和 C++ 库中，叫做内置函数。您可以在程序中引用这些函数。 C++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数。 为了利用这些函数，您需要引用数学头文件 。 序号 函数 &amp; 描述 1 double cos(double); 该函数返回弧度角（double 型）的余弦。 2 double sin(double); 该函数返回弧度角（double 型）的正弦。 3 double tan(double); 该函数返回弧度角（double 型）的正切。 4 double log(double); 该函数返回参数的自然对数。 5 double pow(double, double); 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。 6 double hypot(double, double); 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。 7 double sqrt(double); 该函数返回参数的平方根。 8 int abs(int); 该函数返回整数的绝对值。 9 double fabs(double); 该函数返回任意一个浮点数的绝对值。 10 double floor(double); 该函数返回一个小于或等于传入参数的最大整数。 C++中直接调用的函数 1、sqrt(x) 取x的平方根。 2、pow(x,y) 值为x的y次方。 3、abs(x) 取整数的绝对值。 fabs(x) 求精度更高的double、float型的绝对值。 4、floor(x) 返回一个小于或等于x的最大整数。 5、setw(x) 空x个空格。 6、strcpy(s1,s2) 复制字符串s2到字符串s1。 7、strlen(s1) 返回字符串s1的长度。 8、strcat(s1,s2) 连接字符串 s2 到字符串 s1 的末尾。 9、strchr(s1,ch) 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 10、strstr(s1,s2) 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 11、strcmp(s1,s2) 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回值小于 0；如果 s1&gt;s2 则返回值大于 0。 原文链接：https://blog.csdn.net/qq_55196230/article/details/122525491 常用的字符串函数 指针 指针类型可以有函数类型、对象类型或者不完全类型派生出来，派生指针类型的类型称为被引用类型。指针类型描述了一种对象，其值用于引用被引用类型的实体。 这是C11中给出指针类型的标准定义，读起来拗口难懂！ 那么，根据第一性原理，从简单处入手——类型。 提到类型，立刻会让人想起int类型、doule类型等，同样的，指针也是一种类型，但是指针类型并不是独立存在的，而是由其他类型派生出来的。由被引用类型T派生出的指针类型称为“指向T的指针”。指针类型是类型，所以也存在“指针类型的变量”和“指针类型的值”。但是糟糕的事，大多数人对指针类型、指针类型的值、指针类型的变量混为一谈，笼统地认为他们都是“指针”，所以对于基本的概念理解要提高警惕。 现有的指针类型，因为有了指针类型，所以才有指针类型的变量和指针类型的值。 例如在C语言中，int类型用来表示整数。因为int是“类型”，所以存在用于保存int类型的变量，当然也存在int类型的值。指针类型也是如此，既存在指针类型的变量，也存在指针类型的值。指针类型的值实际上就是内存的地址。 什么是指针？ 指针是一个变量，其值为某一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。 type *var-name; 在这里，type 是指针的基类型，它必须是一个有效的 C++ 数据类型，var-name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明： int *ip; /* 一个整型的指针 */ double *dp; /* 一个 double 型的指针 */ float *fp; /* 一个浮点型的指针 */ char *ch; /* 一个字符型的指针 */ 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。 &amp;与*区别使用方式：* p是一个值；p是一个地址；两者完全不相同。代表着p指向的地址的值，简单来说就是取值；&amp;是取地址符号，取的是地址；p是指针，可以理解为所指向的值的地址，* p就是取p指针指向的地址的值，&amp;a就是取a的地址。 &amp;是取地址符号，其返回的是一个变量的地址；而*是一个单目运算符，用来访问指针的值所表示的地址上的变量，其返回的是根据地址所对应的数值；我们也俗称叫做“解引用”，可以作为左值使用。 指针的运算符&amp;与*起到互作用： int xptr = &amp;x； *xptr = x； *&amp;xptr -&gt; *(&amp;xptr) -&gt; *(xptr的地址) -&gt; 得到那个地址上的变量 -&gt; xptr &amp;*xptr -&gt; &amp;( *xptr) -&gt; &amp;(x) -&gt; 得到x的地址，也就是xptr -&gt; xptr [百度百科]单目运算是指运算符包括算术运算符、逻辑运算符、位逻辑运算符、位移运算符、关系运算符、自增自减运算符。-&gt;只需要一个变量参与即可完成相应的计算过程。 [翁恺]左值之所以叫左值，是因为出现在赋值号左边的不是一个变量而是一个值(或者是表达式的结果)，是一个特殊的值，所以叫左值。a[0] = 2、*p = 3. int a = 5;//变量的声明与定义 int *p = a;//指针变量的声明与定义 32位架构之下scanf(&quot;%d&quot;,i)；不会报错-&gt;因为整数和地址是一样大的 对于这个*而言，它可以靠近变量本身也可以靠近关键字，本身没有实际的区别 -&gt;变量的值是内存的地址；普通变量的值是实际的值；指针变量的值是具有实际值的变量的地址。 在当使用*+变量名作为参数是，其定义的类型为指针类型，所以在传入参数时，务必传入变量的地址，而不是单纯的传入一个变量名。只有主调函数参数传入地址，被调函数才能根据定义的指针类型参数去复用地址，从而达到了改变主调函数中的值的操作。 void swap(int *a,int *b){ int temp = *a; *a = *b; *b = temp; } 以上面的交换函数为例，调用swap函数时，必须传入的是两个地址(&amp;+变量名)；这是主调函数int *a,int *b才能根据传入的地址去解析地址所对应的数值。在内存中(无论是在堆空间还是栈空间)存放好的变量是不怕被覆盖的，换言之，他们是随时做好准备而去被覆盖的。 这也是值传递和地址传递的区别。主调函数发生值传递后，传入的参数会在被调函数中的栈区中自己开辟新的空间存放传进来的参数值。这也是所谓的C语言的特性之一：单向值传递。而主调函数传入地址后，被调函数拿到传入的地址即解析，到堆区主调函数中(这里说的不严谨，因为当主调函数与被调函数都定义在栈区时，参数的传递也只在栈区中传递)去改变主调函数中参数的值。理解堆区和栈区是参数传递过程的中的重点问题。 应用场景： 函数返回多个值的时候：swap交换函数、寻找min与max函数 and so on… 函数返回运算的状态可能会用到指针进行返回。让函数返回某些特殊的不属于有效范围内的值表示出错。 int divide(int a,int b,int *res){ int ret = 1; if(b == 0) ret = 0; else{ *result = a/b; } return ret; } int main(){ int a = 2; int b = 10; int c; if(divide(a,b,&amp;c)){ printf(&quot;%d%d%d&quot;,a,b,c); } } 初学者使用指针的常见错误： 定义了指针变量，但是还没有开始指向任何变量，就开始使用指针。-&gt;野指针的产生 C99标准下const与指针： -&gt;指针的const表示一旦得到了某个变量的地址，不能在指向其他的变量。指针不能被修改 int *const q = &amp;i;//q是const *q = 26;//OK q++；//ERROR -&gt;const所指的int表示不能通过有这个指针去修改所指向的变量。所指的东西不能被修改 const int *p = &amp;i; *p = 26;//ERROR i = 26;//OK p = &amp;j;//OK 数组指针 数组参数的等价： int sum(int *a,int n); int sum(int *,int n); int sum(int a[ ],int n); int sum(int [ ],int n); 数组与指针几点特性： 数组变量是特殊的指针，数组本身就是表达地址。 []可以对数组做，也可以对指针做。 *可以对数组做，也可以对指针做。 数组变量是const指针，所以不能被赋值。 其实数组在传入到子函数时，本质上就是传入子函数的首地址。 指针函数参数，具备输入输出特性： main函数： int main(){ test01(); test02(); test03(); return 0; } 输入特性：主调函数分配内存，被调函数中使用内存 //栈区内存分配 void func(char *c){ strcpy(c,&quot;helloworld!&quot;); } void test02(){ char buf[100] = {0}; func(buf); printf(&quot;%s\\n&quot;,buf); } //堆区内存分配 void PrintString(char *str){ printf(&quot;%s\\n&quot;,str); } void test01(){ //堆区内存分配 char *p = malloc(sizeof(char)*64); memset(p,0,64); strcpy(p,&quot;helloworld!&quot;); PrintString(p); } 输出特性：被调函数分配内存，主调函数中使用内存 //输出特性：被调函数创建内存，主调函数使用内存 void allocateSpace(char **pp){ char *temp = malloc(sizeof(char)*64); memset(temp,0,64); strcpy(temp,&quot;helloworld!&quot;); *pp = temp; } void test03(){ char *p = NULL; allocateSpace(&amp;p); printf(&quot;%s\\n&quot;,p); } 数组指针与指针数组 数组指针：是指一个指向数组的指针，它其实还是一个指针，只不过是指向数组而已 int (*p)[10] 指针数组：是指一个数组里面装着指针，也即指针数组是一个数组 int *a[10] 指针数组的使用： #include &lt;stdio.h&gt; int main(){ int a = 16, b = 932, c = 100; //定义一个指针数组 int *arr[3] = {&amp;a, &amp;b, &amp;c};//也可以不指定长度，直接写作 int *arr[] //parr 是指向数组 arr 的指针，确切地说是指向 arr 第 0 个元素的指针， //它的定义形式应该理解为int *(*parr)，括号中的*表示 parr 是一个指针，括号外面的int *表示 parr 指向的数据的类型。 //arr 第 0 个元素的类型为 int *，所以在定义 parr 时要加两个 *。 int **parr = arr; printf(&quot;%d, %d, %d\\n&quot;, *arr[0], *arr[1], *arr[2]);//16, 932, 100 printf(&quot;%d, %d, %d\\n&quot;, **(parr+0), **(parr+1), **(parr+2));//16, 932, 100 return 0; } #include &lt;stdio.h&gt; int main(){ char *str[3] = { &quot;c.biancheng.net&quot;, &quot;C语言中文网&quot;, &quot;C Language&quot; }; printf(&quot;%s\\n%s\\n%s\\n&quot;, str[0], str[1], str[2]); /* 运行结果： c.biancheng.net C语言中文网 C Language */ return 0; } 数组指针的使用： #include&lt;stdio.h&gt; int main(void) { char a[5]={'A','K','C','G','L'}; char (*p)[5]=&amp;a;//&amp;a代表的是整个数组的首地址 //char (*p)[5]=a;这样是错误的，因为a代表第一个元素的首地址 printf(&quot;%c %c %c&quot;,**p,*(*p+1),*(*p+3));//输出：A K G return 0; } 结构体指针 **-&gt;**前是指针，而 . 前是结构体变量 .用于类的实例，而-&gt;用于类的指针 .：成员访问表达式指定由其左操作数指定的结构或联合的命名成员，它具有与左操作数相同的值类别。 -&gt;：通过指针表达式的成员访问指定由其左操作数指向的结构或联合类型的命名成员。它的值l类别始终是左值。 简单点说就是： A-&gt;a表示A是指向结构体的指针 A.a表示A是结构体 A-&gt;a等效于(*A).a -&gt;比如C++中一个类Class Student;里面有个公有成员变量test 如果你声明这个类的对象Student s;那么你要对test操作要用&quot;.&quot; s.test 如果你声明这个类的对象Student *s为指针类型的话，那么你要对test操作要用&quot;-&gt;&quot; s-&gt;test 结构体指针的等价性： int *p = &amp;结构体变量； 结构体变量名.成员名 (*p).成员名 p-&gt;成员名 函数指针 内存中每个指令都顺序存放的，每个指令都有一个与其相对应的地址；而函数反应到内存中就是一大块指令的集合。 #include&lt;stdio.h&gt; int Add(int a,int b){ return a + b; } int main(){ int c; int (*p)(int ,int); p = &amp;Add; c = (*p)(2,3); ------------------ p = Add; c = p(2,3); ------------------ printf(&quot;%d&quot;,c); return 0; //程序得到的结果为5 } 水煮易混指针 int *a[5] 这是一个指针数组，每一个元素都是一个int *指针变量,指向int类型的地址。指向 *a[5]时应该使用二级指针而不是一级指针。 int (*a)[5] 这是一个数组指针，它是一个指针变量，占有8个字节存地址编号，它指向一个数组，二维数组加一偏移后指向下一行，也可以将&amp;+一维数组赋值给它。 int **p 这是一个指针的指针，存放的是保存指针的地址。 int *f(void) 它是一个函数的声明，返回的是一个函数的地址-&gt;int *类型。 int (*f)(void) f是个函数的指针变量，存放函数的地址，它指向的函数必须有一个int类型的返回值，没有参数。 结构体 结构体的作用：把一些相关的变量组合起来，以一个整体形式对对象进行描述 【注】: 只有结构体变量才分配地址，而结构体的定义是不分配空间的 结构体中各成员的定义和之前的变量定义一样，但在定义时也不分配空间 结构体变量的声明需要在主函数之上或者主函数中声明，如果在主函数之下则会报错 c语言中的结构体不能直接进行强制转换，只有结构体指针才能进行强制转换 相同类型的成员是可以定义在同一类型下 定义结构体变量以后，系统就会为其分配内存单元。 在对结构体变量初始化时，要对结构体成员一一赋值，不能跳过前面成员变量，而直接给后面成员赋初值。 用结构体指针变量访问结构体变量成员有以下两种方式： (*p).属性 //这里的括号不能少 p-&gt;属性 全局变量与宏 全局变量 定义在函数的外部的变量称为全局变量，全局变量具有全局的生存期和作用域。他们与任何函数都无关，任何函数都可以调用。没有初始化的全局变量会被赋予0值，指针会得到NULL值，他们的初始化在main函数之前。全局变量禁止套娃 int gall = 12; void f(){ gall += 2; printf(&quot;value in f is %d&quot;,gall); } int main(){ f(); printf(&quot;value in main is %d&quot;,gall); } 静态全局变量 在本地变量定义时前面加上static就变成了静态本地变量。函数离开时，静态本地变量会保持其原来的值，静态本地变量的初始化只会在第一次进入这个函数时做，以后进入函数会保持和上次离开时的值。 #include&lt;stdio.h&gt; int gall = 12; //int gall = 12; void f(){ int all1 = 2;//不加static为本地变量 static int all2 = 2; //加static //遵守的原则：以后进入函数会保持上次离开时的值 printf(&quot;value in f is %d&quot;,all); all += 2; printf(&quot;value in f is %d&quot;,all); } int main(){ f(); f(); f(); } 实际上在内存中：gall地址0x3800c，all2地址0x38010两者是紧挨着的，而静态本地变量与本地变量all1区相隔十万八千里。 静态本地变量实际上是特殊的全局变量，他们位于相同的内存区域。静态本地变量具有全局的生存区，函数内局部作用域。全局生存期，本地作用域。 指针作为返回值返回本地变量是危险的，返回全局变量或者静态本地变量是安全的，最好的做法是返回指针。 小贴士： 不要使用全局变量来作为函数之间的参数传递的结果 尽量避免使用全局变量 *使用全局变量和静态本地变量时函数的线程是不去安全的 编译预处理与宏 #include: #开有就是编译预处理指令，他们不是C语言的指令，但是他们不可或缺。#define来定义一个宏。 #define 宏：#define PI 3.14；因为不是C语言的语句所以结尾没必要加分号！名字必须是一个单词，值可以是任何东西。宏也可以带着参数，形成函数的宏。 #define cube(x) (x * x * x) 一切都要有括号，整个值都要有括号 #define MIN(a,b) ((a&gt;b)?(b):(a)) #ifndef的用法 #ifndef &lt;标识&gt; #define &lt;标识&gt; ...... ...... #endif #ifndef起到的效果是防止一个源文件(.cpp)两次包含同一个头文件(.h)，而不是防止两个源文件包含同一个头文件。它是if not define 的简写，是宏定义的一种，实际上确切的说，这应该是预处理功能三种（宏定义、文件包含、条件编译）中的一种——条件编译。 &lt;标识&gt;在理论上来说可以是自由命名的，但每个头文件的这个“标识”都应该是唯一的。标识的命名规则一般是头文件名全大写，前后加下划线，并把文件名中的“.”也变成下划线，如：stdio.h #ifndef STDIO_H #define STDIO_H ...... #endif 使用#ifndef可以避免下面这种错误：如果在h文件中定义了全局变量，一个c文件包含同一个h文件多次，如果不加#ifndef宏定义，会出现变量重复定义的错误；如果加了#ifndef，则不会出现这种错误。 条件指示符#ifndef 的最主要目的是防止头文件的重复包含和编译。 const关键字 关键字const用来定义常量，如果一个变量被const修饰，那么它的值就不能再被改变。与前面的#define(预编译指令)相比，const具有如下的优点： 预编译指令只是对值进行简单的替换，不能进行类型检查 可以保护被修饰的东西，防止意外修改，增强程序的健壮性 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高 需要注意的是，用const修饰变量时，一定要给变量初始化，否则之后就不能再进行赋值了。 使用const修饰变量后，可以高枕无忧的进行函数的参数传递，但是不可以 C++的引用 准确来说就是给变量起别名；准确来说实际的作用和指针类似。-&gt;共同操纵内存 int a = 10;//栈区存放内存地址 int &amp;b = a; cout &lt;&lt; &quot;a =&quot;&lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b =&quot;&lt;&lt; b &lt;&lt; endl; b = 20; cout &lt;&lt; &quot;a =&quot;&lt;&lt; a &lt;&lt; endl; cout &lt;&lt; &quot;b =&quot;&lt;&lt; b &lt;&lt; endl; 引用必须初始化，必须开始的时候就要初始化。int &amp;b是错误的；int &amp;b = 一个变量名; 引用一旦初始化后，就不可以更改了。 引用作为函数的参数 作用：函数传参时，可以利用引用技术让形参修饰实参。 优点:可以简化指针修改实参。 //交换函数三种方法实现 //值传递 void swap(int a,int b){ int temp = a; a = b; b =temp; } //地址传递 void swap(int *a,int *b){ int temp = *a; *a = *b; *b =temp; } swap(&amp;a,&amp;b); //引用传递 void swap(int &amp;a,int &amp;b){ int temp = *a; *a = *b; *b =temp; } swap(a,b);//本质上a就是上面子函数中形参的别名 通过引用参数产生的效果和使用指针的产生的效果是一样的，引用的语法更加简介清晰。 引用作为函数的返回值 不要返回局部变量的引用 int&amp; func(){ int a = 1; return a; } int main(){ int &amp;ref = func(); cout &lt;&lt; &quot;ref=&quot; &lt;&lt; ref &lt;&lt;endl;//第一次打ref的值是1，因为编译器做了保留 cout &lt;&lt; &quot;ref=&quot; &lt;&lt; ref &lt;&lt;endl;//第二次打是个乱码、错误值，因为局部变量释放 } 函数的调用可以作为左值 int&amp; func(){ static int a = 1; return a; } int main(){ int &amp;ref = func(); cout &lt;&lt; &quot;ref=&quot; &lt;&lt; ref &lt;&lt;endl; cout &lt;&lt; &quot;ref=&quot; &lt;&lt; ref &lt;&lt;endl;//结果都是1 func() = 200; cout &lt;&lt; &quot;ref=&quot; &lt;&lt; ref &lt;&lt;endl; cout &lt;&lt; &quot;ref=&quot; &lt;&lt; ref &lt;&lt;endl;//结果都是200 } void test(){ static int a = 10; return a; } int &amp;ref = test(); cout &lt;&lt; &quot;ref =&quot;&lt;&lt;ref &lt;&lt; endl; cout &lt;&lt; &quot;ref =&quot;&lt;&lt;ref &lt;&lt; endl; test() = 1000;//函数的调用可以作为左值 cout &lt;&lt; &quot;ref =&quot;&lt;&lt;ref &lt;&lt; endl; cout &lt;&lt; &quot;ref =&quot;&lt;&lt;ref &lt;&lt; endl; 引用的本质 引用的本质在C++中内部的实现就是一个指针常量。引用一旦初始化，就不可以进行更改。 C++推荐使用引用技术，因为语法方便，所有的指针操作编译器都帮我们做好了。 //编译器发现是引用的话，转化为 int* const ref = &amp;a; void func(int &amp;ref){ int ref = 100; } int main(){ //自动转换为 int* const ref = &amp;a;指针常量是指针指向不可以改变，也说明了为什么引用不可以更改。 int &amp;ref = a; ref = 20;//内部发现ref是引用以后，自动帮我们转换为：*ref = 20； cout &lt;&lt; &quot;a&quot; &lt;&lt; a &lt;&lt;endl; cout &lt;&lt; &quot;ref&quot; &lt;&lt; ref &lt;&lt;endl; func(a); return 0; } 修饰形参放置 void PrintValue(const int &amp;x){ x = &quot;新值&quot;;//加上const以后，这句话就会报错 cout &lt;&lt; &quot;val = &quot; &lt;&lt; endl; } //对于常量的引用 int main(){ int a = 10; int &amp;ref = a; //以上内容是合法的，但是如果左值赋给了一个新的数值就会引起非法操作 ref = 20;//这样操作是非法的，20下面会加上红色波浪线报错提示。 //加上const之后，编译器将代码修改为 int temp = 20 const int &amp;ref = temp; const int &amp;ref = 20; int x = 10; PrintValue(x);//为了避免在子函数中对实参进行修改，可以在形参前面加上const关键字 cout &lt;&lt; &quot;val = &quot; &lt;&lt; endl; } 动态内存分配 程序运行过程中，需要根据自身大小自由分配空间 按需分配 分配在堆区，一般使用特定的函数进行分配 -&gt;free函数释放p指针指向的内存。内存大小有限，好借好还、再借不难。 free(p); malloc函数无法避免内存的碎片化。 malloc #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; void *malloc(int size){ }//在堆区中分配一块长度为size的连续内存块，用来存放内存说明符号指定的数据类型，函数返回 void *指针 int main(){ int *p = (int *)malloc(size);//(int *)注意强转 } 返回值： 分配内存空间的起始地址(分配成功) NULL(分配失败) calloc 在内存堆中，申请n块，每块sizeof(指定数据类型)个字节的字节的连续区域。 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; void *calloc(int size){ }//在堆区中分配一块长度为size的连续内存块，用来存放内存说明符号指定的数据类型，函数返回 void *指针 int main(){ //本质上就是一个二维的数组指针 datatype *p = (datatype *)calloc(n,sizeof(datatype));//(datatype *)注意强转 } memset函数 void *memset(void *ptr,int value,size_t num); //memset函数是将ptr指针指向的内存空间的num个字节全部赋值为value； int *str = (int *)malloc(sizeof(int)*100); if(!str) return; memset(str,0,100); for(int i = 0;i &lt; sizeof(str)/sizeif(int);i++){ printf(&quot;%d\\t&quot;,str[i]); } 文件操作 初识文件 文件是用来存放程序、文档、音频、视频数据、图片等数据。文件是存放在磁盘上的数据集合。 **磁盘文件：**一组相关数据的集合，通常存放在外部介质上，使用时才调入内存 **设备文件：**在OS中把每一个与主机相连的输入、输出设备看做一个文件，把他们的输入、输出等同于磁盘文件的读和写。 键盘：标准输入文件 屏幕：标准输出文件 C语言中文件的操作： FILE *fopen(const char *filename, const char *mode); 返回值： fopen函数返回新打开文件的文件指针； 如果此文件不能打开，则返回NULL指针。 &quot;r&quot; 打开文件仅供读取 必须存在 &quot;w&quot; 创建新文件仅供写入 若存在，则清空后再写入 &quot;a&quot; 打开文件附加写入 若不存在，则创建新文件写入 &quot;r+&quot; 打开文件供读取并写入 必须存在 &quot;w+&quot; 创建新文件供读取并写入 若存在，则清空后再写入 &quot;a&quot; 打开文件读取并附加写入 若不存在，则创建新文件写入 FILE* fp = fopen('file','r'); if(fp){ fscanf(fp,...); fclose(fp); } else{ } 编码、运算与变量 数据存储量的量级增长： 1字节1KB=8比特bits 1兆字节1MB=1024KB 1吉字节1GB=1024MB 1太字节1TB=1024GB 千万亿字节1PB拍字节 = 1024TB 百亿亿字节1EB艾字节 = 1024PB 十万亿亿字节1ZB泽字节 = 1024EB 一亿亿亿字节1YB尧字节 = 1024ZB 一千亿亿亿字节1BB = 1024YB 补码的作用 组成原理要考！ 计算机的CPU无法进行减法运算，只能做加法运算。CPU有一个逻辑单元交加法器，只能进行加法操作。CPU中包含三部分：加法器、移位器、译码器。对于减法操作：2-5-&gt;2+(-5)的操作。由于计算机只能存储0和1，编写程序来看-5是如何存储的。 在数据的存储中，有两种存储形式，*大端存储和小端存储。*所有的数据都是在内存当中存的，而内存当中的基本单位是字节数据访存的基本单位是字节的话，那么一个整形变量（int）就有四个字节，那么就意味着数据在存储过程中会被划分为四块。数据按照字节序为单位，也有高权值位，低权值位之别的。按空间来划分的话，有高地址，低地址之分。 两种存储方案： 大端：按照字节位单位，低权值位数据存储在高地址处，就叫做大端； 小端：按照字节位单位，低权值位数据存储在低地址处，就叫做小端。 我们以 int a = -10 为例： （因为int类型占有四个字节，而一个字节等于8个bite位） （说明:数据在内存中是以补码的形式存储的） 所以将其转化为二进制原码为: 10000000 00000000 00000000 00001010 反码(符号位不变，其他位按位取反): 11111111 11111111 11111111 11110101 补码（反码+1）： 11111111 11111111 11111111 11110110 转化为十六进制为: ＦＦ ＦＦ ＦＦ Ｆ６ 大端存储： 低地址-&gt;高地址：ＦＦ ＦＦ ＦＦ Ｆ６ 小段存储： 高地址-&gt;低地址：Ｆ６ ＦＦ ＦＦ ＦＦ 5 0000 0101-&gt;一个字节 原码 -5 取反后加1：1111 1010-&gt;1111 1011 用补码来表示负数 对于有符号数而言，最高位为1表示负数，最高位为0表示正数。最高位为1则自然表示该数据的补码，加1取反则得到相反数 反码的作用 反码是计算机中一种机器码的表示。对于单个数值(二进制的0和1)而言，对其进行反操作就是将0变成1，将1变成0。正数的反码和原码一致，负数的反码就是在其原码的基础之上，符号位不变的情况下，其他位置取反。 反码是历史遗留的残物。作用就是解决对于负数补码的求值。 负数的补码=负数的原码-&gt;负数的反码-&gt;反码加1 int数值型 括号可以缺省，无符号只能存储非负数。 整型变量的类型： 有符号基本整型：(signed)int 有符号短整型：(signed)short(int) 有符号长整型：(signed)long(int) 无符号基本整型：unsigned int 无符号短整型：unsigned short(int) 无符号长整型：unsigned long(int) 数据类型 字节数 范围 (signed)int 4 −231-2^{31}−231~231−12^{31}-1231−1 (signed)short(int) 2 −215-2^{15}−215~215−12^{15}-1215−1 (signed)long(int) 4 −231-2^{31}−231~231−12^{31}-1231−1 或 −263-2^{63}−263~263−12^{63}-1263−1 unsigned int 4 000~232−12^{32}-1232−1 unsigned short(int) 2 0-65535 unsigned long(int) 4 000~232−12^{32}-1232−1 或 000~264−12^{64}-1264−1 Linux OS下long类型占有8个字节 为啥符号位的字节数要比符号位少一次幂呢？因为符号位 最小的负数是： 1000 0000 0000 0000 0000 0000 0000 0000 而不是： 1111 1111 1111 1111 1111 1111 1111 1111 避免溢出现象的发生： 掌握字符型数值的取值范围！ 浮点型数据 在C语言中，浮点型数据用double和float表示。float占用4个字节，double占用8个字节。与整数形式不同，浮点数存储是按照指数形式存储的。系统会把一个浮点数分成小数部分M和指数部分E，分别存放。 0/1表示符号位，指数部分有8位，小数部分有23位。 浮点数的取值范围要看指数部分的取值：指数部分有效位数是8位，所以范围就是2−127到1282^{-127到128}2−127到128,求得的结果用科学计数法表示就是下面float的范围。有效部分是小数部分，23位就是2的23次方=8388608不能表示到9999999. 数据类型 位数 范围 有效位数 float 32 10−3710^{-37}10−37~^10{38}-1$ 6-7 double 64 10−30710^{-307}10−307~^10{308}-1$ 15-16 long double 128 10−493110^{-4931}10−4931~104932−110^{4932}-1104932−1 18-19 IEEE-754标准: 0x:40 90 00 00: 0o:0 100 0000 1001 0000 0000 0000 0000 0000 字符串常量 转义字符： \\n 换行 \\t 横向跳格 \\r 回车 \\ \\ 反斜杠 \\b 退格 \\0 空字符用于标识字符串的结尾，不是空格，无法打印 位运算 &lt;&lt;:左移 &gt;&gt;:右移 ~: 按位取反 |: 按位或 ^: 按位异或 &amp;: 按位与 一个变量左移与右移之后类似于++或者—–其本身很不会发生改变，除非对其自身进行赋值。 **左移：**丢弃高位，低位以0补充，相当于乘以2.申请内存是需要用到左移。例如要申请一个G的内存，可以使用malloc(1&lt;&lt;20)。 **右移：**低位丢弃，正数高位补0，负数高位补1，相当于除以2。移位对于乘除法来说效率要高，负数右移对偶数来说是除以2，但是对于技术来说是先减1后除以2.-无符号数右移时的高位补1. **异或：**相同的数字进行异或是结果为0；任何数字和0异或的结果时其本身。数字位相同为0，相异为1。 **按位取反：**数位上的0变成1,1变成0。正数按位取反的结果是其相反数-1. **按位与和按位或：**用两个数字的每一维进行与和或。与是前者，或是后者。 &amp; 与：全1则1，有0则0 | 或：全0为0，有1则1 ~ 非：按未取反 ^ 异或：相同为0，不同为1 &gt;&gt; 右移 &lt;&lt; 左移 两个数取异或后得到的结果再分别与自身取异或，便可以得到两个数交换的结果。 C++ 基本的输入输出 C++ 标准库提供了一组丰富的输入/输出功能，我们将在后续的章节进行介绍。本章将讨论 C++ 编程中最基本和最常见的 I/O 操作。 C++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。 I/O 库头文件 下列的头文件在 C++ 编程中很重要。 头文件 函数和描述 该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。&lt;&lt; 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。 流插入运算符 &lt;&lt; 在一个语句中可以多次使用，如上面实例中所示，endl 用于在行末添加一个换行符。 using namespace std的意思是使用命名空间 std。C++标准库中的类和函数是在命名空间 std中声明的，因此程序中如果需要用到 C++标准库，（此时就需要用 #include命令行）用using namespace std作声明，表示要用到命名空间 std中的内容。 如果程序有输入或输出时，必须使用#include 命令以提供必要的信息，同时要用using namespace std; 使程序能够使用这些信息，否则程序编译时将出错。 cin&gt;&gt;输入流&gt;&gt;endl； cin&gt;&gt;变量1&gt;&gt;变量2&gt;&gt;变量3&gt;&gt;变量n&gt;&gt;endl； cout&lt;&lt;输出流&lt;&lt;endl; cout&lt;&lt;表达式1&lt;&lt;表达式2&lt;&lt;表达式3&lt;&lt;表达式n&lt;&lt;endl； 在定义流对象时，系统会在内存中开辟一段缓冲区，用来暂存输入输出流的数据。先把插入的数据顺序存放输出缓冲区中，直到输出缓冲区满或遇到 cout语句中的 endl；此时将缓冲区中已有的数据一起输出，并清空缓冲区。输出流中的数据在系统默认的设备( 一般为显示器) 输出。 不能用 cin语句把空格字符和回车换行符作为字符输入给字符变量，它们将被跳过。如果想将空格字符或回车换行符(或任何其他键盘上的字符)输入给字符变量，用getchar函数。在组织输入流数据时，要仔细分析 cin语句中变量的类型，按照相应的格式输入，否则容易出错。 C++还保留了C语言中用于输入和输出单个字符的函数，使用很方便。其中最常用的有 getchar函数和putchar函数。在C 语言中是用 printf函数进行输出，用 scanf函数进行输入的。 C++保留了C语言的这一用法。 常用I/O流控制符 描述 dec 转换整数的基数为十进制 oct 转换整数的基数为八进制 hex 转换整数的基数为十六进制 showbase 在输出中显示基数指示符 uppercase 十六进制输出时一律用大写字母 scientific 科学计数法显示浮点数 fixed 定点小数形式显示浮点数 showpoint 把带有小数点的浮点数值输入到流中 showpos 正整数前带有&quot;+&quot;号 unitbuf 输出操作后立即刷新流 left 输出数据在本域宽范围内左对齐 right 输出数据在本域宽范围内右对齐 版权声明：本文为CSDN博主「亲亲Friends」的原创文章 在C++下，若要使用C中已有库中的函数如stdio，文件包含方式为前面加一个c，同时去掉.h后缀，如#include &lt; cstdio &gt;，同时必须加上using namaspace;对于其他类似的函数同样 对于C++特有的库，直接用去掉.h后缀的文件包含，并加上using namaspace &quot;.h&quot;头文件将所有名字放在global namespace中，在新的方式下（指的是诸如cstdio这样的头文件），名字是放在namespace std中的。因此，新的方式是所有应用推荐的方式，除非是要编写与C严格兼容的程序 Standard Template Library-STL 标准模板库（Standard Template Library，STL）是惠普实验室开发的一系列软件的统称。STL的代码从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器）；在C++标准中，STL被组织为下面的13个头文件：、、、、、、、、、、、和。 C++ 对模板（Template）支持得很好，STL 就是借助模板把常用的数据结构及其算法都实现了一遍，并且做到了数据结构和算法的分离。STL封装了很多实用的容器，省时省力，能够让你将更多心思放到解决问题的步骤上，而非费力去实现数据结构诸多细节上，像极了用python时候的酣畅淋漓。 P.S. 如果你对STL源码颇有兴趣，那你不妨拜读C++大师侯捷的杰作《STL源码剖析》。 STL是提高C++编写效率的一个利器. STL六大部件 容器（Containers） 分配器（Allocators） 算法（Algorithm） 迭代器（Iterators） 适配器（Adapters） 仿函数（Functors） vector #include &lt; vector &gt; vector是变长数组，支持随机访问，不支持在任意位置O(1)插入。为了保证效率，元素的增删一般应该在末尾进行。 声明: \\#include &lt; vector &gt; 头文件 //引用vector是必须在头文件添加的 vector&lt; int &gt; a; 相当于一个长度动态变化的int数组 //初始化动态数组 vector&lt; int &gt; b[233]; 相当于第一维长233，第二维长度动态变化的int数组 struct rec{…}; vector&lt; rec &gt; c; 自定义的结构体类型也可以保存在vector中 //结构体数组 size/empty size函数返回vector的实际长度（包含的元素个数），empty函数返回一个bool类型，表明vector是否为空。二者的时间复杂度都是O(1)。 -&gt; 所有的STL容器都支持这两个方法，含义也相同，之后我们就不再重复给出。 lear clear函数把vector清空。 迭代器 迭代器就像STL容器的“指针”，可以用星号“*”操作符解除引用。 一个保存int的vector的迭代器声明方法为： vector&lt; int &gt;::iterator it; vector&lt; int &gt;::iterator是迭代器引用，it是迭代器的命名。 vector的迭代器是“随机访问迭代器”，可以把vector的迭代器与一个整数相加减，其行为和指针的移动类似。可以把vector的两个迭代器相减，其结果也和指针相减类似，得到两个迭代器对应下标之间的距离。 begin/end begin函数返回指向vector中第一个元素的迭代器。例如a是一个非空的vector，则***a.begin()与a[0]**的作用相同。 所有的容器都可以视作一个“前闭后开”的结构，end函数返回vector的尾部，即第n个元素再往后的“边界”。*a.end()与a[n]都是越界访问，其中n=a.size()。 front/back front函数返回vector的第一个元素，等价于*a.begin() 和 a[0]。 back函数返回vector的最后一个元素，等价于*==a.end() 和 a[a.size() – 1]。 push_back() and pop_back() a.push_back(x) 把元素x插入到vector a的尾部。 b.pop_back() 删除vector a的最后一个元素。 queue #include &lt; queue &gt; 头文件queue主要包括循环队列queue和优先队列priority_queue两个容器。 声明 queue&lt; int &gt; q; struct rec{…}; queue&lt; rec &gt; q; //结构体rec中必须定义小于号 priority_queue&lt; int &gt; q; // 大根堆 priority_queue&lt;int, vector&lt; int &gt;, greater&lt; int &gt; q; // 小根堆 priority_queue&lt;pair&lt;int, int&gt;&gt;q; 循环队列 queue push 从队尾插入 pop 从队头弹出 front 返回队头元素 back 返回队尾元素 优先队列 priority_queue push 把元素插入堆 pop 删除堆顶元素 top 查询堆顶元素（最大值） stack #include &lt; stack &gt; 头文件stack包含栈。 声明 stack&lt; int &gt; st; push 向栈顶插入 pop 弹出栈顶元素 deque #include &lt; deque &gt; 双端队列deque是一个支持在两端高效插入或删除元素的连续线性存储空间。它就像是vector和queue的结合。与vector相比，deque在头部增删元素仅需要O(1)的时间；与queue相比，deque像数组一样支持随机访问。 begin/end 返回deque的头/尾迭代器 front/back 队头/队尾元素 push_back 从队尾入队 push_front 从队头入队 pop_back 从队尾出队 pop_front 从队头出队 clear 清空队列 set #include &lt; set &gt; 头文件set主要包括set和multiset两个容器，分别是“有序集合”和“有序多重集合”，即前者的元素不能重复，而后者可以包含若干个相等的元素。set和multiset的内部实现是一棵红黑树，它们支持的函数基本相同。 声明 set&lt; int &gt; s; struct rec{…}; set&lt; rec &gt; s; // 结构体rec中必须定义小于号 multiset&lt; double &gt; s; size/empty/clear 与vector类似 迭代器 set和multiset的迭代器称为“双向访问迭代器”，不支持“随机访问”，支持星号(*)解除引用，仅支持“++”和“—–”两个与算术相关的操作。 设it是一个迭代器，例如set&lt; int &gt;::iterator it; 若把it++，则it会指向“下一个”元素。这里的“下一个”元素是指在元素从小到大排序的结果中，排在it下一名的元素。同理，若把it--，则it将会指向排在“上一个”的元素。 begin/end 返回集合的首、尾迭代器，时间复杂度均为O(1)。 s.begin() 是指向集合中最小元素的迭代器。 s.end() 是指向集合中最大元素的下一个位置的迭代器。换言之，就像vector一样，是一个“前闭后开”的形式。因此--s.end()是指向集合中最大元素的迭代器。 insert s.insert(x)把一个元素x插入到集合s中，时间复杂度为O(logn)。 在set中，若元素已存在，则不会重复插入该元素，对集合的状态无影响。 find s.find(x) 在集合s中查找等于x的元素，并返回指向该元素的迭代器。若不存在，则返回s.end()。时间复杂度为O(logn)。 lower_bound/upper_bound 这两个函数的用法与find类似，但查找的条件略有不同，时间复杂度为 O(logn)。 s.lower_bound(x) 查找大于等于x的元素中最小的一个，并返回指向该元素的迭代器。 s.upper_bound(x) 查找大于x的元素中最小的一个，并返回指向该元素的迭代器。 erase 设it是一个迭代器，s.erase(it) 从s中删除迭代器it指向的元素，时间复杂度为O(logn) 设x是一个元素，s.erase(x) 从s中删除所有等于x的元素，时间复杂度为O(k+logn)，其中k是被删除的元素个数。 count s.count(x) 返回集合s中等于x的元素个数，时间复杂度为 O(k +logn)，其中k为元素x的个数。 map #include &lt; map &gt; map容器是一个键值对key-value的映射，其内部实现是一棵以key为关键码的红黑树。Map的key和value可以是任意类型，其中key必须定义小于号运算符。类比Python中的字典 声明 map&lt;key_type, value_type&gt; name; 例如： map&lt;long, long, bool&gt; vis; -&gt;map&lt;string, int&gt; hash;//哈希结构重点理解，熟练运用 map&lt;pair&lt;int, int&gt;, vector&lt;int&gt;&gt; test; size/empty/clear/begin/end 均与set类似 insert/erase 与set类似，但其参数均是pair&lt;key_type, value_type&gt; find h.find(x) 在变量名为h的map中查找key为x的二元组。 []操作符 hash[key] 返回key映射的value的引用，时间复杂度为O(logn)。 []操作符是map最吸引人的地方。我们可以很方便地通过hash[key]来得到key对应的value，还可以对h[key]进行赋值操作，改变key对应的value。 常用库函数 常用库函数 万能头文件 #include&lt;bits/stdc++.h&gt; #include&lt; algorithm &gt; reverse 翻转 翻转一个vector： reverse(a.begin(), a.end()); 翻转一个数组，元素存放在下标1~n： reverse(a + 1, a + 1 + n); unique 去重 返回去重之后的尾迭代器（或指针），仍然为前闭后开，即这个迭代器是去重之后末尾元素的下一个位置。该函数常用于离散化，利用迭代器（或指针）的减法，可计算出去重后的元素个数。 把一个vector去重： int m = unique(a.begin(), a.end()) – a.begin(); 把一个数组去重，元素存放在下标1~n： int m = unique(a + 1, a + 1 + n) – (a + 1); random_shuffle 随机打乱 用法与reverse相同 sort 对两个迭代器（或指针）指定的部分进行快速排序。可以在第三个参数传入定义大小比较的函数，或者重载“小于号”运算符。 把一个int数组（元素存放在下标1~n）从大到小排序，传入比较函数： int a[MAX_SIZE]; bool cmp(int a, int b) {return a &gt; b; } sort(a + 1, a + 1 + n, cmp); 把自定义的结构体vector排序，重载“小于号”运算符： struct rec{ int id, x, y; } vector&lt; rec &gt; a; bool operator &lt;(const rec &amp;a, const rec &amp;b) { return a.x &lt; b.x || a.x == b.x &amp;&amp; a.y &lt; b.y; } sort(a.begin(), a.end()); lower_bound/upper_bound 二分 lower_bound 的第三个参数传入一个元素x，在两个迭代器（指针）指定的部分上执行二分查找，返回指向第一个大于等于x的元素的位置的迭代器（指针）。 upper_bound 的用法和lower_bound大致相同，唯一的区别是查找第一个大于x的元素。当然，两个迭代器（指针）指定的部分应该是提前排好序的。 在有序int数组（元素存放在下标1~n）中查找大于等于x的最小整数的下标： int I = lower_bound(a + 1, a + 1 + n,x) – a; 在有序vector&lt; int &gt; 中查找小于等于x的最大整数（假设一定存在）： int y = *--upper_bound(a.begin(), a.end(), x); string函数 string的构造函数的形式 #include引入第三方库，库中常用的方法： string str：生成空字符串 string s(str)：生成字符串为str的复制品 string s(str, strbegin,strlen)：将字符串str中从下标strbegin开始、长度为strlen的部分作为字符串初值 string s(cstr, char_len)：以C_string类型cstr的前char_len个字符串作为字符串s的初值 string s(num ,c)：生成num个c字符的字符串 string s(str, stridx)：将字符串str中从下标stridx开始到字符串结束的位置作为字符串初值 string的大小和容量： **size()**和length()：返回string对象的字符个数，他们执行效果相同。 max_size()：返回string对象最多包含的字符数，超出会抛出length_error异常 capacity()：重新分配内存之前，string对象能包含的最大字符数 string的字符串比较： C ++字符串支持常见的比较操作符（&gt;,&gt;=,&lt;,&lt;=,==,!=），甚至支持string与C-string的比较。在使用&gt;,&gt;=,&lt;,&lt;=这些操作符的时候，根据“当前字符特性”将字符按字典顺序进行逐一得 比较。字典排序靠前的字符小，比较的顺序是从前向后比较，遇到不相等的字符就按这个位置上的两个字符的比较结果确定两个字符串的大小(前面减后面)。 另一个功能强大的比较函数是成员函数compare()。他支持多参数处理，支持用索引值和长度定位子串来进行比较。 他返回一个整数来表示比较结果，返回值意义如下：0：相等 1：大于 -1：小于 string的插入：push_back() 和 insert() push_back(‘插入的字符’)是尾插入法 insert(s.begin(),‘插入的字符’)是特殊位置的插入法 // 方法一：append() string s1(&quot;abc&quot;); s1.append(&quot;def&quot;); cout&lt;&lt;&quot;s1:&quot;&lt;&lt;s1&lt;&lt;endl; // s1:abcdef // 方法二：+ 操作符 string s2 = &quot;abc&quot;; /*s2 += &quot;def&quot;;*/ string s3 = &quot;def&quot;; s2 += s3.c_str(); string的遍历：借助迭代器 或者 下标法 // 方法一： 下标法 for( int i = 0; i &lt; s1.size() ; i++ ) { cout&lt;&lt;s1[i]; } cout&lt;&lt;endl; // 方法二：正向迭代器 string::iterator iter = s1.begin(); for( ; iter &lt; s1.end() ; iter++) { cout&lt;&lt;*iter; } cout&lt;&lt;endl; // 方法三：反向迭代器 string::reverse_iterator riter = s1.rbegin(); for( ; riter &lt; s1.rend() ; riter++) { cout&lt;&lt;*riter; } cout&lt;&lt;endl; string的删除：erase() iterator erase(iterator p);//删除字符串中p所指的字符 iterator erase(iterator first, iterator last);//删除字符串中迭代器 区间[first,last)上所有字符 string的字符替换： string&amp; replace(size_t pos, size_t n, const char *s);//将当前字符串从pos索引开始的n个字符，替换成字符串s string&amp; replace(size_t pos, size_t n, size_t n1, char c); //将当前字符串从pos索引开始的n个字符，替换成n1个字符c string&amp; replace(iterator i1, iterator i2, const char* s);//将当前字符串[i1,i2)区间中的字符串替换为字符串s string的大小写转换：tolower()和toupper()函数 或者 STL中的transform算法 string的查找：find string s(&quot;I like C++ and Python.&quot;); // 1. 查找一个字符串 cout &lt;&lt; s.find(&quot;chicken&quot;) &lt;&lt; endl; // 结果是：9 // 2. 从下标为6开始找字符'i'，返回找到的第一个i的下标 cout &lt;&lt; s.find('i',6) &lt;&lt; endl; // 结果是：11 // 3. 从字符串的末尾开始查找字符串，返回的还是首字母在字符串中的下标 cout &lt;&lt; s.rfind(&quot;chicken&quot;) &lt;&lt; endl; // 结果是：9 // 4. 从字符串的末尾开始查找字符 cout &lt;&lt; s.rfind('i') &lt;&lt; endl; // 结果是：18--因为是从末尾开始查找，所以返回第一次找到的字符 string的排序：sort(s.begin( ),s.end( )) string s = &quot;cdefba&quot;; sort(s.begin(),s.end()); string的分割/截取字符串：strtok() &amp; substr() string s1(&quot;0123456789&quot;); string s2 = s1.substr(2,5); // 结果：23456-----参数5表示：截取的字符串的长度 ------------------- char str[] = &quot;I,am,a,student; hello world!&quot;; const char *split = &quot;,; !&quot;; char *p2 = strtok(str,split); while( p2 != NULL ) { cout&lt;&lt;p2&lt;&lt;endl; p2 = strtok(NULL,split); } C语言中的字符串处理函数 strlen 函数功能：计算字符串str1的长度 返回值：一个int值 注意：字符串的长度不包括字符’\\0’ char str1[20] = &quot;We are csdn!&quot;; int size = strlen(str1); printf(&quot;%d\\n&quot;, size); //size = 12 strcpy 函数功能：将字符串str2复制到字符串str1中，并覆盖str1原始字符串，可以用来为字符串变量赋值 返回值：str1 注意：1）字符串str2会覆盖str1中的全部字符，2）字符串str2的长度不能超过str1 char str1[] = &quot;We are Chinese!&quot;; char str2[] = &quot;Hello!&quot;; strcpy_s(str1, str2); //str = Hello! strcat 原型：strcat(str1,str2); 功能：将字符串str2添加到字符串str1的尾部，也就是拼接两个字符串 原型2：strncat(str1,str2,n); 功能2：将字符串str2的前n个字符添加到字符串str1的尾部 char str1[20] = &quot;We are csdn!&quot;; char str2[] = &quot;Hello!&quot;; strcat_s(str1, str2); printf(&quot;str1 = %s\\n&quot;, str1); //str1 = We are csdn!Hello! strcmp 原型：strcmp(str1,str2); 功能：比较两个字符串，如果两个字符串相等，则返回0； 若str1大于str2（对于大于的理解，是指从两个字符串的第一个字符开始比较，若两个字符相同，则继续比较，若发现两个字符不相等，且str1中该字符的ASCII码大于str2中的，则表示str1大于str2），返回一个正数（这个正数不一定是1）； 若str1小于str2，返回一个负数（不一定是-1）；若字符串str1的长度大于str2，且str2的字符与str1前面的字符相同，则也相对于str1大于str2处理 原型2：strncmp(str1,str2,n); 功能2：比较两个字符串的前n个字符 char str1[] = &quot;Wearecsdn!&quot;; char str2[] = &quot;Wearecsdn!&quot;; char str3[] = &quot;Wearea!&quot;; char str4[] = &quot;Wearef!&quot;; int cmp1 = strcmp(str1, str2); //cmp1=0 int cmp2 = strcmp(str1, str3); //cmp2=1 int cmp5 = strncmp(str1, str2, 5); //cmp5=0 int cmp6 = strncmp(str1, str3, 5); //cmp6=0 程序中的科学计数法 今天学c看到const int a=1e6+10不是很理解,原来是科学计数法的表示形式。 const int a=1e6+10=1000010；1∗106+101*10^6+101∗106+10 6.555e6+10=6555010；6.555∗106+106.555*10^6+106.555∗106+10 面向对象 VS Code 基本配置 编译C/C++程序 首先在自己的电脑上配置MinGw64，之后将其添加到环境变量当中去。 之后新建一个文件夹，注意要用英文命名，通过vs code打开。 最后写一段程序，在运行选项栏里选择以非调试模式运行，生成.vs code文件夹，里面包含了launch.json和tasks.json文件。 launch.json文件的配置： { // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;g++.exe - 生成和调试活动文件&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${fileDirname}\\\\exe\\\\${fileBasenameNoExtension}.exe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;${fileDirname}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: true, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;E:\\\\mingw64\\\\bin\\\\gdb.exe&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;为 gdb 启用整齐打印&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true }, { &quot;description&quot;: &quot;将反汇编风格设置为 Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true } ], &quot;preLaunchTask&quot;: &quot;C/C++: g++.exe 生成活动文件&quot; } ] } tasks.json文件的配置： { &quot;tasks&quot;: [ { &quot;type&quot;: &quot;cppbuild&quot;, &quot;label&quot;: &quot;C/C++: g++.exe 生成活动文件&quot;, &quot;command&quot;: &quot;E:\\\\mingw64\\\\bin\\\\g++.exe&quot;, &quot;args&quot;: [ &quot;-fdiagnostics-color=always&quot;, &quot;-g&quot;, &quot;${file}&quot;, &quot;-o&quot;, &quot;${fileDirname}\\\\exe\\\\${fileBasenameNoExtension}.exe&quot;, &quot;-fexec-charset=GBK&quot; ], &quot;options&quot;: { &quot;cwd&quot;: &quot;${fileDirname}&quot; }, &quot;problemMatcher&quot;: [ &quot;$gcc&quot; ], &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true }, &quot;detail&quot;: &quot;调试器生成的任务。&quot; } ], &quot;version&quot;: &quot;2.0.0&quot; } 常见错误 undefined reference to 'WinMain' collect2.exe: error: ld returned 1 exit status 解决办法：没有在c/cpp文件中写出main函数,而且main别写错！！ 编译Python程序-jupyter lab 经典概念辨析 编译器是对代码进行编译，转换为包含在目标文件中的机器语言版本(字节码)，生成扩展名为.o/.obj的目标文件；解释器是 标识符和关键字 标识符：编写程序时使用字符集中的字符组合成一系列“单词”代表变量、常量、函数等。用于声明的这些“单词”称为标识符。 用户自定义的标识符：由程序员定义说明的标识符，包括程序中使用的变量名、符号常量名、函数名、结构体类型名、共用体类型名等。 自定义标识符的定义遵循规则： 只由英文、数字、或 _（下划线） 组成 第一个字符只能是英文字母或下划线，不能是数字 大小写英文字母代表不同的字符 不能是C/C++语言的关键字 关键字：系统预定说明的标识符称为关键字 1.数据类型关键字 char、int、short、long、float、double、signed、unsigned、struct、union、enum、void 2.存储类型关键字 auto、register、static、extern 3.流程控制关键字 if、else、switch、default、case、while、do、for、break、continue、return、goto 4.其他关键字 sizeof、typedef、const、volatile 正确标识符命名： smart _decision high3 Area 不正确标识符命名：5smart(以数字开头) Bomb?(含有特殊字符？) High.balance(把下划线“_”与“.”混淆) float（不能用C语言中的关键字） 变量的声明和定义 声明的两种方式： 一种是需要建立存储空间的： 例如：int a ;在声明的时候就已经建立了存储空间。这种声明是”定义性声明(defining declaration)”，即我们平时所说的“定义”。 另一种是不需要建立存储空间的： 只是告诉编译器某变量已经在别处定义过了。例如：extern int a。其中，变量a是在别处定义的。这种声明是”引用性声明(referncing declaration)”，即我们平时所说的“声明”。 例子： int a; //定义性声明，分配存储空间，初值不确定 int b = 0; //定义性声明，分配存储空间，赋初值 extern int c; //引用性声明，不分配存储空间，只是告诉编译器这个变量已经在别处定义过了 函数的声明和定义 函数的定义和声明也是一样，定义需要分配存储空间；声明只是告诉编译器这个函数已经在别处定义过了。函数的定义和声明比较好区分。有函数体的即为定义，不带函数体即为声明。 //声明 double sqrt(double x); //定义 double sqrt(double x) { return x*x; } c++零基础入门99题——夜深人静写算法 1.函数2235 给你两个整数 num1 和 num2，返回这两个整数的和。 class Solution { public: int sum(int num1, int num2) { return num1 + num2; } }; 2.库函数69 给你一个非负整数 x ，计算并返回 x 的 算术平方根 。 由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。 注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。 class Solution { public: int mySqrt(int x) { //库函数的使用 return (int)sqrt(x); } }; 7.29-7.30错误总结与复盘（强基计划） 1.数组的二维遍历初始值的设定(2006) for(int i = 0;i &lt; nums.size();i++){ for(int j = i;j &lt; nums.size();j++){ .......; } } 2.冒泡排序 int temp; for(int i = 0;i &lt; nums.size();i++){ for(int j = 0;j &lt; nums.size();j++){ if(nums[j] &gt; nums[j+1]){ temp = nums[j]; nums[j+1] = nums[j]; nums[j] = nums[j+1]; } } } 3.sum的位置(1672) class Solution { public: int maximumWealth(vector&lt;vector&lt;int&gt;&gt;&amp; accounts) { int maxv = 0; //一个是放在这里 //int sum = 0; for(int i =0;i &lt; accounts.size();i++){ //一个是放在这里 int sum = 0; for(int j = 0;j &lt; accounts[i].size();j++){ sum += accounts[i][j]; } maxv = max(maxv,sum); } return maxv; } }; 放在初始求得是全部数组中每行的和；放在后面求的是二维数组中单独行的和。 4.二分查找应用条件是——有序数组 结合矩阵中元素的搜索 /2和&gt;&gt;1的区别：（c++) 1.操作对象类型不同是右移符百号，它在操度作时只允许整数 /是除法，它可以操作不同类型的数据：浮点数除法最终结果是浮点数，整数除法的最终结果是整数。 只有当被操作数数据类型为知大于0的整数时，运算道结果才是内相同的。 2.运算效率不同 右移操作通常情况下，会比整数除法速度快。涉及容到浮点数的除法速度是最慢的。 3.优先级不同 右移运算的优先级比除法低，在同时参与的运算中，先计算乘除，后计算左移或右移 8月-10错误总结与复盘（强基计划） 加深对递归函数调用的过程理解与实战书写；只有过程清晰了，才能跟高的运用递归函数去提高效率。 scanf与scanf_s安全性问题： #define _CRT_SECURE_NO_WARNINGS-&gt;解除安全隐患 同样gets也不再支持而改用gets_s #include&lt;stdio.h&gt; //进程数量-&gt;题目中是五个 void process(){ } void cpu(){ process(); func1(); func2(); func3(); func4(); func5(); } void func1(){ //x=操作的实现 } void func2(){ //x++操作的实现 } void func3(){ //x--操作的实现 } void func4(){ //！？？操作的实现 } void func5(){ //操作的实现 } int main(){ cpu(); } ","link":"https://Mungeryang.github.io/post/cc-for-everyonr/"},{"title":"测试文章","content":"你好，这里是杨桂淼的博客网站！ ","link":"https://Mungeryang.github.io/post/ce-shi-wen-zhang/"},{"title":"指南","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://Mungeryang.github.io/post/hello-gridea/"}]}